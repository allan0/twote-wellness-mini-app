<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Third Eye - Game</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon"> <!-- Placeholder for favicon -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #4E342E;
            --text-color: #FFF8E1;
            --button-color: #FFD700;
            --button-text-color: #3E2723;
            --wellness-manager-color: #3E2723; /* Dark brown */
            --warning-color: #d9534f; /* Bootstrap danger-ish red */
            --challenge-description-color: #3E2723; /* Dark brown for challenge descriptions */
            --level-color: #00bcd4; /* Cyan for level */
            --achievement-color: #ff9800; /* Orange for achievements */
            --wheel-pointer-color: #FF0000; /* Red pointer */
        }
        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            padding-bottom: 70px; /* Space for footer nav */
        }
        #backgroundVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            opacity: 0.3; /* Dim the video */
        }
        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 15px;
        }
        .section {
            background: rgba(62, 39, 35, 0.7); /* Darker brown, semi-transparent */
            backdrop-filter: blur(8px);
            padding: 20px; /* Reduced padding */
            border-radius: 15px; /* Slightly smaller radius */
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 248, 220, 0.2); /* Subtle border */
        }
        .challenge-div {
            background: rgba(255, 255, 255, 0.9); /* Lighter background for contrast */
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: var(--challenge-description-color);
        }
         .challenge-div h3, .challenge-div h4 {
             color: var(--challenge-description-color);
             margin-bottom: 10px;
             font-size: 1.1rem; /* Consistent size */
         }
        .challenge-div p {
             color: var(--challenge-description-color);
             font-size: 0.9rem; /* Slightly smaller */
             margin-bottom: 8px;
        }
         .challenge-div .warning-text {
            color: var(--warning-color);
            font-weight: bold;
            font-size: 0.85rem;
        }
        .challenge-icon {
            font-size: 2em; /* Smaller */
            margin-bottom: 8px;
            color: var(--challenge-description-color); /* Match text */
        }
        /* Use icon inside the challenge-div specifically */
        .challenge-div > i.challenge-icon {
            color: var(--wellness-manager-color); /* Darker icon */
        }

        .modal-content {
            background: var(--bg-color);
            color: var(--text-color);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
        }
        .modal-header, .modal-footer {
            border: none;
        }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%); }

        .btn-custom {
            background-color: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 8px 16px; /* Smaller padding */
            border-radius: 8px;
            font-weight: 600; /* Slightly bolder */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .btn-custom:hover, .btn-custom:focus {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: var(--button-text-color);
            background-color: var(--button-color); /* Keep color on hover */
        }
         .btn-custom:active {
             transform: translateY(0px);
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
         }
         .btn-custom:disabled {
             background-color: #a0a0a0;
             cursor: not-allowed;
             opacity: 0.7;
             transform: none;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
         }

        .btn-danger {
            background-color: var(--warning-color);
            color: #fff;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
             transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .btn-danger:hover, .btn-danger:focus {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: #fff;
            background-color: var(--warning-color); /* Keep color */
        }
        .btn-danger:active {
             transform: translateY(0px);
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
         }

        .locked {
            opacity: 0.6;
            background: rgba(200, 200, 200, 0.7); /* Grey out locked challenges */
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0; /* Reduced padding */
            margin-bottom: 15px;
        }
        /* Style for the logo.webp */
        header img[src="logo.webp"] {
            width: 35px; /* Smaller logo */
            height: 35px;
            /* Removed border-radius: 50%; if logo is not circular */
            margin-right: 8px;
            vertical-align: middle; /* Align with text */
        }
        header h1 {
            margin: 0;
            font-size: 1.5rem; /* Smaller title */
            color: var(--text-color);
            font-weight: 700;
            display: inline-block; /* Keep H1 on same line */
            vertical-align: middle;
        }
        #profileLink { cursor: pointer; }
        #profilePhoto {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid var(--button-color); /* Highlight profile pic */
        }
        #profileNameDisplay, #profileLevelDisplay, #pointsDisplay, #energyHeaderDisplay { /* Added energyHeaderDisplay */
            font-size: 0.8rem; /* Smaller text */
            line-height: 1.2;
            text-align: right;
            margin-top: 2px;
            color: var(--text-color); /* Default color */
        }
        #profileNameDisplay { font-weight: bold; }
        #pointsDisplay { color: var(--button-color); font-weight: bold; }
        #profileLevelDisplay { color: var(--level-color); font-size: 0.75rem; }
        #energyHeaderDisplay { color: #87CEEB; font-weight: bold;} /* Specific color for energy */


        h2 {
             color: var(--text-color);
             text-align: center;
             margin-bottom: 15px; /* Reduced margin */
             font-size: 1.4rem; /* Slightly smaller */
             font-weight: 700;
         }
         h3 {
             color: var(--text-color);
             font-size: 1.2rem;
             font-weight: 600;
         }
         h4 {
            color: var(--text-color);
            font-size: 1rem;
            font-weight: 600;
         }

        .warning-text {
            color: var(--warning-color);
            font-weight: bold;
        }
        .footer-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(78, 52, 46, 0.9); /* Slightly less transparent */
            padding: 8px 0; /* Reduced padding */
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        .footer-nav a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 12px; /* Smaller font */
            text-align: center;
            transition: color 0.2s, transform 0.2s; /* Added color transition */
            flex: 1;
            padding: 4px 0;
        }
        .footer-nav a:hover {
             color: var(--button-color); /* Highlight on hover */
             transform: scale(1.1);
        }
        .footer-nav a.active { /* Style for the active tab */
            color: var(--button-color);
            transform: scale(1.1);
            font-weight: bold;
        }
        .footer-nav a i {
            display: block;
            font-size: 18px; /* Smaller icons */
            margin-bottom: 2px;
        }
        .task-icon {
            font-size: 1.5em; /* Smaller */
            margin-right: 8px;
            color: var(--text-color);
        }
        #socialMediaTasks ul { list-style-type: none; padding: 0; }
        #socialMediaTasks li { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; flex-wrap: wrap; background: rgba(0,0,0,0.1); padding: 8px; border-radius: 5px;}
        #socialMediaTasks li > div { display: flex; align-items: center; margin-right: 10px; margin-bottom: 5px; }
        #socialMediaTasks a { color: var(--text-color); text-decoration: underline; margin-left: 5px; font-weight: 600;}
        #socialMediaTasks a:hover { text-decoration: none; }
        #socialMediaTasks button { padding: 5px 10px; font-size: 0.8em; }

        #referralTask { margin-top: 20px; background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px; }
        #referralTask p { margin-bottom: 10px; font-size: 0.9rem;}
        #referralTask input[type="text"] { background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: var(--text-color); padding: 8px; border-radius: 5px; font-size: 0.9rem;}
        #referralTask button { width: 80px; font-size: 0.9rem; padding: 6px 10px;}

        /* Game Page specific styles */
        .wheel-button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); /* Further adjust min width */
            gap: 8px; /* Slightly smaller gap */
            margin-bottom: 15px;
        }
        .wheel-button {
            padding: 8px 5px; /* Smaller padding */
            font-size: 0.75em; /* Smaller font */
            text-align: center;
            display: flex; /* Flex layout for icon and text */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60px; /* Ensure consistent height */
            line-height: 1.1; /* Tighter line height */
        }
         .wheel-button i {
             font-size: 1.3em; /* Smaller icon */
             margin-bottom: 3px;
         }
         .wheel-button span.spins-left { /* Style for spin count */
            display: block;
            font-size: 0.85em; /* Slightly larger relative to button text */
            opacity: 0.8;
            margin-top: 2px;
         }

         .mystery-box-section {
            text-align: center;
            margin-top: 20px;
            border-top: 1px solid rgba(255, 248, 220, 0.2);
            padding-top: 20px;
            background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px;
         }
         .mystery-box-section .fa-box-open {
             font-size: 2.5em; /* Smaller */
             color: var(--button-color);
             margin-bottom: 8px;
         }
         #mysteryBoxCount {
             font-weight: bold;
             color: var(--button-color);
         }

         /* Progression & Achievements */
         #levelDisplay {
             font-size: 1rem; /* Smaller */
             font-weight: bold;
             color: var(--level-color);
             margin-bottom: 10px;
             text-align: center;
         }
         #achievementsList {
             list-style: none;
             padding: 0;
             text-align: center;
             margin-bottom: 20px;
         }
         #achievementsList li {
             display: inline-block;
             background: rgba(0,0,0, 0.4); /* Darker */
             color: var(--achievement-color);
             padding: 4px 8px; /* Smaller */
             border-radius: 12px;
             margin: 3px;
             font-size: 0.8em; /* Smaller */
             border: 1px solid var(--achievement-color);
             cursor: default; /* Indicate it's clickable for title */
         }
         #achievementsList li i {
             margin-right: 4px;
         }
         .subscription-info {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px dashed rgba(255, 248, 220, 0.3);
             text-align: center;
             font-size: 0.85em;
             opacity: 0.8;
         }


        /* Responsive Design */
        @media (max-width: 576px) {
            .container { padding: 0 10px; }
            .section { padding: 15px; margin-bottom: 10px;}
            .challenge-div { padding: 10px; }
            .challenge-icon { font-size: 1.8em; }
            h1 { font-size: 1.3rem; } h2 { font-size: 1.2rem; } h3 { font-size: 1.1rem; }
            .challenge-div h3, .challenge-div h4 { font-size: 1rem; }
            p { font-size: 0.85rem; }
            .footer-nav a { font-size: 11px; } .footer-nav a i { font-size: 16px; }
            header { flex-direction: column; text-align: center; }
            header > div:last-child { margin-top: 8px; text-align: center;} /* Center profile info */
            #profileNameDisplay, #profileLevelDisplay, #pointsDisplay, #energyHeaderDisplay { text-align: center; width: 100%;}
            #socialMediaTasks li { flex-direction: column; align-items: flex-start;}
            #socialMediaTasks li > div { margin-bottom: 8px; }
            #socialMediaTasks button { width: 100%; margin-top: 5px; font-size: 0.8em;}
            #referralTask { flex-direction: column; }
            #referralTask input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px;}
            #referralTask button { width: 100%; }
            .wheel-button-grid { grid-template-columns: repeat(2, 1fr); gap: 8px;} /* Force 2 columns */
            .wheel-button { font-size: 0.7em; min-height: 55px;} /* Even smaller */
            .wheel-button i { font-size: 1.2em;}
            .table th, .table td { padding: 0.4rem 0.3rem; font-size: 0.8rem;} /* Smaller table text */
            .table img { max-width: 30px; }
        }

        /* Table styling */
        .table { color: var(--text-color); background-color: rgba(0, 0, 0, 0.3); border-radius: 8px; overflow: hidden; margin-top: 15px; border-collapse: separate; border-spacing: 0; font-size: 0.9rem;}
        .table th, .table td { border-top: 1px solid rgba(255, 248, 220, 0.15); padding: 0.5rem 0.4rem; vertical-align: middle; }
        .table thead th { color: var(--button-color); background-color: rgba(0, 0, 0, 0.5); border-top: none; border-bottom: 2px solid var(--button-color); font-weight: bold; text-align: center; }
        .table tbody tr:first-child td { border-top: none; }
        .table tbody tr:hover { background-color: rgba(255, 248, 220, 0.08); }
        .table img { max-width: 35px; height: auto; border-radius: 4px; }
        .table .table-primary td, .table tr.table-primary { background-color: rgba(var(--button-color), 0.2) !important; font-weight: bold; } /* Applied to TR */
        .table .rank-col { width: 50px; text-align: center;}
        .table .points-col { width: 100px; text-align: right;}
        .table-responsive { border-radius: 8px; }
        .table-sm th, .table-sm td { padding: 0.4rem 0.4rem; } /* Keep table-sm adjustments */
        .table .text-success { color: #28a745 !important; }
        .table .text-danger { color: var(--warning-color) !important; }

        /* Energy Log Modal Enhancements */
        .form-range::-webkit-slider-thumb { background-color: var(--button-color); }
        .form-range::-moz-range-thumb { background-color: var(--button-color); }
        #challengeTasks { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px; margin-top: 15px;}
        #challengeTasks p { font-size: 0.9rem; }
        #challengeTasks .form-control-sm { font-size: 0.8rem; padding: 0.3rem 0.6rem;}

        /* Wheel Modal Styles */
        #wheelModal .modal-dialog {
            max-width: 90vw;
            width: 320px; /* Slightly smaller */
            margin: 1.75rem auto; /* Bootstrap default centering */
        }
        .wheel-outer-container {
            padding: 15px;
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            flex-direction: column; /* Stack pointer and wheel */
            background: rgba(0,0,0,0.2); /* Slight background in modal body */
            border-radius: 10px;
            min-height: 300px; /* Give it some space */
        }
        .wheel-pointer {
            width: 0;
            height: 0;
            border-left: 12px solid transparent; /* Smaller pointer */
            border-right: 12px solid transparent;
            border-top: 20px solid var(--wheel-pointer-color); /* Arrow pointing down */
            position: relative; /* Keep relative positioning */
            top: -8px; /* Position above the wheel */
            z-index: 10;
            margin-bottom: -12px; /* Adjust spacing */
        }
        .wheel-container {
            width: 220px; /* Smaller wheel */
            height: 220px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 4px solid var(--button-color);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            /* margin: 0 auto; Remove if using flex centering */
        }
        .wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative; /* Needed for absolute positioning of segments */
            background: conic-gradient( /* Slightly adjusted colors for visual */
                #ffd700 0% 12.5%, #ffa500 12.5% 25%, /* Gold, Orange */
                #ff7f50 25% 37.5%, #ff6347 37.5% 50%, /* Coral, Tomato */
                #cd5c5c 50% 62.5%, #fa8072 62.5% 75%, /* IndianRed, Salmon */
                #e9967a 75% 87.5%, #f0e68c 87.5% 100% /* DarkSalmon, Khaki */
            );
            transition: transform 4s cubic-bezier(0.25, 0.1, 0.25, 1); /* Spin animation */
            transform: rotate(0deg); /* Initial position */
        }
        /* Emoji Segments */
        .wheel-segment {
            position: absolute;
            width: 50px; /* Adjust size as needed */
            height: 50px;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            margin-top: -25px; /* Half of height */
            margin-left: -25px; /* Half of width */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.6em; /* Adjust emoji size */
            /* Calculated rotation and translation */
            /* transform: rotate(calc(360deg / 8 * var(--i))) translateY(-80px) rotate(calc(-360deg / 8 * var(--i))); */
        }
         /* Position each segment manually */
         .wheel-segment:nth-child(1) { transform: rotate(22.5deg) translateY(-85px) rotate(-22.5deg); }
         .wheel-segment:nth-child(2) { transform: rotate(67.5deg) translateY(-85px) rotate(-67.5deg); }
         .wheel-segment:nth-child(3) { transform: rotate(112.5deg) translateY(-85px) rotate(-112.5deg); }
         .wheel-segment:nth-child(4) { transform: rotate(157.5deg) translateY(-85px) rotate(-157.5deg); }
         .wheel-segment:nth-child(5) { transform: rotate(202.5deg) translateY(-85px) rotate(-202.5deg); }
         .wheel-segment:nth-child(6) { transform: rotate(247.5deg) translateY(-85px) rotate(-247.5deg); }
         .wheel-segment:nth-child(7) { transform: rotate(292.5deg) translateY(-85px) rotate(-292.5deg); }
         .wheel-segment:nth-child(8) { transform: rotate(337.5deg) translateY(-85px) rotate(-337.5deg); }

         #wheelResultDisplay {
            margin-top: 15px;
            font-weight: bold;
            color: var(--button-color);
            text-align: center;
            min-height: 40px; /* Reserve space for multi-line messages */
            font-size: 1.1em;
            padding: 0 10px;
         }
    </style>
</head>
<body>
    <!-- Background video - consider performance on mobile -->
    <video id="backgroundVideo" autoplay muted loop playsinline>
        <source src="cosmic.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <div class="container">
        <header>
            <div class="d-flex align-items-center">
                 <!-- Replaced icon with image -->
                 <img src="logo.webp" alt="Third Eye Logo">
                 <h1>Third Eye</h1>
            </div>
            <div id="profileLink">
                <img id="profilePhoto" src="https://via.placeholder.com/40" alt="Profile">
                <span id="profileNameDisplay">Guest</span>
                 <span id="profileLevelDisplay">Level: Novice</span>
                <span id="pointsDisplay">0 $twote</span>
                 <span id="energyHeaderDisplay">NRG: 0%</span>
            </div>
        </header>

        <!-- Sections -->
        <div id="horoscopeForm" class="section" style="display: none;">
            <h2>Enter Your Birthdate</h2>
            <p style="text-align:center; font-size: 0.9rem;">To personalize your journey.</p>
            <input type="date" id="birthdate" class="form-control mb-2" style="background: rgba(255,255,255,0.1); color: var(--text-color); border-color: rgba(255,255,255,0.3);">
            <button class="btn btn-custom w-100 mt-2" id="saveHoroscopeBtn">Save & Continue</button>
        </div>

        <div id="wellnessManager" class="section" style="display: none;">
            <h2>Mindfulness Journey</h2>
            <p style="text-align: center; font-size: 0.9rem;">Select a challenge duration to begin.</p>
            <div id="challengeOptions" class="mt-3"></div>
        </div>

        <div id="dailyChallenges" class="section" style="display: none;">
            <h2 id="challengeTitle">Challenge</h2>
            <div id="dailyChallengeList"></div>
        </div>

        <div id="tasksSection" class="section" style="display: none;">
            <h2>Earn More $twote</h2>
             <div id="socialMediaTasks">
                 <h4 style="color: var(--button-color); margin-bottom: 15px; text-align:center;">Social Tasks (+10 $twote each)</h4>
                 <ul>
                     <li>
                         <div><i class="fab fa-telegram-plane task-icon"></i>Join <a href="https://t.me/ThirdEyeXai" target="_blank">Telegram</a></div>
                         <button class="btn btn-custom btn-sm" id="telegramTaskBtn">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-twitter task-icon"></i>Follow <a href="https://twitter.com/ThirdEyeXai" target="_blank">Twitter</a></div>
                         <button class="btn btn-custom btn-sm" id="twitterTaskBtn">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-instagram task-icon"></i>Follow <a href="https://instagram.com/ThirdEyeXai" target="_blank">Instagram</a></div>
                         <button class="btn btn-custom btn-sm" id="instagramTaskBtn">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-youtube task-icon"></i>Subscribe <a href="https://youtube.com/@ThirdEyeXai" target="_blank">YouTube</a></div>
                         <button class="btn btn-custom btn-sm" id="youtubeTaskBtn">Verify</button>
                     </li>
                 </ul>
             </div>
             <div id="referralTask" class="mt-3">
                 <h4 style="color: var(--button-color); margin-bottom: 10px; text-align:center;">Referral Task (+Bonus Spins!)</h4>
                 <p>Share your link! Both you and your friend earn $twote. You also get bonus spins!</p>
                 <div class="d-flex mb-2">
                     <input type="text" id="referralLink" class="form-control form-control-sm" readonly style="flex-grow: 1; margin-right: 10px;">
                     <button class="btn btn-custom" id="copyReferralBtn">Copy</button> <!-- Added ID -->
                 </div>
                 <button class="btn btn-secondary btn-sm mt-2 w-100" id="claimReferralRewardBtn">Simulate Friend Joined (Dev)</button>
             </div>
        </div>

        <div id="gamePage" class="section" style="display: none;">
            <h2>Engage & Earn</h2>
            <div class="text-center mb-3" style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px;">
                <button class="btn btn-custom w-75" id="dailyCheckInBtn">Daily Check-In</button>
                <p id="countdownDisplay" style="color: var(--button-color); margin-top: 10px; font-size: 0.85em;"></p>
            </div>

            <h4 style="text-align:center; margin-bottom: 10px; color: var(--button-color);">Daily Bonus Wheels</h4>
            <p id="spinInfo" class="text-center" style="font-size: 0.8em; margin-bottom: 15px;">Complete Daily Check-In to enable spins.</p>
            <div class="wheel-button-grid">
                <button class="btn btn-custom wheel-button" id="spinEnergyWheelBtn" data-wheel="energy">
                    <i class="fas fa-bolt"></i>Energy <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinSigilWheelBtn" data-wheel="sigil">
                    <i class="fas fa-magic"></i>Sigil <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinHappinessWheelBtn" data-wheel="happiness">
                    <i class="fas fa-smile-beam"></i>Happiness <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinWellnessWheelBtn" data-wheel="wellness">
                    <i class="fas fa-heartbeat"></i>Wellness <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinProsperityWheelBtn" data-wheel="prosperity">
                    <i class="fas fa-coins"></i>Prosperity <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinManifestationWheelBtn" data-wheel="manifestation">
                    <i class="fas fa-star"></i>Manifest <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinHealingWheelBtn" data-wheel="healing">
                    <i class="fas fa-hand-holding-heart"></i>Healing <span class="spins-left">(0)</span>
                </button>
                 <button class="btn btn-info wheel-button" id="useReferralSpinBtn" data-wheel="referral">
                    <i class="fas fa-gift"></i>Ref Spins <span id="referralSpinsCount" class="spins-left">(0)</span>
                 </button>
            </div>

            <div class="mystery-box-section">
                <i class="fas fa-box-open"></i>
                <h4 style="color: var(--button-color);">Mystery Boxes</h4>
                <p>Earn boxes from streaks & events!</p>
                <p>You have <span id="mysteryBoxCount">0</span> boxes.</p>
                <button class="btn btn-custom btn-sm" id="openMysteryBoxBtn" disabled>Open a Box</button>
            </div>

             <div class="subscription-info">
                 <p>✨ Premium Tiers Coming Soon! Unlock better rewards, exclusive badges, and more spins!</p>
             </div>
             <div class="section" style="margin-top: 20px; background: rgba(0,0,0,0.2);">
                 <h4 style="text-align: center; color: var(--button-color);">Limited-Time Events</h4>
                 <p style="text-align: center; font-size: 0.9rem;">Check back soon for seasonal challenges and special events!</p>
             </div>
        </div>

        <div id="playerProfile" class="section" style="display: none;">
            <h2>Player Profile</h2>
            <div class="text-center mb-3" style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px;">
                <p style="font-size: 1.1rem;">Welcome, <strong id="profileNameDisplayInner" style="color: var(--button-color);">Guest</strong>!</p>
                 <div id="levelDisplay">Level: <span id="levelName" style="color: var(--level-color); font-weight:bold;">Novice</span></div>
                <div id="pointsProfileDisplay" style="font-size: 1rem;">Points: <span id="pointsValue" style="color: var(--button-color); font-weight:bold;">0</span> $twote</div>
                <div id="energyLevel" style="font-size: 1rem;">Energy: <span id="energyValue" style="color: #87CEEB; font-weight:bold;">0</span>%</div>
                <div id="consecutiveDaysDisplay" style="font-size: 0.9rem;">Daily Streak: <span id="consecutiveDaysValue" style="color: var(--button-color); font-weight:bold;">0</span> days</div>
                <div id="weeklyStreakDisplay" style="font-size: 0.9rem;">Weekly Streak: <span id="weeklyStreakValue" style="color: var(--button-color); font-weight:bold;">0</span> weeks</div>
            </div>
             <div class="d-grid gap-2 mb-3">
                 <button class="btn btn-secondary btn-sm" id="connectWalletBtn">Connect Wallet (Soon)</button>
                 <button class="btn btn-secondary btn-sm" id="airdropWithdrawBtn">Withdraw $twote (Soon)</button>
             </div>

             <h4 class="mt-3 text-center" style="color: var(--button-color);">Achievements</h4>
             <ul id="achievementsList" class="mb-3">
                 <li><i class="fas fa-hourglass-start"></i> No achievements yet</li>
             </ul>

            <h4 class="mt-3" style="color: var(--button-color); text-align: center;">Challenge History (Last 15)</h4>
            <div class="table-responsive">
                <table class="table table-sm">
                    <thead><tr><th>Day</th><th>Goal</th><th>NRG In</th><th>NRG Out</th><th>T1 Proof</th><th>T2 Proof</th></tr></thead>
                    <tbody id="profileHistory"></tbody>
                </table>
            </div>

            <h4 class="mt-3" style="color: var(--button-color); text-align: center;">Leaderboard (Top 100)</h4>
             <div class="table-responsive">
                 <table class="table table-sm">
                     <thead><tr><th class="rank-col">Rank</th><th>Name</th><th class="points-col">Points</th></tr></thead>
                     <tbody id="leaderboard"></tbody>
                 </table>
             </div>
             <div class="text-center mt-4">
                 <button class="btn btn-danger mt-3 btn-sm" id="deleteProgressBtn">Delete All Progress</button>
             </div>
        </div>
    </div>

    <nav class="footer-nav">
        <a href="#" id="navHome"><i class="fas fa-home"></i>Journey</a>
        <a href="#" id="navTasks"><i class="fas fa-tasks"></i>Tasks</a>
        <a href="#" id="navGame"><i class="fas fa-dice"></i>Engage</a>
        <a href="#" id="navProfile"><i class="fas fa-user-astronaut"></i>Profile</a>
    </nav>

    <!-- Modals -->
    <div class="modal fade" id="energyLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="energyLogModalTitle">Energy Log</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p id="energyLogPrompt" style="font-size: 0.95rem;">How positive is your mind frame?</p>
                    <div class="d-flex align-items-center my-3">
                         <span style="font-size: 0.9rem; margin-right: 10px;">0%</span>
                         <input type="range" min="0" max="100" value="50" class="form-range flex-grow-1 me-3" id="energySlider">
                         <span id="energySliderValue" style="color: var(--button-color); font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                         <span style="font-size: 0.9rem; margin-left: 5px;">100%</span>
                    </div>
                    <div id="challengeTasks" style="display: none;">
                        <p class="mb-2"><strong>Meditation:</strong> <span id="meditationTask" style="font-style: italic;"></span></p>
                        <hr style="border-top: 1px solid rgba(255,248,220,0.3);">
                        <p class="mb-1"><strong>Task 1:</strong> <span id="task1Text"></span></p>
                        <input type="file" id="task1Proof" class="form-control form-control-sm mb-2" accept="image/*,video/*,.pdf">
                        <p class="mb-1"><strong>Task 2:</strong> <span id="task2Text"></span></p>
                        <input type="file" id="task2Proof" class="form-control form-control-sm" accept="image/*,video/*,.pdf">
                        <p class="mt-3 text-center warning-text" id="proofWarning" style="display: none; font-size: 0.85em;">Please upload proof for both tasks.</p>
                    </div>
                </div>
                <div class="modal-footer justify-content-center">
                    <button class="btn btn-custom w-75" id="submitEnergyLog" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="enrollModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enroll in Workshop</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                     <p><strong>Name:</strong> <span id="enrollName"></span></p>
                     <p><strong>Current Energy:</strong> <span id="enrollEnergy" style="color: #87CEEB; font-weight: bold;"></span>%</p>
                     <p id="enrollRequirement" class="warning-text" style="font-size: 0.9em; display: none;">Requires 70% Energy</p>
                     <button class="btn btn-custom mt-3 w-50" id="submitEnrollment" disabled>Enroll Now</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="codeModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title">Enter Workshop Code</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body">
                     <input type="text" id="workshopCode" class="form-control mb-3" placeholder="Enter code" style="background: rgba(255,255,255,0.1); color: var(--text-color); border-color: rgba(255,255,255,0.3);">
                      <div class="text-center">
                          <button class="btn btn-custom w-50" id="submitCode">Submit</button>
                      </div>
                 </div>
             </div>
         </div>
     </div>

     <!-- Wheel Modal -->
    <div class="modal fade" id="wheelModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title" id="wheelModalTitle">Spin the Wheel!</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body wheel-outer-container"> <!-- Flex container -->
                     <div class="wheel-pointer"></div>
                     <div class="wheel-container">
                         <div class="wheel" id="modalWheel">
                             <!-- Emojis for decoration -->
                             <span class="wheel-segment">⚡</span> <!-- Energy -->
                             <span class="wheel-segment">✨</span> <!-- Sigil/Manifest -->
                             <span class="wheel-segment">😊</span> <!-- Happiness -->
                             <span class="wheel-segment">💖</span> <!-- Wellness/Healing -->
                             <span class="wheel-segment">💰</span> <!-- Prosperity -->
                             <span class="wheel-segment">⭐</span> <!-- Manifest/Star -->
                             <span class="wheel-segment">🌿</span> <!-- Healing/Wellness -->
                             <span class="wheel-segment">🎁</span> <!-- Referral/Gift -->
                         </div>
                     </div>
                     <div id="wheelResultDisplay">Spinning...</div>
                 </div>
                 <!-- Optional Footer
                 <div class="modal-footer justify-content-center">
                    <button class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Close</button>
                 </div>
                 -->
             </div>
         </div>
     </div>


    <!-- Toast Container for Notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
        <!-- Toasts will be appended here -->
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script>
        // --- Constants ---
        const dailyGoals = [ // Simplified, ensure 7 unique ones for the cycle
            { goal: "Abundance", meditation: "Visualize abundance.", task1: "List 3 things you're financially grateful for.", task2: "Set one small financial goal for the week.", points: 5 },
            { goal: "Inner Peace", meditation: "Focus on your breath.", task1: "5-minute silent meditation.", task2: "Write down 3 things causing stress and one action for each.", points: 5 },
            { goal: "Clarity", meditation: "Visualize clear thoughts.", task1: "Mind dump: Write all thoughts for 5 mins.", task2: "Prioritize your top 3 tasks for tomorrow.", points: 5 },
            { goal: "Inspiration", meditation: "Open yourself to ideas.", task1: "Spend 10 mins exploring something new (article, music, art).", task2: "Note down one inspiring idea.", points: 5 },
            { goal: "Self-Love", meditation: "Affirm your worth.", task1: "List 3 qualities you admire about yourself.", task2: "Do one small kind thing for yourself.", points: 5 },
            { goal: "Vitality", meditation: "Visualize vibrant energy.", task1: "5-minute stretching or gentle movement.", task2: "Drink an extra glass of water.", points: 5 },
            { goal: "Connection", meditation: "Feel connected to others.", task1: "Send a positive message to a friend/family member.", task2: "Reflect on a positive interaction you had.", points: 5 }
        ];
        const sections = ['horoscopeForm', 'wellnessManager', 'dailyChallenges', 'tasksSection', 'gamePage', 'playerProfile'];
        const wheelTypes = ['energy', 'sigil', 'happiness', 'wellness', 'prosperity', 'manifestation', 'healing', 'referral'];
        const levels = [
            { name: "Novice", points: 0 },
            { name: "Seeker", points: 100 },
            { name: "Adept", points: 500 },
            { name: "Guardian", points: 1500 },
            { name: "Healer", points: 4000 },
            { name: "Master", points: 10000 },
            { name: "Sage", points: 25000 },
        ];
        const achievementsConfig = {
            'FIRST_CHECKIN': { name: "First Steps", icon: "fa-shoe-prints", description: "Completed your first daily check-in." },
            '7_DAY_STREAK': { name: "Consistent Soul", icon: "fa-calendar-check", description: "Achieved a 7-day streak." },
            'FIRST_REFERRAL': { name: "Community Builder", icon: "fa-users", description: "Successfully referred a friend." },
            'LEVEL_ADEPT': { name: "Adept Achiever", icon: "fa-star", description: "Reached the Adept level." },
            'CHALLENGE_7_COMPLETE': { name: "Foundation Complete", icon: "fa-sun", description: "Completed the 7-Day Foundation Challenge."},
            'OPEN_MYSTERY_BOX': { name: "Curious Explorer", icon: "fa-box", description: "Opened your first Mystery Box." },
            // Add more as needed
        };
        const DUBAI_TIMEZONE_OFFSET_MS = 4 * 60 * 60 * 1000; // UTC+4
        const WHEEL_SEGMENTS = 8; // Number of segments defined in the CSS conic-gradient

        // --- Global State & Variables ---
        let state = {};
        let sectionStack = ['wellnessManager']; // Default starting point after birthdate
        let domElements = {};
        let modalInstances = {}; // Store all modal instances
        let activeWheelType = null; // Track which wheel is spinning
        let isSpinning = false; // Prevent multiple spins
        let spinTimeoutId = null; // To manage the failsafe timeout


        // --- Helper Functions ---
        function getDomElements() {
            const ids = [
                'backgroundVideo', 'profilePhoto', 'profileNameDisplay', 'profileNameDisplayInner',
                'pointsDisplay', 'profileLevelDisplay', 'energyHeaderDisplay', 'pointsValue',
                'consecutiveDaysValue', 'weeklyStreakValue', 'energyValue', 'challengeOptions',
                'dailyChallengeList', 'challengeTitle', 'energyLogPrompt', 'energySlider',
                'energySliderValue', 'challengeTasks', 'meditationTask', 'task1Text',
                'task2Text', 'task1Proof', 'task2Proof', 'submitEnergyLog', 'profileHistory',
                'referralLink', 'copyReferralBtn', 'dailyCheckInBtn', 'countdownDisplay', 'leaderboard', 'enrollName',
                 'enrollEnergy', 'submitEnrollment', 'workshopCode',
                'submitCode', 'proofWarning', 'enrollRequirement', 'energyLogModal',
                'enrollModal', 'codeModal', 'wheelModal', 'modalWheel', 'wheelModalTitle', 'wheelResultDisplay',
                'spinInfo', 'levelDisplay', 'levelName', 'achievementsList',
                'mysteryBoxCount', 'openMysteryBoxBtn', 'referralSpinsCount', 'claimReferralRewardBtn',
                // Birthdate form
                'birthdate', 'saveHoroscopeBtn',
                // Task Buttons
                'telegramTaskBtn', 'twitterTaskBtn', 'instagramTaskBtn', 'youtubeTaskBtn',
                // Footer Nav
                 'navHome', 'navTasks', 'navGame', 'navProfile',
                 // Profile Buttons
                 'deleteProgressBtn', 'connectWalletBtn', 'airdropWithdrawBtn'
            ];
             // Add wheel buttons
             wheelTypes.forEach(type => {
                 const btnId = type === 'referral' ? 'useReferralSpinBtn' : `spin${capitalizeFirstLetter(type)}WheelBtn`;
                 ids.push(btnId);
             });

            const elements = {};
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) console.warn(`DOM Element not found: #${id}`); // Optional warning
                elements[id] = el;
            });
            return elements;
        }

        function capitalizeFirstLetter(string) {
          if (!string) return '';
          return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getCurrentDubaiDate() {
            const now = Date.now();
            const dubaiTime = new Date(now + DUBAI_TIMEZONE_OFFSET_MS);
            return dubaiTime.toISOString().split('T')[0]; // YYYY-MM-DD format in Dubai
        }

        function showNotification(message, type = 'info') {
            // type can be 'info', 'success', 'warning', 'error'
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) {
                console.error("Toast container not found!");
                return;
            }

            const toast = document.createElement('div');
            let bgClass = 'bg-primary'; // Default to info
            if (type === 'success') bgClass = 'bg-success';
            else if (type === 'warning') bgClass = 'bg-warning text-dark'; // Dark text for yellow bg
            else if (type === 'error') bgClass = 'bg-danger';

            toast.className = `toast align-items-center text-white ${bgClass} border-0`;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        ${escapeHtml(message)}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            toastContainer.appendChild(toast);
            try {
                const bsToast = new bootstrap.Toast(toast, { delay: 3500 });
                bsToast.show();
                 toast.addEventListener('hidden.bs.toast', () => {
                    toast.remove();
                });
            } catch (e) {
                console.error("Error showing bootstrap toast:", e);
                toast.remove(); // Clean up if it failed
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing App...");
            domElements = getDomElements();
            if (!domElements.navHome) {
                console.error("Failed to get crucial DOM elements (e.g., navHome). Aborting initialization.");
                alert("Error: Could not initialize the application UI.");
                return;
            }

            // Initialize Modals safely
            try {
                modalInstances.energyLog = domElements.energyLogModal ? new bootstrap.Modal(domElements.energyLogModal) : null;
                modalInstances.enroll = domElements.enrollModal ? new bootstrap.Modal(domElements.enrollModal) : null;
                modalInstances.code = domElements.codeModal ? new bootstrap.Modal(domElements.codeModal) : null;
                modalInstances.wheel = domElements.wheelModal ? new bootstrap.Modal(domElements.wheelModal) : null;
                if (!modalInstances.wheel) console.error("Wheel modal failed to initialize!");
                if (!modalInstances.energyLog) console.error("EnergyLog modal failed to initialize!");
            } catch(e) {
                console.error("Error initializing Bootstrap Modals:", e);
            }

            initializeApp(); // Load state and check Telegram
            setupEventListeners(); // Setup interactions

            // Setup Telegram BackButton (with safety checks)
            try {
                if (window.Telegram?.WebApp) {
                     if (!Telegram.WebApp.isVersionAtLeast('6.1')) {
                        console.warn("[Telegram.WebApp] BackButton might have limited support below 6.1. Current:", Telegram.WebApp.version);
                     }
                     if (Telegram.WebApp.BackButton) {
                        Telegram.WebApp.BackButton.onClick(() => {
                            console.log("Back button clicked. Stack:", [...sectionStack]);
                            if (sectionStack.length > 1) {
                                sectionStack.pop();
                                const previousSection = sectionStack[sectionStack.length - 1];
                                console.log("Navigating back to:", previousSection);
                                showSection(previousSection, true); // Navigate back
                            } else {
                                console.log("Back button clicked on root section.");
                                // Optionally close: Telegram.WebApp.close();
                            }
                        });
                     } else {
                         console.warn("Telegram.WebApp.BackButton object not available.");
                     }
                } else {
                    console.warn("Telegram WebApp environment not detected. Back button disabled.");
                }
            } catch (e) {
                console.error("Error setting up Telegram BackButton:", e);
            }
        });

        function initializeState() {
             const defaultLeaderboard = [
                 { userId: 'bot1', name: 'Cosmic Guide', points: 150 }, { userId: 'bot2', name: 'Zen Master', points: 120 },
                 { userId: 'bot3', name: 'Astro Explorer', points: 110 }, { userId: 'bot4', name: 'Mindful One', points: 95 },
                 { userId: 'bot5', name: 'Starlight', points: 80 },
             ];
             const initialSpins = {};
             wheelTypes.forEach(type => initialSpins[type] = (type === 'referral' ? 0 : 1));

            return {
                userId: null, userName: "Guest", userPhoto: "https://via.placeholder.com/40",
                energyLevel: 50, points: 0, level: "Novice",
                challenges: initializeChallenges(), challengeHistory: [], birthdate: null,
                consecutiveDays: 0, weeklyStreak: 0, lastPlayedDate: null, lastCheckInTime: null,
                completedTasks: [], workshopAccess: false, currentChallengeDuration: null,
                currentChallengeDay: null, energyBefore: null, leaderboard: defaultLeaderboard,
                achievements: [], mysteryBoxes: 0, wheelSpins: initialSpins, lastDailySpinReset: null,
            };
        }

        function initializeApp() {
             console.log("Initializing App State...");
             state = initializeState();
             let telegramUser = null;

             try {
                 if (window.Telegram?.WebApp) {
                     Telegram.WebApp.ready();
                     Telegram.WebApp.expand();
                     Telegram.WebApp.setHeaderColor('secondary_bg_color'); // Use theme color
                     Telegram.WebApp.onEvent('themeChanged', applyTheme); // Listen for theme changes

                     // Request theme AFTER ready()
                     Telegram.WebApp.postEvent("web_app_request_theme");

                     telegramUser = Telegram.WebApp.initDataUnsafe?.user;
                     console.log("Raw Telegram initDataUnsafe:", Telegram.WebApp.initDataUnsafe); // DEBUG TG DATA
                     if (telegramUser) {
                         console.log("Telegram User Data Found:", telegramUser);
                         state.userId = telegramUser.id.toString();
                         state.userName = telegramUser.first_name || telegramUser.username || "User";
                         state.userPhoto = telegramUser.photo_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(state.userName)}&background=random&color=fff&size=40`;
                         console.log(`Set state from TG: Name=${state.userName}, Photo=${state.userPhoto}`); // DEBUG TG DATA
                     } else { console.warn("Telegram user data not found in initDataUnsafe."); }
                 } else { console.warn("Telegram WebApp object not available."); }
             } catch (e) { console.error("Error during Telegram setup:", e); }

             // --- User ID and Storage ---
             const storageUserId = localStorage.getItem('userId');
             if (telegramUser && (!storageUserId || storageUserId !== state.userId)) {
                 console.log(`Using Telegram User ID: ${state.userId}. Clearing old data if storage ID (${storageUserId}) differs.`);
                 if (storageUserId) clearLocalStorageForUser(storageUserId);
                 localStorage.setItem('userId', state.userId);
             } else if (!state.userId && storageUserId) {
                 state.userId = storageUserId;
                 console.log(`Using stored User ID: ${state.userId}`);
             } else if (!state.userId && !storageUserId) {
                 state.userId = `local_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
                 console.log(`Generating new local User ID: ${state.userId}`);
                 localStorage.setItem('userId', state.userId);
             }
             // Ensure current userId is stored if it came from Telegram initially
             if (state.userId && state.userId !== storageUserId) {
                 localStorage.setItem('userId', state.userId);
             }

             console.log(`Initializing Data for User ID: ${state.userId}`);
             loadStateFromLocal(); // Load data for the determined user ID
             applyTheme(); // Apply theme after loading potentially stored theme data
        }

        function applyTheme() {
            try {
                if (window.Telegram?.WebApp?.themeParams && Object.keys(Telegram.WebApp.themeParams).length > 0) {
                    console.log("Applying Telegram theme:", Telegram.WebApp.themeParams);
                    document.documentElement.style.setProperty('--bg-color', Telegram.WebApp.themeParams.secondary_bg_color || '#4E342E');
                    document.documentElement.style.setProperty('--text-color', Telegram.WebApp.themeParams.text_color || '#FFF8E1');
                    document.documentElement.style.setProperty('--button-color', Telegram.WebApp.themeParams.button_color || '#FFD700');
                    document.documentElement.style.setProperty('--button-text-color', Telegram.WebApp.themeParams.button_text_color || '#3E2723');
                    // Adjust other colors based on theme if needed (e.g., make warnings more visible on dark themes)
                    if(Telegram.WebApp.colorScheme === 'dark') {
                         document.documentElement.style.setProperty('--challenge-description-color', '#E0E0E0'); // Lighter text on dark
                         document.documentElement.style.setProperty('--warning-color', '#FF6B6B'); // Brighter red for dark mode
                    } else {
                        document.documentElement.style.setProperty('--challenge-description-color', '#3E2723');
                        document.documentElement.style.setProperty('--warning-color', '#d9534f');
                    }
                } else {
                    console.log("No Telegram theme data found or themeParams empty, using default CSS variables.");
                }
            } catch (e) {
                console.error("Error applying theme:", e);
            }
        }


        function getStorageKey(key) {
            if (!state.userId) {
                console.error("Cannot get storage key: userId is not set!");
                return `ERROR_NO_USER_${key}`; // Prevent saving/loading if no user ID
            }
            return `${state.userId}_${key}`;
        }

        function clearLocalStorageForUser(userIdToClear) {
            if (!userIdToClear) return;
            console.warn(`Clearing local storage keys for previous user ID: ${userIdToClear}`);
            try {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(`${userIdToClear}_`)) {
                        localStorage.removeItem(key);
                        console.log(`Removed: ${key}`);
                    }
                });
                // Also remove the base userId key if it matches the old one
                if (localStorage.getItem('userId') === userIdToClear) {
                    localStorage.removeItem('userId');
                }
            } catch (error) {
                console.error(`Error clearing local storage for user ${userIdToClear}:`, error);
            }
        }


        function loadStateFromLocal() {
             console.log("Loading state from Local Storage...");
             if (!state.userId) {
                 console.error("Aborting load: userId is not set!");
                 return;
             }
             try {
                 state.energyLevel = parseInt(localStorage.getItem(getStorageKey('energyLevel')) || '50');
                 state.points = parseInt(localStorage.getItem(getStorageKey('points')) || '0');
                 state.level = localStorage.getItem(getStorageKey('level')) || "Novice";

                 // --- Birthdate Loading ---
                 const loadedBirthdate = localStorage.getItem(getStorageKey('birthdate'));
                 state.birthdate = (loadedBirthdate && loadedBirthdate !== 'null' && loadedBirthdate.length > 5) ? loadedBirthdate : null;
                 console.log(`Loaded birthdate from storage: '${state.birthdate}' (type: ${typeof state.birthdate})`); // DEBUG

                 state.consecutiveDays = parseInt(localStorage.getItem(getStorageKey('consecutiveDays')) || '0');
                 state.weeklyStreak = parseInt(localStorage.getItem(getStorageKey('weeklyStreak')) || '0');
                 state.lastPlayedDate = localStorage.getItem(getStorageKey('lastPlayedDate')) || null;
                 state.lastCheckInTime = localStorage.getItem(getStorageKey('lastCheckInTime')) ? parseInt(localStorage.getItem(getStorageKey('lastCheckInTime'))) : null;
                 state.workshopAccess = localStorage.getItem(getStorageKey('workshopAccess')) === 'true';
                 state.mysteryBoxes = parseInt(localStorage.getItem(getStorageKey('mysteryBoxes')) || '0');
                 state.lastDailySpinReset = localStorage.getItem(getStorageKey('lastDailySpinReset')) || null;
                 state.completedTasks = JSON.parse(localStorage.getItem(getStorageKey('completedTasks')) || '[]');
                 state.achievements = JSON.parse(localStorage.getItem(getStorageKey('achievements')) || '[]');
                 state.currentChallengeDuration = localStorage.getItem(getStorageKey('currentChallengeDuration')) ? parseInt(localStorage.getItem(getStorageKey('currentChallengeDuration'))) : null;

                 const savedChallenges = JSON.parse(localStorage.getItem(getStorageKey('challenges')) || 'null');
                 if (savedChallenges && Array.isArray(savedChallenges)) {
                    state.challenges.forEach((challenge, index) => {
                        const saved = savedChallenges.find(sc => sc.day === challenge.day);
                        if (saved) {
                            challenge.completed = saved.completed || false;
                            challenge.completionDate = saved.completionDate || null;
                        }
                    });
                 }

                 state.challengeHistory = JSON.parse(localStorage.getItem(getStorageKey('challengeHistory')) || '[]');
                 const savedLeaderboard = JSON.parse(localStorage.getItem(getStorageKey('leaderboard')) || 'null') || [];
                 state.leaderboard = mergeLeaderboards(initializeState().leaderboard, savedLeaderboard);
                 ensureUserInLeaderboard();

                 const savedSpins = JSON.parse(localStorage.getItem(getStorageKey('wheelSpins')) || '{}');
                 wheelTypes.forEach(type => {
                     state.wheelSpins[type] = savedSpins[type] ?? (type === 'referral' ? 0 : 1); // Use nullish coalescing
                 });

                 console.log("State loaded successfully.");

                 checkDailyReset();
                 updateUserLevel(); // Update level based on loaded points
                 updateUI(); // Update UI with loaded data FIRST
                 startCountdown();
                 showInitialSection(); // THEN Show section AFTER state is loaded and UI is initially updated

             } catch (error) {
                 console.error('Error loading state from LocalStorage:', error);
                 showNotification('Failed to load saved data. Resetting to defaults.', 'error');
                 const userId = state.userId, userName = state.userName, userPhoto = state.userPhoto;
                 state = initializeState();
                 state.userId = userId; state.userName = userName; state.userPhoto = userPhoto;
                 ensureUserInLeaderboard();
                 updateUI();
                 showInitialSection(); // Show default section after error
                 saveData(Object.keys(state).filter(k => k !== 'userId' && k !== 'userName' && k !== 'userPhoto')); // Save default state
             }
         }

        function saveStateToLocal(keysToSave) {
            if (!state.userId) {
                console.error("Cannot save state: userId is not set!");
                return;
            }
            console.log(`Saving keys: ${keysToSave.join(', ')}`); // DEBUG Save
            keysToSave.forEach(key => {
                 if (key === 'userId' || key === 'userName' || key === 'userPhoto') return;
                 try {
                    let valueToSave; const stateValue = state[key];
                    if (typeof stateValue === 'object' && stateValue !== null) { valueToSave = JSON.stringify(stateValue); }
                    else if (typeof stateValue === 'boolean') { valueToSave = stateValue ? 'true' : 'false'; }
                    else if (stateValue !== null && stateValue !== undefined) { valueToSave = String(stateValue); }
                    else { valueToSave = null; } // Represent null/undefined as removed item

                    const storageKey = getStorageKey(key);
                    if (valueToSave !== null) {
                        // console.log(`Saving ${storageKey}: ${valueToSave.substring(0,100)}...`); // DEBUG Save Value
                        localStorage.setItem(storageKey, valueToSave);
                    } else {
                        // console.log(`Removing ${storageKey}`); // DEBUG Remove Value
                        localStorage.removeItem(storageKey);
                    }
                 } catch (error) {
                     console.error(`Error saving '${key}' to LocalStorage:`, error);
                      // Avoid notification spam if storage is full
                      if (error.name === 'QuotaExceededError') {
                          console.error("LocalStorage quota exceeded!");
                          // Maybe show notification only once
                      } else {
                         showNotification(`Error saving game data (${key}). Progress might be lost!`, 'error');
                      }
                 }
             });
        }


        function saveData(keys = []) {
            if (!Array.isArray(keys) || keys.length === 0) { console.warn("saveData called with no keys."); return; }
            const uniqueKeys = [...new Set(keys)];
            // Add dependencies implicitly
            if (uniqueKeys.includes('points') && !uniqueKeys.includes('level')) uniqueKeys.push('level');
            if (uniqueKeys.includes('points') && !uniqueKeys.includes('leaderboard')) uniqueKeys.push('leaderboard');
            if (uniqueKeys.includes('challenges') && !uniqueKeys.includes('challengeHistory')) uniqueKeys.push('challengeHistory');
            saveStateToLocal(uniqueKeys.filter(k => k !== 'userId' && k !== 'userName' && k !== 'userPhoto')); // Filter identity keys
        }


        function mergeLeaderboards(defaultBoard, savedBoard) {
            const mergedMap = new Map();
            defaultBoard.forEach(p => mergedMap.set(p.userId, { ...p }));
            savedBoard.forEach(p => {
                 if (!p || !p.userId) return; // Skip invalid entries
                 const existing = mergedMap.get(p.userId);
                 if (existing) {
                     existing.points = Math.max(existing.points, p.points || 0);
                     existing.name = p.name || existing.name; // Prefer saved name if available
                 } else {
                     mergedMap.set(p.userId, { ...p, points: p.points || 0, name: p.name || 'Anonymous' });
                 }
            });
            return Array.from(mergedMap.values());
        }

        function ensureUserInLeaderboard() {
             if (!state.userId) return;
             let userEntry = state.leaderboard.find(p => p.userId === state.userId);
             if (!userEntry) {
                 console.log(`Adding user ${state.userId} (${state.userName}) to leaderboard.`);
                 userEntry = { userId: state.userId, name: state.userName, points: state.points };
                 state.leaderboard.push(userEntry);
             }
             // Always update points and name in case they changed
             userEntry.points = state.points;
             userEntry.name = state.userName;
         }

        // --- UI Update Functions ---
         function updateUI() {
             // Header
             if (domElements.profilePhoto) domElements.profilePhoto.src = state.userPhoto;
             if (domElements.profileNameDisplay) domElements.profileNameDisplay.textContent = state.userName;
             if (domElements.pointsDisplay) domElements.pointsDisplay.textContent = `${state.points} $twote`;
             if (domElements.profileLevelDisplay) domElements.profileLevelDisplay.textContent = `Level: ${state.level}`;
             if (domElements.energyHeaderDisplay) domElements.energyHeaderDisplay.textContent = `NRG: ${state.energyLevel}%`;

             // Profile Page
             if (domElements.profileNameDisplayInner) domElements.profileNameDisplayInner.textContent = state.userName;
             if (domElements.pointsValue) domElements.pointsValue.textContent = state.points;
             if (domElements.energyValue) domElements.energyValue.textContent = state.energyLevel;
             if (domElements.levelName) domElements.levelName.textContent = state.level;
             if (domElements.consecutiveDaysValue) domElements.consecutiveDaysValue.textContent = state.consecutiveDays;
             if (domElements.weeklyStreakValue) domElements.weeklyStreakValue.textContent = state.weeklyStreak;

             // Referral
             if (domElements.referralLink) {
                 if (state.userId) {
                     const botUsername = "YOUR_BOT_USERNAME"; // !! IMPORTANT: Replace with your ACTUAL bot username
                     domElements.referralLink.value = `https://t.me/${botUsername}?start=${state.userId}`;
                 } else { domElements.referralLink.value = "Link unavailable"; }
             }

             // Dynamic Components
             updateDailyCheckInButtonState();
             updateLeaderboardUI();
             updateTaskButtons();
             updateWheelButtons();
             updateAchievementsUI();
             updateMysteryBoxUI();
             // updateReferralSpinsUI(); // Now handled within updateWheelButtons
             updateActiveNav();
         }

         function updateActiveNav() {
            const currentSection = sectionStack.length > 0 ? sectionStack[sectionStack.length - 1] : 'wellnessManager'; // Default if stack empty
            const navMap = {
                'wellnessManager': domElements.navHome, 'dailyChallenges': domElements.navHome,
                'tasksSection': domElements.navTasks, 'gamePage': domElements.navGame,
                'playerProfile': domElements.navProfile, 'horoscopeForm': null // No nav item for horoscope form
            };
             [domElements.navHome, domElements.navTasks, domElements.navGame, domElements.navProfile].forEach(nav => nav?.classList.remove('active'));
             const activeNav = navMap[currentSection];
             if (activeNav) { activeNav.classList.add('active'); }
         }

         function updateDailyCheckInButtonState() {
            if (!domElements.dailyCheckInBtn) return;
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const canCheckIn = !state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours);

             domElements.dailyCheckInBtn.disabled = !canCheckIn;
             if (canCheckIn) {
                 domElements.dailyCheckInBtn.textContent = "Daily Check-In";
                 if(domElements.countdownDisplay) domElements.countdownDisplay.textContent = 'Check-in available!';
                 if(domElements.spinInfo) domElements.spinInfo.textContent = 'Complete Daily Check-In to enable spins.';
             } else {
                 domElements.dailyCheckInBtn.textContent = "Checked In Today";
                 if(domElements.spinInfo) domElements.spinInfo.textContent = 'Spins enabled for today!';
                 startCountdown(); // Ensure countdown runs if checked in
             }
             updateWheelButtons(); // Wheel availability depends on check-in
         }

        function startCountdown() {
             if (window.checkinCountdownInterval) clearInterval(window.checkinCountdownInterval);
             if (!state.lastCheckInTime || !domElements.countdownDisplay) {
                 if(domElements.countdownDisplay) domElements.countdownDisplay.textContent = 'Check-in available!';
                 updateDailyCheckInButtonState(); // Ensure button state correct
                 return;
             }

             const twentyFourHours = 24 * 60 * 60 * 1000;
             const endTime = state.lastCheckInTime + twentyFourHours;

             function updateCountdownDisplay() {
                 const now = Date.now(); const timeLeft = endTime - now;
                 if (timeLeft <= 0) {
                     if(domElements.countdownDisplay) domElements.countdownDisplay.textContent = 'Check-in available!';
                     updateDailyCheckInButtonState(); // Enable button
                     clearInterval(window.checkinCountdownInterval);
                     return;
                 }
                 const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                 const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                 const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                 if(domElements.countdownDisplay) domElements.countdownDisplay.textContent = `Next check-in: ${hours}h ${minutes}m ${seconds}s`;
                 if (domElements.dailyCheckInBtn && !domElements.dailyCheckInBtn.disabled) { // Only update if not already disabled by logic
                    domElements.dailyCheckInBtn.disabled = true;
                    domElements.dailyCheckInBtn.textContent = "Checked In Today";
                 }
             }
             updateCountdownDisplay();
             window.checkinCountdownInterval = setInterval(updateCountdownDisplay, 1000);
         }


        function updateWheelButtons() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const checkedInToday = state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours);

             wheelTypes.forEach(type => {
                const isReferral = type === 'referral';
                const btnId = isReferral ? 'useReferralSpinBtn' : `spin${capitalizeFirstLetter(type)}WheelBtn`;
                const button = domElements[btnId];
                 if (!button) { /*console.warn(`Wheel button not found: ${btnId}`);*/ return; } // Skip if button doesn't exist

                 const spinsLeft = state.wheelSpins[type] || 0;
                 // Referral spins can be used anytime if available, others need check-in AND spins>0
                 const canSpin = isReferral ? (spinsLeft > 0) : (checkedInToday && spinsLeft > 0);
                 button.disabled = !canSpin || isSpinning; // Also disable if another spin is active

                 // Update text content for the spins count span
                 const spinsLeftSpan = button.querySelector('.spins-left');
                 if (spinsLeftSpan) {
                     spinsLeftSpan.textContent = `(${spinsLeft})`;
                     // Specific ID for referral count if needed, otherwise handled by general class
                     if (isReferral && domElements.referralSpinsCount && spinsLeftSpan !== domElements.referralSpinsCount) {
                        domElements.referralSpinsCount.textContent = `(${spinsLeft})`;
                     }
                 } else {
                    console.warn(`Spins left span not found for button ${btnId}`);
                 }


                 button.title = !checkedInToday && !isReferral ? "Complete daily check-in first"
                              : spinsLeft <= 0 ? (isReferral ? "No referral spins left" : "No spins left for today")
                              : isSpinning ? "Spin in progress..."
                              : `Click to spin (${spinsLeft} left)`;
             });
        }


        function updateTaskButtons() {
            ['telegram', 'twitter', 'instagram', 'youtube'].forEach(taskKey => {
                 const button = domElements[`${taskKey}TaskBtn`];
                 if (!button) return;
                 const isCompleted = state.completedTasks.includes(taskKey);
                 button.disabled = isCompleted;
                 button.textContent = isCompleted ? 'Done' : 'Verify';
                 button.classList.toggle('btn-success', isCompleted);
                 button.classList.toggle('btn-custom', !isCompleted);
             });
        }

        function updateAchievementsUI() {
            if (!domElements.achievementsList) return;
             if (!state.achievements || state.achievements.length === 0) {
                 domElements.achievementsList.innerHTML = '<li><i class="fas fa-hourglass-start"></i> No achievements yet</li>'; return;
             }
             domElements.achievementsList.innerHTML = state.achievements.map(key => {
                 const ach = achievementsConfig[key]; if (!ach) return '';
                 return `<li title="${escapeHtml(ach.description || '')}"><i class="fas ${ach.icon || 'fa-question-circle'}"></i> ${escapeHtml(ach.name || 'Unknown')}</li>`;
             }).join('');
         }

        function updateMysteryBoxUI() {
            if (domElements.mysteryBoxCount) domElements.mysteryBoxCount.textContent = state.mysteryBoxes;
            if (domElements.openMysteryBoxBtn) domElements.openMysteryBoxBtn.disabled = state.mysteryBoxes <= 0 || isSpinning; // Disable if spinning or no boxes
         }

        function updateLeaderboardUI() {
            if (!domElements.leaderboard) return;
             ensureUserInLeaderboard(); // Make sure current user is reflected
             // Sort leaderboard by points descending
             state.leaderboard.sort((a, b) => b.points - a.points);
             domElements.leaderboard.innerHTML = state.leaderboard.slice(0, 100).map((p, i) => `
                 <tr class="${p.userId === state.userId ? 'table-primary' : ''}">
                     <td class="rank-col">${i + 1}</td>
                     <td>${escapeHtml(p.name)}</td>
                     <td class="points-col">${p.points}</td>
                 </tr>`).join('') || '<tr><td colspan="3" class="text-center text-muted">Leaderboard is empty.</td></tr>';
         }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe; // Return non-strings as is
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
         }

        // --- Navigation ---
         function showInitialSection() {
             console.log(`showInitialSection called. Current birthdate state: '${state.birthdate}'`); // DEBUG
             // Robust check for birthdate (must be a non-empty string representing a date)
             const hasBirthdate = state.birthdate && typeof state.birthdate === 'string' && state.birthdate.length > 5;
             const firstSection = hasBirthdate ? 'wellnessManager' : 'horoscopeForm';
             console.log(`Determined initial section: ${firstSection} (hasBirthdate: ${hasBirthdate})`); // DEBUG
             sectionStack = [firstSection]; // Reset stack to only the first section
             showSection(firstSection, true); // Use true to prevent adding to stack again
         }


         function showSection(sectionId, isNavigatingBackOrInitial = false) {
             if (!sections.includes(sectionId)) { console.error(`Invalid sectionId: ${sectionId}`); return; }

             const currentTopSection = sectionStack.length > 0 ? sectionStack[sectionStack.length - 1] : null;

             // Prevent pushing duplicates or navigating to the same section
             if (!isNavigatingBackOrInitial && sectionId === currentTopSection) {
                console.log(`Already on section: ${sectionId}`);
                return;
             }

             // Update stack only if it's a forward navigation
             if (!isNavigatingBackOrInitial) {
                sectionStack.push(sectionId);
             } else if (sectionStack[sectionStack.length - 1] !== sectionId && sectionStack.length === 0) {
                 // Handle case where stack is empty but we are showing initial section
                 sectionStack.push(sectionId);
             }


             console.log("Showing section:", sectionId, "Stack:", [...sectionStack]);

             sections.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = id === sectionId ? 'block' : 'none'; });

             // Update TG BackButton visibility based on stack depth
             try {
                 if (window.Telegram?.WebApp?.BackButton) {
                     if (sectionStack.length > 1) Telegram.WebApp.BackButton.show();
                     else Telegram.WebApp.BackButton.hide();
                 }
             } catch (e) { console.error("Error updating BackButton visibility:", e); }

             // Section-specific logic/updates
             switch (sectionId) {
                 case 'wellnessManager': loadChallenges(); break;
                 case 'dailyChallenges': displayDailyChallenges(state.currentChallengeDuration); break;
                 case 'playerProfile': loadProfileHistory(); updateLeaderboardUI(); updateAchievementsUI(); break;
                 case 'gamePage': updateWheelButtons(); updateMysteryBoxUI(); break; // Update game elements
                 case 'tasksSection': updateTaskButtons(); break;
                 // No specific action needed for horoscopeForm on show
             }
             updateActiveNav(); // Highlight correct footer nav item
             window.scrollTo(0, 0); // Scroll to top
         }


        // --- Core Logic Functions ---
        function saveHoroscope() {
             console.log("saveHoroscope triggered"); // DEBUG
             const birthdateInput = domElements.birthdate;
             if (!birthdateInput) { console.error("Birthdate input not found"); return; }

             const birthdate = birthdateInput.value; // Format YYYY-MM-DD
             console.log(`Got birthdate value: ${birthdate}`); // DEBUG

             if (birthdate) {
                 try {
                    // Basic validation: Check if it's a plausible date string
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(birthdate)) {
                        throw new Error("Invalid date format. Use YYYY-MM-DD.");
                    }

                    const d = new Date(birthdate);
                    // Check if the date object is valid (accounts for invalid dates like 2023-02-30)
                    if (isNaN(d.getTime()) || d.toISOString().slice(0, 10) !== birthdate) {
                        throw new Error("Invalid date value (e.g., day/month out of range).");
                    }

                    const year = d.getFullYear();
                    const currentYear = new Date().getFullYear();
                    if (year < 1900 || year > currentYear) { // Check year range
                        throw new Error(`Year ${year} is out of range (1900-${currentYear}).`);
                    }

                    // If validation passes
                    console.log("Birthdate validated:", birthdate); // DEBUG
                    state.birthdate = birthdate;
                    saveData(['birthdate']); // Save the validated date
                    showNotification('Birthdate saved!', 'success');
                    showSection('wellnessManager'); // Navigate to next section

                 } catch (e) {
                    console.error("Birthdate validation error:", e.message); // DEBUG
                    showNotification(`Invalid birthdate: ${e.message}. Please try again.`, 'warning');
                    birthdateInput.focus();
                 }
             } else {
                showNotification('Please enter your birthdate.', 'warning');
                birthdateInput.focus();
             }
         }


        function checkDailyReset() {
            const today = getCurrentDubaiDate();
            resetDailySpinsIfNeeded(today); // Reset spins first

            if (!state.lastPlayedDate) { // First time playing or data reset
                state.consecutiveDays = 0;
                state.weeklyStreak = 0;
                console.log("First play or data reset, streaks set to 0.");
                // No need to save here, will be saved on check-in
                updateDailyCheckInButtonState(); // Ensure button is enabled
                return;
            }

            if (state.lastPlayedDate === today) {
                console.log("Already played today.");
                updateDailyCheckInButtonState(); // Ensure button reflects checked-in state
                return; // Don't reset streaks if played today
            }

             // Played previously, but not today
             try {
                const todayDate = new Date(today);
                const lastPlayedDateObj = new Date(state.lastPlayedDate);

                // Calculate difference in days (robustly handling timezone/DST changes near midnight)
                const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays > 1) {
                    // Missed one or more days
                    state.consecutiveDays = 0;
                    state.weeklyStreak = 0;
                    console.log(`Missed ${diffDays - 1} day(s), streaks reset.`);
                    saveData(['consecutiveDays', 'weeklyStreak']); // Save the reset streaks
                } else if (diffDays === 1) {
                    // Played yesterday, streak continues (handled during check-in)
                    console.log("Consecutive day possible.");
                } else if (diffDays <= 0) {
                    // Should not happen if lastPlayedDate is correctly set, but handle defensively
                    console.warn(`Unexpected day difference: ${diffDays}. Resetting streaks just in case.`);
                    state.consecutiveDays = 0;
                    state.weeklyStreak = 0;
                    saveData(['consecutiveDays', 'weeklyStreak']);
                }
             } catch(e) {
                // Error parsing dates? Reset streaks defensively.
                console.error("Error in checkDailyReset date diff calculation:", e);
                state.consecutiveDays = 0;
                state.weeklyStreak = 0;
                saveData(['consecutiveDays', 'weeklyStreak']);
             }

            // Regardless of streak reset, the check-in button should be available if not played today
            updateDailyCheckInButtonState();
        }


        function resetDailySpinsIfNeeded(today) {
            if (state.lastDailySpinReset !== today) {
                console.log(`Resetting daily spins for ${today}. Previous reset: ${state.lastDailySpinReset}`);
                let changed = false;
                wheelTypes.forEach(type => {
                    // Reset non-referral spins to 1
                    if (type !== 'referral') {
                        if (state.wheelSpins[type] !== 1) {
                            state.wheelSpins[type] = 1;
                            changed = true;
                        }
                    }
                });
                state.lastDailySpinReset = today;

                if (changed) {
                    console.log("Daily spins were reset.");
                    saveData(['wheelSpins', 'lastDailySpinReset']);
                } else {
                    console.log("Daily spins already seem correct, only updating reset date.");
                    saveData(['lastDailySpinReset']); // Still save the reset date
                }
                updateWheelButtons(); // Update UI after reset
            } else {
                // console.log("Daily spins already reset today."); // Less verbose
            }
        }


        function dailyCheckIn() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;

            if (state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours)) {
                showNotification('Cooldown active. Next check-in available later.', 'warning');
                return;
            }

            // Disable button immediately
            if (domElements.dailyCheckInBtn) {
                domElements.dailyCheckInBtn.disabled = true;
                domElements.dailyCheckInBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking In...';
            }

            const today = getCurrentDubaiDate();
            let pointsAwarded = 5; // Base points
            let streakBonusPoints = 0;
            let newWeeklyStreak = false;
            let streakContinued = false;

            resetDailySpinsIfNeeded(today); // Ensure spins are definitely reset for today

            // Check streak continuity
            if (state.lastPlayedDate) {
                try {
                    const lastPlayedDateObj = new Date(state.lastPlayedDate);
                    const todayDate = new Date(today);
                    const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                    if (diffDays === 1) { // Played yesterday
                        state.consecutiveDays++;
                        streakBonusPoints = Math.min(state.consecutiveDays, 7); // Cap bonus at 7
                        streakContinued = true;
                        console.log(`Streak continued: Day ${state.consecutiveDays}, Bonus +${streakBonusPoints}`);

                        if (state.consecutiveDays > 0 && state.consecutiveDays % 7 === 0) {
                            state.weeklyStreak++;
                            newWeeklyStreak = true;
                            awardMysteryBox(1, "Weekly Streak"); // Award box on completing a week
                            console.log(`Weekly streak advanced to ${state.weeklyStreak}`);
                        }

                        // Grant achievement for 7-day streak
                        if (state.consecutiveDays >= 7) {
                            checkAndGrantAchievement('7_DAY_STREAK');
                        }
                    } else if (diffDays > 1) { // Missed days
                        console.log("Streak broken, starting new streak.");
                        state.consecutiveDays = 1; // Start new streak
                        state.weeklyStreak = 0;
                    } else if (diffDays === 0) {
                        // Should be caught by cooldown check, but handle defensively
                        console.warn("Duplicate check-in attempt on same day detected here.");
                        pointsAwarded = 0; // No points if already checked in
                        streakBonusPoints = 0;
                    } else { // Unexpected diff (e.g., negative) - reset
                        console.warn(`Unexpected day difference ${diffDays}. Resetting streak.`);
                        state.consecutiveDays = 1;
                        state.weeklyStreak = 0;
                    }
                } catch (e) {
                    console.error("Error calculating check-in date difference:", e);
                    state.consecutiveDays = 1; // Reset defensively
                    state.weeklyStreak = 0;
                }
            } else {
                // First ever check-in
                console.log("First check-in.");
                state.consecutiveDays = 1;
                state.weeklyStreak = 0;
            }

            // Grant first check-in achievement if applicable
             if (pointsAwarded > 0) {
                checkAndGrantAchievement('FIRST_CHECKIN');
             }

            // Update state and award points if any were earned
            if (pointsAwarded > 0 || streakBonusPoints > 0) {
                state.lastPlayedDate = today;
                state.lastCheckInTime = now;
                const totalPoints = pointsAwarded + streakBonusPoints;
                awardPoints(totalPoints, "Daily Check-in"); // Award combined points

                // Construct feedback message
                let msg = `Checked in! Day ${state.consecutiveDays}. +${totalPoints} $twote!`;
                if (newWeeklyStreak) {
                    msg += ` Weekly Streak: ${state.weeklyStreak}! +1 Box!`;
                } else if (streakContinued) {
                    // msg += ` Streak bonus: +${streakBonusPoints}!`; // Already included in total points message
                }
                showNotification(msg, 'success');

                // Save all relevant state changes
                saveData(['lastPlayedDate', 'lastCheckInTime', 'consecutiveDays', 'weeklyStreak', 'points', 'level', 'leaderboard', 'achievements', 'mysteryBoxes']); // Added mysteryBoxes
            } else {
                console.log("No points awarded for this check-in (likely duplicate or error).");
                // Still update lastCheckInTime to prevent immediate re-checkin if error occurred
                state.lastCheckInTime = now;
                saveData(['lastCheckInTime']);
                showNotification("Already checked in today.", "info");
            }

            // Update UI elements like button state and streaks display
            updateUI();
            startCountdown(); // Start or update the countdown timer
        }


        function awardPoints(amount, reason = "") {
             if (!Number.isInteger(amount) || amount <= 0) return;
             state.points += amount;
             console.log(`+${amount} points (${reason}). New total: ${state.points}`);

             ensureUserInLeaderboard(); // Update user's points in the leaderboard state
             const previousLevel = state.level;
             updateUserLevel(); // Check if level changed

             // Determine keys to save
             const keysToSave = ['points', 'leaderboard'];
             if (state.level !== previousLevel) {
                 keysToSave.push('level'); // Save level only if it changed
             }

             saveData(keysToSave);
             updateUI(); // Update displayed points and level
             showNotification(`+${amount} $twote! ✨ (${reason})`, 'success');
         }

        function awardEnergy(amount, reason = "") {
            if (!Number.isInteger(amount) || amount === 0) return;
            const oldEnergy = state.energyLevel;
            state.energyLevel = Math.min(100, Math.max(0, oldEnergy + amount)); // Clamp between 0 and 100
            if (state.energyLevel !== oldEnergy) {
                console.log(`${amount > 0 ? '+' : ''}${amount}% energy (${reason}). New: ${state.energyLevel}%`);
                saveData(['energyLevel']);
                updateUI(); // Update displayed energy
                showNotification(`${amount > 0 ? '+' : ''}${amount}% Energy!⚡️ (${reason})`, 'info');
            } else {
                console.log(`Energy change (${amount}%) resulted in no change from ${oldEnergy}%.`);
            }
        }

        function updateUserLevel() {
            let currentLevel = state.level;
            let newLevelData = levels[0]; // Default to first level

            // Find the highest level the user qualifies for
            for (let i = levels.length - 1; i >= 0; i--) {
                if (state.points >= levels[i].points) {
                    newLevelData = levels[i];
                    break;
                }
            }

            if (newLevelData.name !== currentLevel) {
                state.level = newLevelData.name;
                console.log(`Level up! New level: ${state.level}`);
                showNotification(`Level Up: ${state.level}! 🎉`, 'success');

                // Grant achievements based on level
                if (state.level === "Adept") checkAndGrantAchievement('LEVEL_ADEPT');
                // Add more level achievements here...

                // Note: saveData is typically handled by awardPoints which calls this.
                // If called elsewhere, ensure 'level' is saved.
                updateUI(); // Update displayed level name
            }
         }

        function checkAndGrantAchievement(key) {
              if (!achievementsConfig[key]) {
                  console.warn(`Invalid achievement key: ${key}`);
                  return false; // Indicate failure
              }
              if (!state.achievements.includes(key)) {
                  state.achievements.push(key);
                  const ach = achievementsConfig[key];
                  console.log(`Achievement Unlocked: ${ach.name}`);
                  showNotification(`Achievement: ${ach.name}! 🏅`, 'success');
                  saveData(['achievements']); // Save the updated achievements list
                  updateAchievementsUI(); // Update the UI display
                  return true; // Indicate success
              }
              return false; // Indicate already had achievement
          }

        // --- Challenge Logic ---
        function initializeChallenges() {
             return Array.from({ length: 150 }, (_, i) => {
                 const goalIndex = i % dailyGoals.length; // Cycle through goals
                 const goalData = dailyGoals[goalIndex];
                 return {
                    day: i + 1,
                    goal: goalData.goal,
                    meditation: goalData.meditation,
                    task1: goalData.task1,
                    task2: goalData.task2,
                    points: goalData.points,
                    completed: false,
                    completionDate: null // Store YYYY-MM-DD date when completed
                 };
             });
         }

        function getCompletedDaysCount(maxDay) {
             if (!state.challenges || maxDay <= 0) return 0;
             return state.challenges.slice(0, maxDay).filter(ch => ch.completed).length;
         }

        function isChallengeUnlocked(days) {
             switch (days) {
                 case 7: return true; // Always unlocked
                 case 21: return getCompletedDaysCount(7) === 7; // Requires 7-day completed
                 case 41: return getCompletedDaysCount(21) === 21; // Requires 21-day completed
                 case 66: return state.workshopAccess && getCompletedDaysCount(41) === 41; // Requires workshop + 41-day
                 case 150: return state.workshopAccess && getCompletedDaysCount(66) === 66; // Requires workshop + 66-day
                 default: return false; // Unknown duration
             }
         }

        function loadChallenges() {
            const durations = [7, 21, 41, 66, 150];
            const icons = { 7: 'fa-sun', 21: 'fa-seedling', 41: 'fa-star', 66: 'fa-moon', 150: 'fa-crown' };
            const titles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };

            if (!domElements.challengeOptions) return;
            domElements.challengeOptions.innerHTML = ''; // Clear previous options

            durations.forEach(days => {
                const unlocked = isChallengeUnlocked(days);
                const icon = icons[days] || 'fa-question-circle';
                const title = titles[days] || `${days}-Day`;
                const reqWorkshop = days > 41; // Workshop required for 66 and 150
                const prevDays = days === 21 ? 7 : (days === 41 ? 21 : (days === 66 ? 41 : (days === 150 ? 66 : 0)));
                const prevTitle = titles[prevDays] || `${prevDays}-Day`;
                const prevComplete = prevDays === 0 || getCompletedDaysCount(prevDays) === prevDays;

                const div = document.createElement('div');
                div.className = `challenge-div ${unlocked ? '' : 'locked'}`;
                let content = `<i class="fas ${icon} challenge-icon"></i><h3>${days}-Day: ${title}</h3>`;

                if (unlocked) {
                    // Check if this challenge is the currently active one
                    if (state.currentChallengeDuration === days) {
                        content += `<button class="btn btn-info view-challenge-btn mt-2 btn-sm" data-days="${days}">View Progress</button>`;
                    } else {
                        content += `<button class="btn btn-custom start-challenge-btn mt-2 btn-sm" data-days="${days}">Begin ${title}</button>`;
                    }
                } else {
                    // Explain why it's locked
                    if (!prevComplete) {
                        content += `<p class="warning-text">Complete the ${prevTitle} challenge first.</p>`;
                    } else if (reqWorkshop && !state.workshopAccess) {
                        // If previous is complete but workshop is needed and not accessed
                        content += `<p class="warning-text">Requires Workshop Access</p><div class="d-flex justify-content-center gap-2 mt-2"><button class="btn btn-info enroll-btn btn-sm" data-days="${days}">Enroll Info</button><button class="btn btn-secondary attended-btn btn-sm" data-days="${days}">Enter Code</button></div>`;
                    } else {
                         // Should not happen if logic is correct, but provide a fallback message
                        content += `<p class="warning-text">Locked (Requirement not met)</p>`;
                    }
                }
                div.innerHTML = content;
                domElements.challengeOptions.appendChild(div);
            });
         }


         function displayDailyChallenges(days) {
             if (!days || !domElements.dailyChallengeList) {
                 console.warn("Cannot display daily challenges: No duration set or list element missing.");
                 showSection('wellnessManager'); // Go back if state is invalid
                 return;
             }

             const titles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
             domElements.challengeTitle.textContent = `${days}-Day Challenge: ${titles[days] || ''}`;
             domElements.dailyChallengeList.innerHTML = ''; // Clear previous list
             const dubaiDate = getCurrentDubaiDate();
             let firstUncompletedIdx = -1;

             // Find the index of the first challenge that can be started today
             for(let i = 0; i < days; i++) {
                 const ch = state.challenges[i];
                 if (ch.completed) continue; // Skip completed challenges

                 // If it's the very first challenge (day 1) and not completed, it's startable
                 if (i === 0) {
                     firstUncompletedIdx = 0;
                     break;
                 }

                 // For subsequent challenges, check if the *previous* one was completed *yesterday* or earlier
                 const prevCh = state.challenges[i-1];
                 if (prevCh.completed && prevCh.completionDate && dubaiDate > prevCh.completionDate) {
                     firstUncompletedIdx = i; // This challenge unlocks today
                     break;
                 } else {
                     // If previous not completed, or completed today, cannot start this one yet
                     break; // Stop searching, no more challenges can be started
                 }
             }

             // If all challenges up to 'days' are completed
             if (firstUncompletedIdx === -1 && getCompletedDaysCount(days) === days) {
                 firstUncompletedIdx = days; // Indicates all done, no button needed
                 console.log(`${days}-Day Challenge Completed!`);
                 // Optionally add a completion message here
             }

             console.log(`Displaying challenges for ${days} days. First startable index: ${firstUncompletedIdx}`); // DEBUG

             // Render challenge cards up to the duration 'days'
             state.challenges.slice(0, days).forEach((ch, idx) => {
                 const card = document.createElement('div');
                 card.className = 'challenge-div mb-2';
                 const isStartable = idx === firstUncompletedIdx;

                 let content = `<h4>Day ${ch.day}: ${escapeHtml(ch.goal)}</h4>`;

                 if (ch.completed) {
                     content += `<p style="color: green; font-weight: bold;"><i class="fas fa-check-circle"></i> Completed (+${ch.points} $twote)</p>`;
                     card.classList.add('completed');
                 } else if (isStartable) {
                     content += `<button class="btn btn-custom btn-sm mt-1 start-day-btn" data-day="${ch.day}">Start Day ${ch.day}</button>`;
                     card.classList.add('startable');
                 } else {
                     // Explain why it's locked
                     const prevCh = idx > 0 ? state.challenges[idx - 1] : null;
                     if (prevCh && !prevCh.completed) {
                         content += `<p class="warning-text fs-sm"><i class="fas fa-lock"></i> Complete Day ${ch.day - 1}</p>`;
                     } else if (prevCh && prevCh.completionDate && dubaiDate <= prevCh.completionDate) {
                         // Previous completed today, unlocks tomorrow
                         content += `<p class="text-muted fs-sm"><i class="fas fa-clock"></i> Unlocks after midnight (Dubai)</p>`;
                     } else {
                         // Generic locked state (e.g., index > firstUncompletedIdx)
                         content += `<p class="text-muted fs-sm"><i class="fas fa-lock"></i> Locked</p>`;
                     }
                     card.classList.add('locked');
                 }
                 card.innerHTML = content;
                 domElements.dailyChallengeList.appendChild(card);
             });
         }

        function startChallenge(day) {
            console.log(`Attempting to start challenge for day ${day}`); // DEBUG
            const challenge = state.challenges.find(c => c.day === day);
            if (!challenge) {
                console.error(`Challenge data not found for day ${day}`);
                return;
            }
            if (challenge.completed) {
                showNotification(`Day ${day} is already completed.`, 'info');
                return;
            }

            state.currentChallengeDay = day;
            state.energyBefore = null; // Reset energyBefore

            if (!modalInstances.energyLog) {
                console.error("Energy log modal not initialized!");
                showNotification("Error: Cannot open energy log.", "error");
                return;
            }

            try {
                // Configure the modal for the 'before' stage
                domElements.energyLogModalTitle.textContent = `Day ${day}: ${escapeHtml(challenge.goal)} - Before`;
                domElements.energyLogPrompt.textContent = "Log your current energy level (0-100%).";
                domElements.energySlider.value = state.energyLevel; // Pre-fill with current energy
                if(domElements.energySliderValue) domElements.energySliderValue.textContent = `${state.energyLevel}%`;
                domElements.challengeTasks.style.display = 'none'; // Hide task section initially
                domElements.proofWarning.style.display = 'none'; // Hide proof warning
                if(domElements.task1Proof) domElements.task1Proof.value = ''; // Clear file inputs
                if(domElements.task2Proof) domElements.task2Proof.value = '';

                domElements.submitEnergyLog.textContent = 'Confirm Energy & View Tasks';
                domElements.submitEnergyLog.setAttribute('data-stage', 'before');
                domElements.submitEnergyLog.disabled = false; // Enable submission

                console.log("Showing energy log modal for 'before' stage."); // DEBUG
                modalInstances.energyLog.show();
            } catch (e) {
                console.error("Error configuring or showing energy log modal:", e);
                showNotification("Error displaying challenge details.", "error");
            }
         }

        async function submitEnergyLog() {
             const sliderValue = parseInt(domElements.energySlider.value);
             const stage = domElements.submitEnergyLog.getAttribute('data-stage');
             const challenge = state.challenges.find(c => c.day === state.currentChallengeDay);

             if (!challenge || !modalInstances.energyLog) {
                 console.error("Cannot submit energy log: Missing challenge data or modal instance.");
                 return;
             }

             // Disable button during processing
             domElements.submitEnergyLog.disabled = true;
             domElements.submitEnergyLog.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Processing...';

             if (stage === 'before') {
                 state.energyBefore = sliderValue; // Record energy before starting tasks
                 console.log(`Energy Before (Day ${state.currentChallengeDay}): ${state.energyBefore}%`);

                 // Configure modal for 'after' stage
                 domElements.energyLogModalTitle.textContent = `Day ${state.currentChallengeDay}: ${escapeHtml(challenge.goal)} - After`;
                 domElements.energyLogPrompt.textContent = "Complete tasks & log energy post-challenge.";
                 domElements.challengeTasks.style.display = 'block'; // Show tasks
                 domElements.meditationTask.textContent = escapeHtml(challenge.meditation);
                 domElements.task1Text.textContent = escapeHtml(challenge.task1);
                 domElements.task2Text.textContent = escapeHtml(challenge.task2);

                 // Keep slider at the 'before' value for reference, or reset? Let's keep it.
                 // domElements.energySlider.value = sliderValue;
                 // domElements.energySliderValue.textContent = `${sliderValue}%`;

                 // Reset file inputs and enable 'after' submission (conditionally based on files)
                 if(domElements.task1Proof) domElements.task1Proof.value = '';
                 if(domElements.task2Proof) domElements.task2Proof.value = '';
                 domElements.submitEnergyLog.textContent = 'Submit Completion';
                 domElements.submitEnergyLog.setAttribute('data-stage', 'after');
                 domElements.submitEnergyLog.disabled = true; // Disable until files are added
                 domElements.proofWarning.style.display = 'block'; // Show warning initially

             } else if (stage === 'after') {
                 const energyAfter = sliderValue;
                 const task1File = domElements.task1Proof?.files[0];
                 const task2File = domElements.task2Proof?.files[0];

                 // --- Validation ---
                 if (!task1File || !task2File) {
                     showNotification('Please upload proof for both tasks.', 'warning');
                     domElements.submitEnergyLog.textContent = 'Submit Completion';
                     domElements.submitEnergyLog.disabled = false; // Re-enable button
                     domElements.proofWarning.style.display = 'block'; // Ensure warning is visible
                     return; // Stop submission
                 }
                 console.log(`Energy After (Day ${state.currentChallengeDay}): ${energyAfter}%`);

                 // Simulate upload/processing delay
                 await new Promise(resolve => setTimeout(resolve, 1000));

                 try {
                     // Mark challenge as completed
                     challenge.completed = true;
                     challenge.completionDate = getCurrentDubaiDate(); // Record completion date

                     // Add to history (limit size)
                     state.challengeHistory.push({
                         day: state.currentChallengeDay,
                         goal: challenge.goal,
                         energyBefore: state.energyBefore,
                         energyAfter,
                         task1ProofProvided: !!task1File,
                         task2ProofProvided: !!task2File,
                         completionTimestamp: Date.now()
                     });
                     if (state.challengeHistory.length > 50) {
                         state.challengeHistory.shift(); // Keep history size manageable
                     }

                     // Update overall energy level based on 'after' value
                     updateEnergyLevel(state.energyBefore, energyAfter); // Pass before/after for potential logic
                     awardPoints(challenge.points, `Challenge Day ${state.currentChallengeDay}`);

                     // Check for challenge completion achievements
                     if (state.currentChallengeDuration === 7 && getCompletedDaysCount(7) === 7) {
                         checkAndGrantAchievement('CHALLENGE_7_COMPLETE');
                     }
                     // Add more achievement checks for 21, 41, etc. days if needed

                     // Save all relevant changes
                     saveData(['challenges', 'challengeHistory', 'energyLevel', 'points', 'level', 'leaderboard', 'achievements']);

                     modalInstances.energyLog.hide();
                     showNotification(`Day ${state.currentChallengeDay} completed! 🎉`, 'success');
                     displayDailyChallenges(state.currentChallengeDuration); // Refresh the list view

                 } catch (error) {
                     console.error("Error processing challenge completion:", error);
                     showNotification('Error submitting completion. Please try again.', 'error');
                     // Re-enable button on error
                     domElements.submitEnergyLog.textContent = 'Submit Completion';
                     domElements.submitEnergyLog.disabled = false;
                 } finally {
                     // Clean up state regardless of success/error
                     state.currentChallengeDay = null;
                     state.energyBefore = null;
                 }
             }
        }

        function updateEnergyLevel(before, after) {
             // Current logic just sets energy to the 'after' value.
             // Could add more complex logic here (e.g., average, bonus for increase).
             if (after !== null && after !== undefined) {
                 const oldEnergy = state.energyLevel;
                 const newEnergy = Math.min(Math.max(after, 0), 100); // Use 'after' value, clamped
                 if (newEnergy !== oldEnergy) {
                     state.energyLevel = newEnergy;
                     console.log(`Energy updated from ${oldEnergy}% to ${state.energyLevel}% based on challenge log.`);
                     saveData(['energyLevel']);
                     updateUI(); // Reflect change in UI
                 }
             }
         }

        function showEnrollModal(days) {
             if (!modalInstances.enroll) return;
             domElements.enrollName.textContent = state.userName;
             domElements.enrollEnergy.textContent = state.energyLevel;
             const canEnroll = state.energyLevel >= 70;
             domElements.submitEnrollment.disabled = !canEnroll;
             domElements.enrollRequirement.style.display = canEnroll ? 'none' : 'block';
             // Ensure the onclick handler is set correctly
             domElements.submitEnrollment.onclick = () => enroll(days); // Pass days if needed for context
             modalInstances.enroll.show();
         }

         function enroll(daysContext) { // Added context parameter
             if (state.energyLevel < 70) {
                 showNotification('Requires 70% Energy to enroll!', 'warning');
                 return;
             }
             if (state.workshopAccess) {
                 showNotification('You already have workshop access!', 'info');
                 modalInstances.enroll.hide();
                 return;
             }

             // Grant access
             state.workshopAccess = true;
             saveData(['workshopAccess']);
             modalInstances.enroll.hide();
             showNotification(`Enrollment successful! Workshop access granted.`, 'success');

             // Refresh the challenge options to show newly unlocked challenges
             loadChallenges();
         }

        function showCodeModal(days) {
             if (!modalInstances.code) return;
             domElements.workshopCode.value = '';
             // Ensure the onclick handler is set correctly
             domElements.submitCode.onclick = () => submitCode(days); // Pass days if needed
             modalInstances.code.show();
         }

         function submitCode(daysContext) { // Added context parameter
             const codeInput = domElements.workshopCode;
             const code = codeInput.value.trim();
             const correctCode = "WELLNESS"; // Case-insensitive check below

             if (!code) {
                 showNotification('Please enter the workshop code.', 'warning');
                 codeInput.focus();
                 return;
             }

             if (code.toUpperCase() === correctCode) {
                 if (!state.workshopAccess) {
                     state.workshopAccess = true;
                     saveData(['workshopAccess']);
                     showNotification(`Code accepted! Workshop access granted.`, 'success');
                     // Refresh challenges after gaining access
                     loadChallenges();
                 } else {
                     showNotification('Workshop access already granted!', 'info');
                 }
                 modalInstances.code.hide();
             } else {
                 showNotification('Invalid workshop code.', 'error');
                 codeInput.focus();
                 codeInput.select();
             }
         }

        // --- Game Page Logic (Wheels, Boxes) ---
         function spinWheel(wheelType) {
             console.log(`Spin request for: ${wheelType}`); // DEBUG
             if (isSpinning) {
                 console.warn("Attempted to spin while already spinning.");
                 showNotification("Spin already in progress...", "warning");
                 return;
             }
             if (!wheelType || !wheelTypes.includes(wheelType)){
                 console.error(`Invalid wheel type: ${wheelType}`);
                 return;
             }

             const spinsLeft = state.wheelSpins[wheelType] || 0;
             if (spinsLeft <= 0) {
                 showNotification(`No ${capitalizeFirstLetter(wheelType)} spins left.`, 'warning');
                 return;
             }

             const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
             // Referral spins DON'T require daily check-in, others do
             if (wheelType !== 'referral' && (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours))) {
                 showNotification('Complete your Daily Check-In first to spin this wheel!', 'warning');
                 return;
             }

             if (!modalInstances.wheel || !domElements.modalWheel) {
                 console.error("Wheel modal or wheel element not ready!");
                 showNotification("Wheel cannot be displayed currently.", "error");
                 return;
             }

             console.log(`Starting spin for: ${wheelType}`);
             isSpinning = true;
             activeWheelType = wheelType;
             if (spinTimeoutId) clearTimeout(spinTimeoutId); // Clear any previous failsafe timeout

             // Decrement spin count and save immediately
             state.wheelSpins[wheelType]--;
             saveData(['wheelSpins']);
             updateWheelButtons(); // Update counts and disable buttons visually

             // Prepare and show modal
             domElements.wheelModalTitle.textContent = `Spinning: ${capitalizeFirstLetter(wheelType)}!`;
             domElements.wheelResultDisplay.textContent = "Spinning...";
             domElements.modalWheel.style.transition = 'none'; // Remove transition for reset
             domElements.modalWheel.style.transform = 'rotate(0deg)'; // Reset position

             // Show modal *before* starting animation
             modalInstances.wheel.show();

             // Force reflow/repaint to apply reset before animation starts
             domElements.modalWheel.offsetHeight;

             // Calculate target rotation
             const randomSpins = Math.floor(Math.random() * 5) + 5; // 5-9 full spins
             const randomStopAngle = Math.random() * 360; // Random stopping point within a circle
             const targetRotation = (randomSpins * 360) + randomStopAngle;

             // Set a failsafe timeout
             spinTimeoutId = setTimeout(() => {
                 console.warn("Spin failsafe timeout triggered! Transitionend likely didn't fire.");
                 if (isSpinning) { // Only reset if still marked as spinning
                     handleSpinEnd(null); // Call handler manually
                 }
             }, 5500); // Slightly longer than animation (4s) + buffer

             // Apply animation properties
             domElements.modalWheel.style.transition = 'transform 4s cubic-bezier(0.25, 0.1, 0.25, 1)';
             domElements.modalWheel.style.transform = `rotate(${targetRotation}deg)`;

             // Add event listener for when the transition finishes
             domElements.modalWheel.addEventListener('transitionend', handleSpinEnd, { once: true });
             console.log(`Wheel animation started. Target rotation: ${targetRotation.toFixed(0)}deg`); // DEBUG
         }

         // --- handleSpinEnd ---
        function handleSpinEnd(event) {
             // Check if called by event and if it's the transform property
             if (event && event.propertyName !== 'transform') {
                // console.log("Ignoring transitionend event for property:", event.propertyName); // DEBUG Other transitions
                return;
             }
             // Prevent double execution if failsafe and transitionend both fire close together
             if (!isSpinning) {
                console.log("handleSpinEnd called but isSpinning is false, ignoring."); // DEBUG Double call
                return;
             }

             console.log("Spin animation ended or failsafe triggered. Processing result...");
             if (spinTimeoutId) clearTimeout(spinTimeoutId); // Clear the failsafe timeout

             let finalAngle = 0;
             try {
                const wheelElement = domElements.modalWheel;
                if (!wheelElement) throw new Error("Wheel element not found in DOM");

                // Get the computed final rotation angle
                const currentTransform = window.getComputedStyle(wheelElement).transform;
                 if (currentTransform && currentTransform !== 'none') {
                     // Extract angle from matrix(a, b, c, d, tx, ty) using atan2(b, a)
                     const matrixValues = currentTransform.match(/matrix.*\((.+)\)/);
                     if (matrixValues && matrixValues[1]) {
                         const v = matrixValues[1].split(', ').map(parseFloat);
                         // atan2 gives radians, convert to degrees
                         finalAngle = Math.round(Math.atan2(v[1], v[0]) * (180 / Math.PI));
                         // Normalize angle to be between 0 and 360
                         if (finalAngle < 0) finalAngle += 360;
                     } else {
                        console.warn("Could not parse matrix from transform:", currentTransform);
                     }
                 } else {
                     console.warn("No transform found on wheel element after spin.");
                 }
                 console.log(`Final computed angle: ${finalAngle.toFixed(2)}deg`); // DEBUG Angle

                // Determine winning segment based on angle
                const segmentAngle = 360 / WHEEL_SEGMENTS;
                // Adjust calculation slightly: segments are centered, pointer points to top (0/360 deg)
                // We need to find which segment's *range* the 0 degree pointer falls into AFTER rotation.
                // Example: 8 segments (45 deg each).
                // 0-45 deg -> Segment 8 (index 7)
                // 45-90 deg -> Segment 7 (index 6)
                // ...
                // 315-360 deg -> Segment 1 (index 0)
                // Offset angle slightly to avoid landing exactly on borders
                const adjustedAngle = (finalAngle + segmentAngle / 2) % 360;
                const winningSegmentIndexRaw = Math.floor(adjustedAngle / segmentAngle);
                // The index needs to be mapped back to the visual order if needed, but for rewards, index is fine.
                // Let's assume index 0 = first segment clockwise from top-right-ish based on conic gradient
                const winningSegmentIndex = (WHEEL_SEGMENTS - winningSegmentIndexRaw) % WHEEL_SEGMENTS; // Adjust index based on visual/reward mapping


                console.log(`Winning segment index (calculated): ${winningSegmentIndex}`); // DEBUG Segment

                // --- Define Rewards ---
                 // Ensure rewards array length matches WHEEL_SEGMENTS
                 const rewards = [ // Index 0 corresponds to segment 1 (e.g., #ffd700 0% 12.5%)
                     { type: 'energy', value: 10, message: "+10% Energy!" },       // Segment 1
                     { type: 'points', value: 5, message: "+5 $twote!" },         // Segment 2
                     { type: 'energy', value: 15, message: "+15% Energy!" },       // Segment 3
                     { type: 'mystery_box', value: 1, message: "+1 Mystery Box!" },// Segment 4
                     { type: 'energy', value: 5, message: "+5% Energy!" },        // Segment 5
                     { type: 'points', value: 10, message: "+10 $twote!" },        // Segment 6
                     { type: 'referral_spin', value: 1, message: "+1 Referral Spin!" }, // Segment 7 (Example: Add ref spin)
                     { type: 'points', value: 2, message: "+2 $twote!" },         // Segment 8
                 ];
                 if (rewards.length !== WHEEL_SEGMENTS) {
                    console.error(`Mismatch: WHEEL_SEGMENTS (${WHEEL_SEGMENTS}) vs rewards array (${rewards.length})`);
                    // Handle error, maybe award default
                 }

                 const reward = rewards[winningSegmentIndex] || rewards[0]; // Fallback to first reward if index is somehow invalid

                // --- Award Reward ---
                const prefix = getWheelResultMessagePrefix(activeWheelType);
                const fullMessage = `${prefix} ${reward.message}`;
                domElements.wheelResultDisplay.textContent = fullMessage;
                console.log(`Awarding reward: ${reward.type}, value ${reward.value}`); // DEBUG Reward

                 if (reward.type === 'energy') {
                     awardEnergy(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
                 } else if (reward.type === 'points') {
                     awardPoints(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
                 } else if (reward.type === 'mystery_box') {
                     awardMysteryBox(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
                 } else if (reward.type === 'referral_spin') {
                     state.wheelSpins.referral = (state.wheelSpins.referral || 0) + reward.value;
                     saveData(['wheelSpins']);
                     updateWheelButtons(); // Update UI for referral spins
                 }
                 // Add more reward types here if needed

                 // Schedule modal hide after showing result
                 setTimeout(() => {
                    if(modalInstances.wheel) modalInstances.wheel.hide();
                 }, 2500); // Show result for 2.5 seconds

            } catch (error) {
                console.error("Error during handleSpinEnd reward processing:", error);
                domElements.wheelResultDisplay.textContent = "Spin Error! Awarding default.";
                awardEnergy(5, "Spin Error Fallback"); // Award a default small reward
                setTimeout(() => { if(modalInstances.wheel) modalInstances.wheel.hide(); }, 2500);
            } finally {
                // IMPORTANT: Reset isSpinning flag slightly after modal hide starts
                 setTimeout(() => {
                    console.log("Resetting isSpinning flag.");
                    isSpinning = false;
                    activeWheelType = null;
                    updateWheelButtons(); // Re-enable buttons
                    updateMysteryBoxUI(); // Re-enable mystery box button
                 }, 2600); // Just after modal hide timeout
            }
        }

        function getWheelResultMessagePrefix(wheelType) {
            switch (wheelType) {
                case 'energy': return "Feel the power!";
                case 'sigil': return "Symbols align!";
                case 'happiness': return "Spread the joy!";
                case 'wellness': return "Nurture your being!";
                case 'prosperity': return "Attract abundance!";
                case 'manifestation': return "Your wish is heard!";
                case 'healing': return "Embrace restoration!";
                case 'referral': return "A gift from a friend!";
                default: return "The wheel turns!";
            }
        }

         function awardMysteryBox(count = 1, reason = "") {
            if (!Number.isInteger(count) || count <= 0) return;
            state.mysteryBoxes += count;
            console.log(`+${count} Mystery Box (${reason}). Total: ${state.mysteryBoxes}`);
            saveData(['mysteryBoxes']);
            showNotification(`Received ${count} Mystery Box! 🎁`, 'success');
            updateMysteryBoxUI(); // Update display and button state
         }

         function openMysteryBox() {
            if (isSpinning) { // Prevent opening while wheel is active
                showNotification("Wait for the wheel spin to finish.", "warning");
                return;
            }
            if (state.mysteryBoxes <= 0) {
                showNotification("You don't have any mystery boxes!", 'warning');
                return;
            }

            // Disable button and show loading state
            domElements.openMysteryBoxBtn.disabled = true;
            domElements.openMysteryBoxBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Opening...';
            state.mysteryBoxes--; // Decrement count immediately

            setTimeout(() => {
                 // Weighted rewards pool
                 const rewards = [
                     { type: 'points', value: 15, weight: 4 },
                     { type: 'points', value: 25, weight: 3 },
                     { type: 'points', value: 50, weight: 1 },
                     { type: 'spin', wheel: 'referral', value: 1, weight: 3 }, // Increased weight for spins
                     { type: 'energy', value: 10, weight: 3 },
                     { type: 'energy', value: 20, weight: 1 },
                 ];
                 const totalWeight = rewards.reduce((sum, reward) => sum + reward.weight, 0);
                 let randomWeight = Math.random() * totalWeight;
                 let chosenReward = rewards[rewards.length - 1]; // Default to last if calculation fails

                 for(const reward of rewards) {
                     if (randomWeight < reward.weight) {
                         chosenReward = reward;
                         break;
                     }
                     randomWeight -= reward.weight;
                 }

                 console.log("Mystery Box chosen reward:", chosenReward); // DEBUG

                 // Apply the reward
                 let message = "Opened Box: ";
                 if (chosenReward.type === 'points') {
                     message += `+${chosenReward.value} $twote!`;
                     awardPoints(chosenReward.value, "Mystery Box");
                 } else if (chosenReward.type === 'spin' && wheelTypes.includes(chosenReward.wheel)) {
                     message += `+${chosenReward.value} ${capitalizeFirstLetter(chosenReward.wheel)} spin!`;
                     state.wheelSpins[chosenReward.wheel] = (state.wheelSpins[chosenReward.wheel] || 0) + chosenReward.value;
                     saveData(['wheelSpins']); // Save the updated spin count
                     updateWheelButtons(); // Update wheel buttons UI
                 } else if (chosenReward.type === 'energy') {
                     message += `+${chosenReward.value}% Energy boost!`;
                     awardEnergy(chosenReward.value, "Mystery Box");
                 }

                 checkAndGrantAchievement('OPEN_MYSTERY_BOX'); // Grant achievement for opening
                 // Save changes (points/energy/spins are saved by their respective functions)
                 // Need to save mysteryBoxes count and achievements here
                 saveData(['mysteryBoxes', 'achievements']);
                 showNotification(message, 'success');

                 // Reset button state
                 domElements.openMysteryBoxBtn.innerHTML = 'Open a Box';
                 updateMysteryBoxUI(); // Update count and re-enable button if more boxes exist
                 updateUI(); // General UI update just in case

             }, 1500); // Simulate opening time
         }


        // --- Profile & History ---
        function loadProfileHistory() {
             if (!domElements.profileHistory) return;

             // Get the last 15 entries, newest first
             const history = state.challengeHistory.slice(-15).reverse();

             if (history.length === 0) {
                 domElements.profileHistory.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No challenge history yet.</td></tr>';
                 return;
             }

             // Generate table rows
             domElements.profileHistory.innerHTML = history.map(entry => `
                 <tr>
                     <td class="text-center">${entry.day}</td>
                     <td>${escapeHtml(entry.goal)}</td>
                     <td class="text-center">${entry.energyBefore !== null && entry.energyBefore !== undefined ? entry.energyBefore + '%' : '-'}</td>
                     <td class="text-center">${entry.energyAfter !== null && entry.energyAfter !== undefined ? entry.energyAfter + '%' : '-'}</td>
                     <td class="text-center">${entry.task1ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                     <td class="text-center">${entry.task2ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                 </tr>`).join('');
         }

        function deleteProgress() {
             const confirmationMessage = 'ARE YOU SURE?\n\nThis action will delete ALL your game progress, including points, levels, streaks, completed challenges, tasks, achievements, spins, and mystery boxes.\n\nThis cannot be undone!';

             const confirmCallback = (confirmed) => {
                 if (confirmed) {
                     performDeletion();
                 } else {
                     showNotification("Deletion cancelled.", "info");
                 }
             };

             // Use Telegram's confirmation popup if available, otherwise use browser confirm
             if (window.Telegram?.WebApp?.showConfirm) {
                 Telegram.WebApp.showConfirm(confirmationMessage, confirmCallback);
             } else {
                 if (confirm(confirmationMessage)) {
                     performDeletion();
                 } else {
                     showNotification("Deletion cancelled.", "info");
                 }
             }
        }

        function performDeletion() {
             console.warn("PERFORMING PROGRESS DELETION...");

             // Show a simple overlay (optional, can be improved)
             const overlay = document.createElement('div');
             overlay.id = 'temp-loading';
             overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 1.2em;';
             overlay.innerHTML = 'Deleting Progress... Please wait.';
             document.body.appendChild(overlay);

             // Store identity before clearing
             const userId = state.userId, userName = state.userName, userPhoto = state.userPhoto;

             try {
                 // Clear LocalStorage keys associated with this user
                 clearLocalStorageForUser(userId);

                 // Reset the global state object to defaults
                 state = initializeState();

                 // Restore user identity
                 state.userId = userId;
                 state.userName = userName;
                 state.userPhoto = userPhoto;

                 // Reset leaderboard (may keep bots or clear completely)
                 state.leaderboard = initializeState().leaderboard; // Reset to default bots
                 ensureUserInLeaderboard(); // Add the user back with 0 points

                 // IMPORTANT: Save the *fully reset* state back to LocalStorage
                 // This prevents old data reappearing on next load if clearing failed partially
                 const keysToSave = Object.keys(state).filter(k => k !== 'userId' && k !== 'userName' && k !== 'userPhoto');
                 saveStateToLocal(keysToSave); // Use saveStateToLocal directly to ensure ALL keys are reset

                 console.log("Progress deleted and state reset.");
                 showNotification('All progress has been reset.', 'success');

                 // Update UI and navigate to the initial state
                 updateUI(); // Reflect the reset state
                 loadProfileHistory(); // Clear history table
                 showInitialSection(); // Go back to horoscope or wellness manager

             } catch (error) {
                 console.error("Error during deletion process:", error);
                 showNotification('An error occurred while resetting progress. Some data might remain.', 'error');
             } finally {
                 // Remove overlay after a short delay to ensure message is seen
                 setTimeout(() => overlay.remove(), 1500);
             }
         }


        // --- Task Management ---
        function completeTask(taskKey) {
             if (state.completedTasks.includes(taskKey)) {
                 showNotification(`Task '${capitalizeFirstLetter(taskKey)}' already completed!`, 'info');
                 return;
             }

             const button = domElements[`${taskKey}TaskBtn`];
             if (button) {
                 button.disabled = true; // Disable button immediately
                 button.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Verifying...';
             }

             // Simulate verification delay
             setTimeout(() => {
                 // Double-check in case of race conditions (unlikely here but good practice)
                 if (!state.completedTasks.includes(taskKey)) {
                    state.completedTasks.push(taskKey);
                    awardPoints(10, `Task: ${capitalizeFirstLetter(taskKey)}`); // Award points
                    saveData(['completedTasks', 'points', 'level', 'leaderboard']); // Save relevant state
                    showNotification(`Task '${capitalizeFirstLetter(taskKey)}' verified! +10 $twote`, 'success');
                 } else {
                    // Already completed by another means before timeout finished
                    showNotification(`Task '${capitalizeFirstLetter(taskKey)}' already completed!`, 'info');
                 }
                 updateTaskButtons(); // Update button state (will show 'Done')
             }, 1500); // 1.5 second delay
        }


        // --- Referral Simulation ---
        function simulateReferralCompletion() {
            console.log("Simulating referral completion...");
            const referralPoints = 20;
            const referralSpins = 3;

            awardPoints(referralPoints, "Referral Bonus (Simulated)");
            state.wheelSpins.referral = (state.wheelSpins.referral || 0) + referralSpins;
            checkAndGrantAchievement('FIRST_REFERRAL'); // Grant achievement

            saveData(['points', 'level', 'leaderboard', 'wheelSpins', 'achievements']); // Save all changes

            showNotification(`Referral simulated! +${referralPoints} $twote & +${referralSpins} Ref Spins!`, 'success');
            updateUI(); // Update displayed points, spins, achievements
        }

        function copyReferralLink() {
             const input = domElements.referralLink;
             if (!input || !input.value || input.value === "Link unavailable") {
                 showNotification('Referral link is not available.', 'warning');
                 return;
             }

             const textToCopy = input.value;

             // Try using Telegram's clipboard first if available
             if (window.Telegram?.WebApp?.clipboard?.writeText) {
                 Telegram.WebApp.clipboard.writeText(textToCopy, (success) => {
                     if (success) {
                         showNotification('Referral link copied! (via TG)', 'success');
                     } else {
                         // Fallback if Telegram method fails (e.g., permissions)
                         console.warn("Telegram clipboard write failed, falling back to navigator.");
                         copyUsingNavigator(textToCopy);
                     }
                 });
             } else {
                 // Fallback to standard browser clipboard API
                 copyUsingNavigator(textToCopy);
             }
         }

         function copyUsingNavigator(text) {
             navigator.clipboard.writeText(text).then(() => {
                 showNotification('Referral link copied!', 'success');
             }).catch(err => {
                 console.error('Failed to copy referral link using navigator.clipboard:', err);
                 showNotification('Could not copy link. Please copy manually.', 'error');
                 // Optionally select the text for easier manual copying
                 domElements.referralLink?.select();
             });
         }


        // --- Event Listeners Setup ---
         function setupEventListeners() {
             console.log("Setting up event listeners...");

             // Helper function to add listeners safely
             const addListener = (element, event, handler) => {
                 if (element) {
                     element.addEventListener(event, handler);
                 } else {
                    // Find the ID for the missing element for better debugging
                    const elementId = Object.keys(domElements).find(key => domElements[key] === element);
                    console.warn(`Event listener not attached: Element ${elementId || ''} not found.`);
                 }
             };

             // Navigation & Profile
             addListener(domElements.profileLink, 'click', () => showSection('playerProfile'));
             addListener(domElements.navHome, 'click', (e) => { e.preventDefault(); showSection('wellnessManager'); });
             addListener(domElements.navTasks, 'click', (e) => { e.preventDefault(); showSection('tasksSection'); });
             addListener(domElements.navGame, 'click', (e) => { e.preventDefault(); showSection('gamePage'); });
             addListener(domElements.navProfile, 'click', (e) => { e.preventDefault(); showSection('playerProfile'); });

             // Birthdate Form
             addListener(domElements.saveHoroscopeBtn, 'click', saveHoroscope);

             // Wellness Manager (Challenge Selection) - Event Delegation
             addListener(domElements.challengeOptions, 'click', (event) => {
                 const btn = event.target.closest('button');
                 if (!btn || !btn.dataset.days) return; // Ignore clicks not on a button with days data

                 const days = parseInt(btn.dataset.days);
                 if (btn.classList.contains('start-challenge-btn')) {
                     console.log(`Start challenge button clicked for ${days} days`); // DEBUG
                     state.currentChallengeDuration = days;
                     saveData(['currentChallengeDuration']);
                     showSection('dailyChallenges');
                 } else if (btn.classList.contains('view-challenge-btn')) {
                     console.log(`View challenge button clicked for ${days} days`); // DEBUG
                     showSection('dailyChallenges'); // Just navigate to the view
                 } else if (btn.classList.contains('enroll-btn')) {
                     showEnrollModal(days);
                 } else if (btn.classList.contains('attended-btn')) {
                     showCodeModal(days);
                 }
             });

             // Daily Challenge List (Start Day) - Event Delegation
             addListener(domElements.dailyChallengeList, 'click', (event) => {
                 const btn = event.target.closest('button.start-day-btn');
                 if (btn && btn.dataset.day) {
                     console.log(`Start Day button clicked for day: ${btn.dataset.day}`); // DEBUG
                     startChallenge(parseInt(btn.dataset.day));
                 } else {
                     // console.log("Clicked inside daily challenge list, but not on a start button."); // DEBUG Other clicks
                 }
             });

             // Energy Log Modal
             addListener(domElements.energySlider, 'input', () => {
                 if(domElements.energySliderValue) domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`;
             });
             addListener(domElements.submitEnergyLog, 'click', submitEnergyLog);

             // File Input Handling (Enable/Disable Submit Button)
             [domElements.task1Proof, domElements.task2Proof].forEach(input => {
                 addListener(input, 'change', () => {
                     if (domElements.submitEnergyLog?.getAttribute('data-stage') === 'after') {
                         const f1 = domElements.task1Proof?.files[0];
                         const f2 = domElements.task2Proof?.files[0];
                         const bothFilesProvided = f1 && f2;
                         if(domElements.submitEnergyLog) domElements.submitEnergyLog.disabled = !bothFilesProvided;
                         if(domElements.proofWarning) domElements.proofWarning.style.display = bothFilesProvided ? 'none' : 'block';
                     }
                 });
             });

             // Game Page Elements
             addListener(domElements.dailyCheckInBtn, 'click', dailyCheckIn);
             addListener(domElements.openMysteryBoxBtn, 'click', openMysteryBox);

             // Wheel Buttons - Event Delegation on Grid Container
             const wheelGrid = document.querySelector('.wheel-button-grid');
             addListener(wheelGrid, 'click', (event) => {
                  const btn = event.target.closest('button.wheel-button');
                  // Check if it's a valid button, has a wheel type, and is not disabled
                  if (btn && btn.dataset.wheel && !btn.disabled) {
                     console.log(`Wheel spin button clicked: ${btn.dataset.wheel}`); // DEBUG
                     spinWheel(btn.dataset.wheel);
                  } else if (btn && btn.disabled) {
                     console.log(`Disabled wheel button clicked: ${btn.dataset.wheel || 'Unknown'}`); // DEBUG Disabled clicks
                     // Optionally show a specific message why it's disabled (e.g., no spins, check-in needed)
                     if (!isSpinning) { // Don't show extra messages if disabled due to active spin
                        if (state.wheelSpins[btn.dataset.wheel] <= 0) {
                            showNotification(`No ${capitalizeFirstLetter(btn.dataset.wheel)} spins left.`, 'info');
                        } else {
                            showNotification(`Check-in required or spin limit reached.`, 'info');
                        }
                     }
                  }
             });

             // Tasks Page
             addListener(domElements.claimReferralRewardBtn, 'click', simulateReferralCompletion);
             addListener(domElements.copyReferralBtn, 'click', copyReferralLink);
             addListener(domElements.telegramTaskBtn, 'click', () => completeTask('telegram'));
             addListener(domElements.twitterTaskBtn, 'click', () => completeTask('twitter'));
             addListener(domElements.instagramTaskBtn, 'click', () => completeTask('instagram'));
             addListener(domElements.youtubeTaskBtn, 'click', () => completeTask('youtube'));

             // Profile Page Actions
             addListener(domElements.deleteProgressBtn, 'click', deleteProgress);
             addListener(domElements.connectWalletBtn, 'click', () => showNotification('Wallet connection coming soon!', 'info'));
             addListener(domElements.airdropWithdrawBtn, 'click', () => showNotification('$twote withdrawal coming soon!', 'info'));

             console.log("Event listeners setup complete.");
         }

    </script>
</body>
</html>
