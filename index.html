<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Third Eye - Game</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon"> <!-- Placeholder for favicon -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #4E342E;
            --text-color: #FFF8E1;
            --button-color: #FFD700;
            --button-text-color: #3E2723;
            --wellness-manager-color: #3E2723; /* Dark brown */
            --warning-color: #d9534f; /* Bootstrap danger-ish red */
            --challenge-description-color: #3E2723; /* Dark brown for challenge descriptions */
            --level-color: #00bcd4; /* Cyan for level */
            --achievement-color: #ff9800; /* Orange for achievements */
            --wheel-pointer-color: #FF0000; /* Red pointer */
        }
        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            padding-bottom: 70px; /* Space for footer nav */
        }
        #backgroundVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            opacity: 0.3; /* Dim the video */
        }
        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 15px;
        }
        .section {
            background: rgba(62, 39, 35, 0.7); /* Darker brown, semi-transparent */
            backdrop-filter: blur(8px);
            padding: 20px; /* Reduced padding */
            border-radius: 15px; /* Slightly smaller radius */
            margin-bottom: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 248, 220, 0.2); /* Subtle border */
        }
        .challenge-div {
            background: rgba(255, 255, 255, 0.9); /* Lighter background for contrast */
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: var(--challenge-description-color);
        }
         .challenge-div h3, .challenge-div h4 {
             color: var(--challenge-description-color);
             margin-bottom: 10px;
             font-size: 1.1rem; /* Consistent size */
         }
        .challenge-div p {
             color: var(--challenge-description-color);
             font-size: 0.9rem; /* Slightly smaller */
             margin-bottom: 8px;
        }
         .challenge-div .warning-text {
            color: var(--warning-color);
            font-weight: bold;
            font-size: 0.85rem;
        }
        .challenge-icon {
            font-size: 2em; /* Smaller */
            margin-bottom: 8px;
            color: var(--challenge-description-color); /* Match text */
        }
        /* Use icon inside the challenge-div specifically */
        .challenge-div > i.challenge-icon {
            color: var(--wellness-manager-color); /* Darker icon */
        }

        .modal-content {
            background: var(--bg-color);
            color: var(--text-color);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
        }
        .modal-header, .modal-footer {
            border: none;
        }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%); }

        .btn-custom {
            background-color: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 8px 16px; /* Smaller padding */
            border-radius: 8px;
            font-weight: 600; /* Slightly bolder */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .btn-custom:hover, .btn-custom:focus {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: var(--button-text-color);
            background-color: var(--button-color); /* Keep color on hover */
        }
         .btn-custom:active {
             transform: translateY(0px);
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
         }
         .btn-custom:disabled {
             background-color: #a0a0a0;
             cursor: not-allowed;
             opacity: 0.7;
             transform: none;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
         }

        .btn-danger {
            background-color: var(--warning-color);
            color: #fff;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
             transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .btn-danger:hover, .btn-danger:focus {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: #fff;
            background-color: var(--warning-color); /* Keep color */
        }
        .btn-danger:active {
             transform: translateY(0px);
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
         }

        .locked {
            opacity: 0.6;
            background: rgba(200, 200, 200, 0.7); /* Grey out locked challenges */
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0; /* Reduced padding */
            margin-bottom: 15px;
        }
        header img[src="logo.webp"] {
            width: 35px; /* Smaller logo */
            height: 35px;
            border-radius: 50%;
            margin-right: 8px;
        }
        header h1 {
            margin: 0;
            font-size: 1.5rem; /* Smaller title */
            color: var(--text-color);
            font-weight: 700;
        }
        #profileLink { cursor: pointer; }
        #profilePhoto {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            border: 2px solid var(--button-color); /* Highlight profile pic */
        }
        #profileNameDisplay, #profileLevelDisplay, #pointsDisplay {
            font-size: 0.8rem; /* Smaller text */
            line-height: 1.2;
            text-align: right;
            margin-top: 2px;
        }
        #profileNameDisplay { font-weight: bold; }
        #pointsDisplay { color: var(--button-color); font-weight: bold; }
        #profileLevelDisplay { color: var(--level-color); font-size: 0.75rem; }

        h2 {
             color: var(--text-color);
             text-align: center;
             margin-bottom: 15px; /* Reduced margin */
             font-size: 1.4rem; /* Slightly smaller */
             font-weight: 700;
         }
         h3 {
             color: var(--text-color);
             font-size: 1.2rem;
             font-weight: 600;
         }
         h4 {
            color: var(--text-color);
            font-size: 1rem;
            font-weight: 600;
         }

        .warning-text {
            color: var(--warning-color);
            font-weight: bold;
        }
        .footer-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(78, 52, 46, 0.9); /* Slightly less transparent */
            padding: 8px 0; /* Reduced padding */
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        .footer-nav a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 12px; /* Smaller font */
            text-align: center;
            transition: transform 0.2s;
            flex: 1;
            padding: 4px 0;
        }
        .footer-nav a:hover, .footer-nav a.active { /* Add active state */
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            color: var(--button-color); /* Highlight active icon */
        }
        .footer-nav a i {
            display: block;
            font-size: 18px; /* Smaller icons */
            margin-bottom: 2px;
        }
        .task-icon {
            font-size: 1.5em; /* Smaller */
            margin-right: 8px;
            color: var(--text-color);
        }
        #socialMediaTasks ul { list-style-type: none; padding: 0; }
        #socialMediaTasks li { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; flex-wrap: wrap; background: rgba(0,0,0,0.1); padding: 8px; border-radius: 5px;}
        #socialMediaTasks li > div { display: flex; align-items: center; margin-right: 10px; margin-bottom: 5px; }
        #socialMediaTasks a { color: var(--text-color); text-decoration: underline; margin-left: 5px; font-weight: 600;}
        #socialMediaTasks a:hover { text-decoration: none; }
        #socialMediaTasks button { padding: 5px 10px; font-size: 0.8em; }

        #referralTask { margin-top: 20px; background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px; }
        #referralTask p { margin-bottom: 10px; font-size: 0.9rem;}
        #referralTask input[type="text"] { background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: var(--text-color); padding: 8px; border-radius: 5px; font-size: 0.9rem;}
        #referralTask button { width: 80px; font-size: 0.9rem; padding: 6px 10px;}

        /* Game Page specific styles */
        .wheel-button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Adjust min width */
            gap: 10px;
            margin-bottom: 15px;
        }
        .wheel-button {
            padding: 10px 5px;
            font-size: 0.8em; /* Smaller font */
            text-align: center;
            display: flex; /* Flex layout for icon and text */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 65px; /* Ensure consistent height */
            line-height: 1.2;
        }
         .wheel-button i {
             /* display: block; */ /* Removed, handled by flex */
             font-size: 1.4em; /* Smaller icon */
             margin-bottom: 4px;
         }
         .wheel-button span.spins-left { /* Style for spin count */
            display: block;
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 2px;
         }

         .mystery-box-section {
            text-align: center;
            margin-top: 20px;
            border-top: 1px solid rgba(255, 248, 220, 0.2);
            padding-top: 20px;
            background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px;
         }
         .mystery-box-section .fa-box-open {
             font-size: 2.5em; /* Smaller */
             color: var(--button-color);
             margin-bottom: 8px;
         }
         #mysteryBoxCount {
             font-weight: bold;
             color: var(--button-color);
         }

         /* Progression & Achievements */
         #levelDisplay {
             font-size: 1rem; /* Smaller */
             font-weight: bold;
             color: var(--level-color);
             margin-bottom: 10px;
             text-align: center;
         }
         #achievementsList {
             list-style: none;
             padding: 0;
             text-align: center;
             margin-bottom: 20px;
         }
         #achievementsList li {
             display: inline-block;
             background: rgba(0,0,0, 0.4); /* Darker */
             color: var(--achievement-color);
             padding: 4px 8px; /* Smaller */
             border-radius: 12px;
             margin: 3px;
             font-size: 0.8em; /* Smaller */
             border: 1px solid var(--achievement-color);
             cursor: default; /* Indicate it's clickable for title */
         }
         #achievementsList li i {
             margin-right: 4px;
         }
         .subscription-info {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px dashed rgba(255, 248, 220, 0.3);
             text-align: center;
             font-size: 0.85em;
             opacity: 0.8;
         }


        /* Responsive Design */
        @media (max-width: 576px) {
            .container { padding: 0 10px; }
            .section { padding: 15px; margin-bottom: 10px;}
            .challenge-div { padding: 10px; }
            .challenge-icon { font-size: 1.8em; }
            h1 { font-size: 1.3rem; } h2 { font-size: 1.2rem; } h3 { font-size: 1.1rem; }
            .challenge-div h3, .challenge-div h4 { font-size: 1rem; }
            p { font-size: 0.85rem; }
            .footer-nav a { font-size: 11px; } .footer-nav a i { font-size: 16px; }
            header { flex-direction: column; text-align: center; }
            header > div:last-child { margin-top: 8px; text-align: center;} /* Center profile info */
            #profileNameDisplay, #profileLevelDisplay, #pointsDisplay { text-align: center; }
            #socialMediaTasks li { flex-direction: column; align-items: flex-start;}
            #socialMediaTasks li > div { margin-bottom: 8px; }
            #socialMediaTasks button { width: 100%; margin-top: 5px; font-size: 0.8em;}
            #referralTask { flex-direction: column; }
            #referralTask input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px;}
            #referralTask button { width: 100%; }
            .wheel-button-grid { grid-template-columns: repeat(2, 1fr); gap: 8px;} /* Force 2 columns */
            .wheel-button { font-size: 0.75em; min-height: 60px;}
            .wheel-button i { font-size: 1.3em;}
            .table th, .table td { padding: 0.4rem 0.3rem; font-size: 0.8rem;} /* Smaller table text */
            .table img { max-width: 30px; }
        }

        /* Table styling */
        .table { color: var(--text-color); background-color: rgba(0, 0, 0, 0.3); border-radius: 8px; overflow: hidden; margin-top: 15px; border-collapse: separate; border-spacing: 0; font-size: 0.9rem;}
        .table th, .table td { border-top: 1px solid rgba(255, 248, 220, 0.15); padding: 0.5rem 0.4rem; vertical-align: middle; }
        .table thead th { color: var(--button-color); background-color: rgba(0, 0, 0, 0.5); border-top: none; border-bottom: 2px solid var(--button-color); font-weight: bold; text-align: center; }
        .table tbody tr:first-child td { border-top: none; }
        .table tbody tr:hover { background-color: rgba(255, 248, 220, 0.08); }
        .table img { max-width: 35px; height: auto; border-radius: 4px; }
        .table .table-primary td { background-color: rgba(var(--button-color), 0.2) !important; font-weight: bold; }
        .table .rank-col { width: 50px; text-align: center;}
        .table .points-col { width: 100px; text-align: right;}
        .table-responsive { border-radius: 8px; }
        .table-sm th, .table-sm td { padding: 0.4rem 0.4rem; } /* Keep table-sm adjustments */
        .table .text-success { color: #28a745 !important; }
        .table .text-danger { color: var(--warning-color) !important; }

        /* Energy Log Modal Enhancements */
        .form-range::-webkit-slider-thumb { background-color: var(--button-color); }
        .form-range::-moz-range-thumb { background-color: var(--button-color); }
        #challengeTasks { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px; margin-top: 15px;}
        #challengeTasks p { font-size: 0.9rem; }
        #challengeTasks .form-control-sm { font-size: 0.8rem; padding: 0.3rem 0.6rem;}

        /* Wheel Modal Styles */
        #wheelModal .modal-dialog { max-width: 90vw; width: 350px; /* Max width for the wheel */ }
        .wheel-outer-container {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .wheel-pointer {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 25px solid var(--wheel-pointer-color); /* Arrow pointing down */
            position: relative;
            top: -10px; /* Position above the wheel */
            z-index: 10;
            margin-bottom: -15px; /* Adjust spacing */
        }
        .wheel-container {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 5px solid var(--button-color);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            /* Basic conic-gradient for segments - customize colors */
            background: conic-gradient(
                #ffcc00 0% 12.5%, #ff9900 12.5% 25%,
                #ff6600 25% 37.5%, #cc3300 37.5% 50%,
                #990000 50% 62.5%, #cc3300 62.5% 75%,
                #ff6600 75% 87.5%, #ff9900 87.5% 100%
            );
            transition: transform 4s cubic-bezier(0.33, 1, 0.68, 1); /* Spin animation */
            transform: rotate(0deg); /* Initial position */
        }
         #wheelResultDisplay {
            margin-top: 15px;
            font-weight: bold;
            color: var(--button-color);
            text-align: center;
            min-height: 20px; /* Reserve space */
         }
    </style>
</head>
<body>
    <!-- Background video - consider performance on mobile -->
    <video id="backgroundVideo" autoplay muted loop playsinline>
        <source src="cosmic.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <div class="container">
        <header>
            <div class="d-flex align-items-center">
                <!-- <img src="logo.webp" alt="Logo"> --> <!-- Use if you have a logo -->
                 <i class="fas fa-eye" style="font-size: 2rem; margin-right: 8px; color: var(--button-color);"></i> <!-- Simple icon fallback -->
                <h1>Third Eye</h1>
            </div>
            <div id="profileLink">
                <img id="profilePhoto" src="https://via.placeholder.com/40" alt="Profile">
                <span id="profileNameDisplay">Guest</span>
                 <span id="profileLevelDisplay">Level: Novice</span>
                <span id="pointsDisplay">0 $twote</span>
                 <span id="energyHeaderDisplay" style="font-size: 0.8rem; color: #87CEEB;">NRG: 0%</span> <!-- Added Energy to header -->
            </div>
        </header>

        <!-- Sections -->
        <div id="horoscopeForm" class="section" style="display: none;">
            <h2>Enter Your Birthdate</h2>
            <p style="text-align:center; font-size: 0.9rem;">To personalize your journey.</p>
            <input type="date" id="birthdate" class="form-control mb-2" style="background: rgba(255,255,255,0.1); color: var(--text-color); border-color: rgba(255,255,255,0.3);">
            <button class="btn btn-custom w-100 mt-2" id="saveHoroscopeBtn">Save & Continue</button>
        </div>

        <div id="wellnessManager" class="section" style="display: none;">
            <h2>Mindfulness Journey</h2>
            <p style="text-align: center; font-size: 0.9rem;">Select a challenge duration to begin.</p>
            <div id="challengeOptions" class="mt-3"></div>
        </div>

        <div id="dailyChallenges" class="section" style="display: none;">
            <h2 id="challengeTitle">Challenge</h2>
            <div id="dailyChallengeList"></div>
        </div>

        <div id="tasksSection" class="section" style="display: none;">
            <h2>Earn More $twote</h2>
             <div id="socialMediaTasks">
                 <h4 style="color: var(--button-color); margin-bottom: 15px; text-align:center;">Social Tasks (+10 $twote each)</h4>
                 <ul>
                     <li>
                         <div><i class="fab fa-telegram-plane task-icon"></i>Join <a href="https://t.me/ThirdEyeXai" target="_blank">Telegram</a></div>
                         <button class="btn btn-custom btn-sm" id="telegramTaskBtn" onclick="completeTask('telegram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-twitter task-icon"></i>Follow <a href="https://twitter.com/ThirdEyeXai" target="_blank">Twitter</a></div>
                         <button class="btn btn-custom btn-sm" id="twitterTaskBtn" onclick="completeTask('twitter')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-instagram task-icon"></i>Follow <a href="https://instagram.com/ThirdEyeXai" target="_blank">Instagram</a></div>
                         <button class="btn btn-custom btn-sm" id="instagramTaskBtn" onclick="completeTask('instagram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-youtube task-icon"></i>Subscribe <a href="https://youtube.com/@ThirdEyeXai" target="_blank">YouTube</a></div>
                         <button class="btn btn-custom btn-sm" id="youtubeTaskBtn" onclick="completeTask('youtube')">Verify</button>
                     </li>
                 </ul>
             </div>
             <div id="referralTask" class="mt-3">
                 <h4 style="color: var(--button-color); margin-bottom: 10px; text-align:center;">Referral Task (+Bonus Spins!)</h4>
                 <p>Share your link! Both you and your friend earn $twote. You also get bonus spins!</p>
                 <div class="d-flex mb-2">
                     <input type="text" id="referralLink" class="form-control form-control-sm" readonly style="flex-grow: 1; margin-right: 10px;">
                     <button class="btn btn-custom" onclick="copyReferralLink()">Copy</button>
                 </div>
                  <!-- Simple simulation: Button to claim referral reward -->
                 <button class="btn btn-secondary btn-sm mt-2 w-100" id="claimReferralRewardBtn" onclick="simulateReferralCompletion()">Simulate Friend Joined (Dev)</button>
             </div>
        </div>

        <div id="gamePage" class="section" style="display: none;">
            <h2>Engage & Earn</h2>
            <div class="text-center mb-3" style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 5px;">
                <button class="btn btn-custom w-75" id="dailyCheckInBtn">Daily Check-In</button>
                <p id="countdownDisplay" style="color: var(--button-color); margin-top: 10px; font-size: 0.85em;"></p>
            </div>

            <h4 style="text-align:center; margin-bottom: 10px; color: var(--button-color);">Daily Bonus Wheels</h4>
            <p id="spinInfo" class="text-center" style="font-size: 0.8em; margin-bottom: 15px;">Complete Daily Check-In to enable spins.</p>
            <div class="wheel-button-grid">
                <!-- Buttons now trigger the wheel modal -->
                <button class="btn btn-custom wheel-button" id="spinEnergyWheelBtn" data-wheel="energy">
                    <i class="fas fa-bolt"></i>Energy <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinSigilWheelBtn" data-wheel="sigil">
                    <i class="fas fa-magic"></i>Sigil <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinHappinessWheelBtn" data-wheel="happiness">
                    <i class="fas fa-smile-beam"></i>Happiness <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinWellnessWheelBtn" data-wheel="wellness">
                    <i class="fas fa-heartbeat"></i>Wellness <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinProsperityWheelBtn" data-wheel="prosperity">
                    <i class="fas fa-coins"></i>Prosperity <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinManifestationWheelBtn" data-wheel="manifestation">
                    <i class="fas fa-star"></i>Manifest <span class="spins-left">(0)</span>
                </button>
                <button class="btn btn-custom wheel-button" id="spinHealingWheelBtn" data-wheel="healing">
                    <i class="fas fa-hand-holding-heart"></i>Healing <span class="spins-left">(0)</span>
                </button>
                 <button class="btn btn-info wheel-button" id="useReferralSpinBtn" data-wheel="referral">
                    <i class="fas fa-gift"></i>Ref Spins <span id="referralSpinsCount" class="spins-left">(0)</span>
                 </button>
            </div>

            <div class="mystery-box-section">
                <i class="fas fa-box-open"></i>
                <h4 style="color: var(--button-color);">Mystery Boxes</h4>
                <p>Earn boxes from streaks & events!</p>
                <p>You have <span id="mysteryBoxCount">0</span> boxes.</p>
                <button class="btn btn-custom btn-sm" id="openMysteryBoxBtn" disabled>Open a Box</button>
            </div>

             <div class="subscription-info">
                 <p>âœ¨ Premium Tiers Coming Soon! Unlock better rewards, exclusive badges, and more spins!</p>
             </div>
             <div class="section" style="margin-top: 20px; background: rgba(0,0,0,0.2);">
                 <h4 style="text-align: center; color: var(--button-color);">Limited-Time Events</h4>
                 <p style="text-align: center; font-size: 0.9rem;">Check back soon for seasonal challenges and special events!</p>
             </div>
        </div>

        <div id="playerProfile" class="section" style="display: none;">
            <h2>Player Profile</h2>
            <div class="text-center mb-3" style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px;">
                <p style="font-size: 1.1rem;">Welcome, <strong id="profileNameDisplayInner" style="color: var(--button-color);">Guest</strong>!</p>
                 <div id="levelDisplay">Level: <span id="levelName" style="color: var(--level-color); font-weight:bold;">Novice</span></div>
                <div id="pointsProfileDisplay" style="font-size: 1rem;">Points: <span id="pointsValue" style="color: var(--button-color); font-weight:bold;">0</span> $twote</div>
                <div id="energyLevel" style="font-size: 1rem;">Energy: <span id="energyValue" style="color: #87CEEB; font-weight:bold;">0</span>%</div>
                <div id="consecutiveDaysDisplay" style="font-size: 0.9rem;">Daily Streak: <span id="consecutiveDaysValue" style="color: var(--button-color); font-weight:bold;">0</span> days</div>
                <div id="weeklyStreakDisplay" style="font-size: 0.9rem;">Weekly Streak: <span id="weeklyStreakValue" style="color: var(--button-color); font-weight:bold;">0</span> weeks</div>
            </div>
             <div class="d-grid gap-2 mb-3">
                 <button class="btn btn-secondary btn-sm" id="connectWalletBtn">Connect Wallet (Soon)</button>
                 <button class="btn btn-secondary btn-sm" id="airdropWithdrawBtn">Withdraw $twote (Soon)</button>
             </div>

             <h4 class="mt-3 text-center" style="color: var(--button-color);">Achievements</h4>
             <ul id="achievementsList" class="mb-3">
                 <li><i class="fas fa-hourglass-start"></i> No achievements yet</li>
             </ul>

            <h4 class="mt-3" style="color: var(--button-color); text-align: center;">Challenge History (Last 15)</h4>
            <div class="table-responsive">
                <table class="table table-sm">
                    <thead><tr><th>Day</th><th>Goal</th><th>NRG In</th><th>NRG Out</th><th>T1 Proof</th><th>T2 Proof</th></tr></thead>
                    <tbody id="profileHistory"></tbody>
                </table>
            </div>

            <h4 class="mt-3" style="color: var(--button-color); text-align: center;">Leaderboard (Top 100)</h4>
             <div class="table-responsive">
                 <table class="table table-sm">
                     <thead><tr><th class="rank-col">Rank</th><th>Name</th><th class="points-col">Points</th></tr></thead>
                     <tbody id="leaderboard"></tbody>
                 </table>
             </div>
             <div class="text-center mt-4">
                 <button class="btn btn-danger mt-3 btn-sm" id="deleteProgressBtn">Delete All Progress</button>
             </div>
        </div>
    </div>

    <nav class="footer-nav">
        <a href="#" id="navHome"><i class="fas fa-home"></i>Journey</a>
        <a href="#" id="navTasks"><i class="fas fa-tasks"></i>Tasks</a>
        <a href="#" id="navGame"><i class="fas fa-dice"></i>Engage</a>
        <a href="#" id="navProfile"><i class="fas fa-user-astronaut"></i>Profile</a>
    </nav>

    <!-- Modals -->
    <div class="modal fade" id="energyLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="energyLogModalTitle">Energy Log</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p id="energyLogPrompt" style="font-size: 0.95rem;">How positive is your mind frame?</p>
                    <div class="d-flex align-items-center my-3">
                         <span style="font-size: 0.9rem; margin-right: 10px;">0%</span>
                         <input type="range" min="0" max="100" value="50" class="form-range flex-grow-1 me-3" id="energySlider">
                         <span id="energySliderValue" style="color: var(--button-color); font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                         <span style="font-size: 0.9rem; margin-left: 5px;">100%</span>
                    </div>
                    <div id="challengeTasks" style="display: none;">
                        <p class="mb-2"><strong>Meditation:</strong> <span id="meditationTask" style="font-style: italic;"></span></p>
                        <hr style="border-top: 1px solid rgba(255,248,220,0.3);">
                        <p class="mb-1"><strong>Task 1:</strong> <span id="task1Text"></span></p>
                        <input type="file" id="task1Proof" class="form-control form-control-sm mb-2" accept="image/*,video/*,.pdf"> <!-- Allow more types -->
                        <p class="mb-1"><strong>Task 2:</strong> <span id="task2Text"></span></p>
                        <input type="file" id="task2Proof" class="form-control form-control-sm" accept="image/*,video/*,.pdf">
                        <p class="mt-3 text-center warning-text" id="proofWarning" style="display: none; font-size: 0.85em;">Please upload proof for both tasks.</p>
                    </div>
                </div>
                <div class="modal-footer justify-content-center">
                    <button class="btn btn-custom w-75" id="submitEnergyLog" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="enrollModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enroll in Workshop</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                     <p><strong>Name:</strong> <span id="enrollName"></span></p>
                     <p><strong>Current Energy:</strong> <span id="enrollEnergy" style="color: #87CEEB; font-weight: bold;"></span>%</p>
                     <p id="enrollRequirement" class="warning-text" style="font-size: 0.9em; display: none;">Requires 70% Energy</p>
                     <button class="btn btn-custom mt-3 w-50" id="submitEnrollment" disabled>Enroll Now</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="codeModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title">Enter Workshop Code</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body">
                     <input type="text" id="workshopCode" class="form-control mb-3" placeholder="Enter code" style="background: rgba(255,255,255,0.1); color: var(--text-color); border-color: rgba(255,255,255,0.3);">
                      <div class="text-center">
                          <button class="btn btn-custom w-50" id="submitCode">Submit</button>
                      </div>
                 </div>
             </div>
         </div>
     </div>

     <!-- Wheel Modal -->
    <div class="modal fade" id="wheelModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title" id="wheelModalTitle">Spin the Wheel!</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body wheel-outer-container">
                     <div class="wheel-pointer"></div>
                     <div class="wheel-container">
                         <div class="wheel" id="modalWheel"></div>
                     </div>
                     <div id="wheelResultDisplay">Spinning...</div>
                 </div>
                 <div class="modal-footer justify-content-center">
                    <!-- Footer might not be needed if it closes automatically -->
                 </div>
             </div>
         </div>
     </div>


    <!-- Toast Container for Notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
        <!-- Toasts will be appended here -->
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script>
        // --- Constants ---
        const dailyGoals = [ // Simplified, ensure 7 unique ones for the cycle
            { goal: "Abundance", meditation: "Visualize abundance.", task1: "List 3 things you're financially grateful for.", task2: "Set one small financial goal for the week.", points: 5 },
            { goal: "Inner Peace", meditation: "Focus on your breath.", task1: "5-minute silent meditation.", task2: "Write down 3 things causing stress and one action for each.", points: 5 },
            { goal: "Clarity", meditation: "Visualize clear thoughts.", task1: "Mind dump: Write all thoughts for 5 mins.", task2: "Prioritize your top 3 tasks for tomorrow.", points: 5 },
            { goal: "Inspiration", meditation: "Open yourself to ideas.", task1: "Spend 10 mins exploring something new (article, music, art).", task2: "Note down one inspiring idea.", points: 5 },
            { goal: "Self-Love", meditation: "Affirm your worth.", task1: "List 3 qualities you admire about yourself.", task2: "Do one small kind thing for yourself.", points: 5 },
            { goal: "Vitality", meditation: "Visualize vibrant energy.", task1: "5-minute stretching or gentle movement.", task2: "Drink an extra glass of water.", points: 5 },
            { goal: "Connection", meditation: "Feel connected to others.", task1: "Send a positive message to a friend/family member.", task2: "Reflect on a positive interaction you had.", points: 5 }
        ];
        const sections = ['horoscopeForm', 'wellnessManager', 'dailyChallenges', 'tasksSection', 'gamePage', 'playerProfile'];
        const wheelTypes = ['energy', 'sigil', 'happiness', 'wellness', 'prosperity', 'manifestation', 'healing', 'referral'];
        const levels = [
            { name: "Novice", points: 0 },
            { name: "Seeker", points: 100 },
            { name: "Adept", points: 500 },
            { name: "Guardian", points: 1500 },
            { name: "Healer", points: 4000 },
            { name: "Master", points: 10000 },
            { name: "Sage", points: 25000 },
        ];
        const achievementsConfig = {
            'FIRST_CHECKIN': { name: "First Steps", icon: "fa-shoe-prints", description: "Completed your first daily check-in." },
            '7_DAY_STREAK': { name: "Consistent Soul", icon: "fa-calendar-check", description: "Achieved a 7-day streak." },
            'FIRST_REFERRAL': { name: "Community Builder", icon: "fa-users", description: "Successfully referred a friend." },
            'LEVEL_ADEPT': { name: "Adept Achiever", icon: "fa-star", description: "Reached the Adept level." },
            'CHALLENGE_7_COMPLETE': { name: "Foundation Complete", icon: "fa-sun", description: "Completed the 7-Day Foundation Challenge."},
            'OPEN_MYSTERY_BOX': { name: "Curious Explorer", icon: "fa-box", description: "Opened your first Mystery Box." },
            // Add more as needed
        };
        const DUBAI_TIMEZONE_OFFSET_MS = 4 * 60 * 60 * 1000; // UTC+4
        const WHEEL_SEGMENTS = 8; // Number of segments defined in the CSS conic-gradient

        // --- Global State & Variables ---
        let state = {};
        let sectionStack = ['wellnessManager']; // Default starting point after birthdate
        let domElements = {};
        let modalInstances = {}; // Store all modal instances
        let activeWheelType = null; // Track which wheel is spinning
        let isSpinning = false; // Prevent multiple spins


        // --- Helper Functions ---
        function getDomElements() {
            const ids = [
                'backgroundVideo', 'profilePhoto', 'profileNameDisplay', 'profileNameDisplayInner',
                'pointsDisplay', 'profileLevelDisplay', 'energyHeaderDisplay', 'pointsValue',
                'consecutiveDaysValue', 'weeklyStreakValue', 'energyValue', 'challengeOptions',
                'dailyChallengeList', 'challengeTitle', 'energyLogPrompt', 'energySlider',
                'energySliderValue', 'challengeTasks', 'meditationTask', 'task1Text',
                'task2Text', 'task1Proof', 'task2Proof', 'submitEnergyLog', 'profileHistory',
                'referralLink', 'dailyCheckInBtn', 'countdownDisplay', 'leaderboard', 'enrollName',
                 'enrollEnergy', 'submitEnrollment', 'workshopCode',
                'submitCode', 'proofWarning', 'enrollRequirement', 'energyLogModal',
                'enrollModal', 'codeModal', 'wheelModal', 'modalWheel', 'wheelModalTitle', 'wheelResultDisplay',
                'spinInfo', 'levelDisplay', 'levelName', 'achievementsList',
                'mysteryBoxCount', 'openMysteryBoxBtn', 'referralSpinsCount', 'claimReferralRewardBtn',
                // Task Buttons
                'telegramTaskBtn', 'twitterTaskBtn', 'instagramTaskBtn', 'youtubeTaskBtn',
                // Footer Nav
                 'navHome', 'navTasks', 'navGame', 'navProfile'
            ];
             // Add wheel buttons
             wheelTypes.forEach(type => {
                 const btnId = type === 'referral' ? 'useReferralSpinBtn' : `spin${capitalizeFirstLetter(type)}WheelBtn`;
                 ids.push(btnId);
             });

            const elements = {};
            ids.forEach(id => elements[id] = document.getElementById(id));
            return elements;
        }

        function capitalizeFirstLetter(string) {
          if (!string) return '';
          return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getCurrentDubaiDate() {
            const now = Date.now();
            const dubaiTime = new Date(now + DUBAI_TIMEZONE_OFFSET_MS);
            return dubaiTime.toISOString().split('T')[0]; // YYYY-MM-DD format in Dubai
        }

        function showNotification(message, type = 'info') {
            // type can be 'info', 'success', 'warning', 'error'
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return;

            const toast = document.createElement('div');
            let bgClass = 'bg-primary'; // Default to info
            if (type === 'success') bgClass = 'bg-success';
            else if (type === 'warning') bgClass = 'bg-warning text-dark'; // Dark text for yellow bg
            else if (type === 'error') bgClass = 'bg-danger';

            toast.className = `toast align-items-center text-white ${bgClass} border-0`;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            toastContainer.appendChild(toast);
            const bsToast = new bootstrap.Toast(toast, { delay: 3500 }); // Slightly longer delay
            bsToast.show();
             toast.addEventListener('hidden.bs.toast', () => {
                toast.remove();
            });
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing App...");
            // Third-party cookie rejection is a browser security feature, common in iframes.
            // If the app doesn't rely on cross-site cookies, this warning is usually benign.
            // Source map errors for purify.js are likely from browser extensions (e.g., ad blockers)
            // and not an error in this application's code.

            domElements = getDomElements();
            if (!domElements.navHome) { // Basic check if elements loaded
                console.error("Failed to get DOM elements. Aborting initialization.");
                alert("Error: Could not initialize the application UI.");
                return;
            }

            // Initialize Modals
            modalInstances.energyLog = new bootstrap.Modal(domElements.energyLogModal);
            modalInstances.enroll = new bootstrap.Modal(domElements.enrollModal);
            modalInstances.code = new bootstrap.Modal(domElements.codeModal);
            modalInstances.wheel = new bootstrap.Modal(domElements.wheelModal);

            initializeApp();
            setupEventListeners();

            // Handle potential Telegram BackButton issues
            if (window.Telegram?.WebApp) {
                 if (!Telegram.WebApp.isVersionAtLeast('6.1')) {
                    console.warn("[Telegram.WebApp] BackButton is not supported in versions below 6.1. Current version:", Telegram.WebApp.version);
                 }
                 // Setup back button logic only if supported
                 if (window.Telegram?.WebApp?.BackButton) {
                    Telegram.WebApp.BackButton.onClick(() => {
                        console.log("Back button clicked. Stack before pop:", [...sectionStack]);
                        if (sectionStack.length > 1) {
                            sectionStack.pop();
                            const previousSection = sectionStack[sectionStack.length - 1];
                            console.log("Navigating back to:", previousSection);
                            showSection(previousSection, true); // Force show, don't push to stack again
                        } else {
                            console.log("Back button clicked, but stack is empty or has only one item.");
                            // Optionally close the webapp if desired: Telegram.WebApp.close();
                        }
                    });
                 }
            } else {
                console.warn("Telegram WebApp environment not detected. Back button functionality disabled.");
            }
        });

        function initializeState() {
             const defaultLeaderboard = [
                 { userId: 'bot1', name: 'Cosmic Guide', points: 150 },
                 { userId: 'bot2', name: 'Zen Master', points: 120 },
                 { userId: 'bot3', name: 'Astro Explorer', points: 110 },
                 { userId: 'bot4', name: 'Mindful One', points: 95 },
                 { userId: 'bot5', name: 'Starlight', points: 80 },
             ];
             const initialSpins = {};
             // Give 1 free spin daily for non-referral wheels, 0 for referral initially
             wheelTypes.forEach(type => initialSpins[type] = (type === 'referral' ? 0 : 1));

            return {
                userId: null,
                userName: "Guest",
                userPhoto: "https://via.placeholder.com/40",
                energyLevel: 50, // Start with some energy
                points: 0,
                level: "Novice",
                challenges: initializeChallenges(), // Initialize with structure
                challengeHistory: [],
                birthdate: null,
                consecutiveDays: 0,
                weeklyStreak: 0,
                lastPlayedDate: null, // Tracks date for streak logic (YYYY-MM-DD)
                lastCheckInTime: null, // Tracks timestamp for 24h cooldown (milliseconds)
                completedTasks: [], // Array of task keys ('telegram', 'twitter', etc.)
                workshopAccess: false,
                currentChallengeDuration: null, // e.g., 7, 21, 41...
                currentChallengeDay: null,    // Day number being attempted
                energyBefore: null,           // Energy before starting daily challenge task
                leaderboard: defaultLeaderboard,
                achievements: [], // Array of achievement keys like 'FIRST_CHECKIN'
                mysteryBoxes: 0,
                wheelSpins: initialSpins, // Track spins per wheel type
                lastDailySpinReset: null, // Track date when daily spins were last given (YYYY-MM-DD)
            };
        }

        function initializeApp() {
             console.log("Initializing App State...");
             state = initializeState(); // Start with defaults

             let telegramUser = null;
             if (window.Telegram?.WebApp) {
                 Telegram.WebApp.ready(); // Inform Telegram the app is ready
                 Telegram.WebApp.expand(); // Request full height
                  // Set background color based on theme (optional, but good practice)
                  Telegram.WebApp.setHeaderColor('secondary_bg_color');
                  // Basic theme setup
                  try {
                    Telegram.WebApp.postEvent("web_app_set_header_color", { color_key: 'bg_color' });
                    Telegram.WebApp.postEvent("web_app_set_bottom_bar_color", { color: '#ffffff' }); // Example: white bottom bar
                    // Request theme and viewport data
                    Telegram.WebApp.postEvent("web_app_request_theme");
                    Telegram.WebApp.postEvent("web_app_request_viewport");
                    // Listen for theme changes (example)
                    Telegram.WebApp.onEvent('themeChanged', function() {
                        // Adapt your UI if needed, e.g., change CSS variables
                        console.log("Theme changed:", Telegram.WebApp.colorScheme);
                         document.body.style.setProperty('--bg-color', Telegram.WebApp.themeParams.bg_color || '#4E342E');
                         document.body.style.setProperty('--text-color', Telegram.WebApp.themeParams.text_color || '#FFF8E1');
                    });
                    Telegram.WebApp.onEvent('viewportChanged', function() {
                        console.log('Viewport changed:', Telegram.WebApp.viewportHeight, Telegram.WebApp.viewportStableHeight);
                    });

                  } catch (e) { console.error("Error setting up Telegram theme events:", e);}


                 telegramUser = Telegram.WebApp.initDataUnsafe?.user;
                 if (telegramUser) {
                     console.log("Telegram User Data Found:", telegramUser);
                     state.userId = telegramUser.id.toString();
                     state.userName = telegramUser.first_name || "User";
                     // Use Telegram's photo if available, otherwise keep placeholder
                     if (telegramUser.photo_url) {
                        state.userPhoto = telegramUser.photo_url;
                     } else {
                        // Generate a simple placeholder based on initials? (Optional)
                        state.userPhoto = `https://ui-avatars.com/api/?name=${encodeURIComponent(state.userName)}&background=random&color=fff&size=40`; // Example using ui-avatars
                     }
                     // Ensure name is set even if only username is available
                     if (!state.userName && telegramUser.username) {
                        state.userName = telegramUser.username;
                     }
                 } else {
                     console.warn("Telegram user data not found in initDataUnsafe.");
                 }
             } else {
                 console.warn("Telegram WebApp object not available.");
             }

             // Fallback/Persistence: Use Local Storage, prepending Telegram ID if available
             const storageUserId = localStorage.getItem('userId');
             if (telegramUser && storageUserId !== state.userId) {
                // If TG user found and differs from stored ID, prioritize TG user
                // Potentially migrate data later if needed, for now, start fresh for this TG user
                console.log(`Using Telegram User ID: ${state.userId}. Stored ID was ${storageUserId}.`);
                localStorage.setItem('userId', state.userId); // Store the correct ID
             } else if (!state.userId && storageUserId) {
                 // No TG user, but found a stored ID
                 state.userId = storageUserId;
                 console.log(`Using stored User ID: ${state.userId}`);
             } else if (!state.userId && !storageUserId) {
                 // No TG user, no stored ID -> create a new local one
                 state.userId = `local_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
                 console.log(`Generating new local User ID: ${state.userId}`);
                 localStorage.setItem('userId', state.userId);
             }
             // If state.userId was already set by Telegram, this confirms it's stored
             localStorage.setItem('userId', state.userId);


             console.log(`Initializing Data for User ID: ${state.userId}`);
             loadStateFromLocal(); // Load data associated with this user ID
        }

        function getStorageKey(key) {
            // Prefix keys with userId to isolate data for different users in localStorage
            return `${state.userId}_${key}`;
        }

        function loadStateFromLocal() {
             console.log("Loading state from Local Storage...");
             try {
                 // Load primitive values
                 state.energyLevel = parseInt(localStorage.getItem(getStorageKey('energyLevel')) || '50'); // Default 50
                 state.points = parseInt(localStorage.getItem(getStorageKey('points')) || '0');
                 state.level = localStorage.getItem(getStorageKey('level')) || "Novice";
                 state.birthdate = localStorage.getItem(getStorageKey('birthdate')) || null;
                 state.consecutiveDays = parseInt(localStorage.getItem(getStorageKey('consecutiveDays')) || '0');
                 state.weeklyStreak = parseInt(localStorage.getItem(getStorageKey('weeklyStreak')) || '0');
                 state.lastPlayedDate = localStorage.getItem(getStorageKey('lastPlayedDate')) || null;
                 state.lastCheckInTime = localStorage.getItem(getStorageKey('lastCheckInTime')) ? parseInt(localStorage.getItem(getStorageKey('lastCheckInTime'))) : null;
                 state.workshopAccess = localStorage.getItem(getStorageKey('workshopAccess')) === 'true';
                 state.mysteryBoxes = parseInt(localStorage.getItem(getStorageKey('mysteryBoxes')) || '0');
                 state.lastDailySpinReset = localStorage.getItem(getStorageKey('lastDailySpinReset')) || null;

                 // Load complex/object values with defaults
                 state.completedTasks = JSON.parse(localStorage.getItem(getStorageKey('completedTasks')) || '[]');
                 state.achievements = JSON.parse(localStorage.getItem(getStorageKey('achievements')) || '[]');

                 // Load challenges - merge saved completion/date with initialized structure
                 const savedChallenges = JSON.parse(localStorage.getItem(getStorageKey('challenges')) || 'null');
                 if (savedChallenges && Array.isArray(savedChallenges)) {
                    // Merge saved data into the initialized structure
                    state.challenges.forEach((challenge, index) => {
                        const saved = savedChallenges.find(sc => sc.day === challenge.day);
                        if (saved) {
                            challenge.completed = saved.completed || false;
                            challenge.completionDate = saved.completionDate || null; // Load completion date
                        }
                    });
                 } // else use the initialized state.challenges

                 state.challengeHistory = JSON.parse(localStorage.getItem(getStorageKey('challengeHistory')) || '[]');

                 // Load leaderboard, merge with defaults, ensure user is present
                 const savedLeaderboard = JSON.parse(localStorage.getItem(getStorageKey('leaderboard')) || 'null') || [];
                 state.leaderboard = mergeLeaderboards(initializeState().leaderboard, savedLeaderboard); // Use initial default board
                 ensureUserInLeaderboard(); // Add/update current user

                 // Load wheel spins, ensuring all types exist
                 const savedSpins = JSON.parse(localStorage.getItem(getStorageKey('wheelSpins')) || '{}');
                 wheelTypes.forEach(type => {
                     state.wheelSpins[type] = savedSpins[type] ?? (type === 'referral' ? 0 : 1); // Use saved or default
                 });


                 console.log("State loaded:", JSON.parse(JSON.stringify(state))); // Deep copy for logging

                 // Post-load logic
                 checkDailyReset(); // Handles streaks and daily spin reset
                 updateUserLevel(); // Ensure level matches points
                 updateUI();
                 startCountdown();
                 showInitialSection();

             } catch (error) {
                 console.error('Error loading state from LocalStorage:', error);
                 showNotification('Failed to load saved data. Some progress might be lost.', 'error');
                 // Attempt to recover gracefully - use default state but keep user ID/info
                 const userId = state.userId;
                 const userName = state.userName;
                 const userPhoto = state.userPhoto;
                 state = initializeState(); // Reset to defaults
                 state.userId = userId; state.userName = userName; state.userPhoto = userPhoto; // Restore user info
                 ensureUserInLeaderboard(); // Make sure user is in the default board
                 updateUI();
                 showInitialSection();
                 saveData(Object.keys(state)); // Try saving the default state
             }
         }

        function saveStateToLocal(keysToSave) {
            // console.log(`Saving keys to LocalStorage: ${keysToSave.join(', ')}`);
            keysToSave.forEach(key => {
                 // Skip saving sensitive or irrelevant keys if needed
                 if (key === 'userId' || key === 'userName' || key === 'userPhoto') return; // Don't overwrite these here

                 try {
                    let valueToSave;
                    const stateValue = state[key];

                     // Handle different types for JSON stringification
                    if (typeof stateValue === 'object' && stateValue !== null) {
                        valueToSave = JSON.stringify(stateValue);
                    } else if (typeof stateValue === 'boolean') {
                        valueToSave = stateValue ? 'true' : 'false';
                    } else if (stateValue !== null && stateValue !== undefined) {
                        valueToSave = String(stateValue); // Convert numbers, strings to string
                    } else {
                        valueToSave = null; // Explicitly null for removal
                    }

                    const storageKey = getStorageKey(key);
                    if (valueToSave !== null) {
                         localStorage.setItem(storageKey, valueToSave);
                         // console.log(`Saved ${key} (${storageKey}):`, valueToSave.substring(0, 100)); // Log snippet
                     } else {
                         localStorage.removeItem(storageKey);
                         // console.log(`Removed ${key} (${storageKey}) from LocalStorage.`);
                     }
                 } catch (error) {
                     console.error(`Error saving '${key}' to LocalStorage:`, error);
                      // Consider more robust error handling, maybe retry or notify user severely
                      showNotification(`Error saving game data (${key}). Progress might be lost!`, 'error');
                 }
             });
             // console.log(`Save operation completed for keys: ${keysToSave.join(', ')}`);
        }

        // Unified save function
        function saveData(keys = []) {
            if (!Array.isArray(keys) || keys.length === 0) {
                console.warn("saveData called with no keys specified.");
                return;
            }
            // Add dependencies? e.g., if points change, level might change, leaderboard changes...
            if (keys.includes('points') && !keys.includes('level')) keys.push('level');
            if (keys.includes('points') && !keys.includes('leaderboard')) keys.push('leaderboard');
            if (keys.includes('challenges') && !keys.includes('challengeHistory')) keys.push('challengeHistory'); // if one changes, often the other does too
            const uniqueKeys = [...new Set(keys)]; // Ensure unique keys
            saveStateToLocal(uniqueKeys);
        }

        function mergeLeaderboards(defaultBoard, savedBoard) {
            const mergedMap = new Map();
            // Add defaults first
            defaultBoard.forEach(p => mergedMap.set(p.userId, { ...p }));
            // Add / update with saved data
            savedBoard.forEach(p => {
                if (mergedMap.has(p.userId)) {
                    // Update points if higher in saved data (or just always take saved?)
                    const existing = mergedMap.get(p.userId);
                    if (p.points >= existing.points) { // Generally, saved points are more current
                         mergedMap.set(p.userId, { ...p, name: p.name || existing.name }); // Keep existing name if saved is missing
                    }
                } else {
                    mergedMap.set(p.userId, { ...p });
                }
            });
            return Array.from(mergedMap.values());
        }

        function ensureUserInLeaderboard() {
             const userEntry = state.leaderboard.find(p => p.userId === state.userId);
             if (!userEntry) {
                 console.log(`User ${state.userId} not found in leaderboard, adding.`);
                 state.leaderboard.push({ userId: state.userId, name: state.userName, points: state.points });
             } else {
                // Ensure current points and name are reflected
                if (userEntry.points !== state.points || userEntry.name !== state.userName) {
                    console.log(`Updating leaderboard entry for user ${state.userId}`);
                    userEntry.points = state.points;
                    userEntry.name = state.userName;
                }
             }
             // Sorting happens in updateLeaderboardUI
         }


        // --- UI Update Functions ---
         function updateUI() {
             // Header Profile
             domElements.profilePhoto.src = state.userPhoto;
             domElements.profileNameDisplay.textContent = state.userName;
             domElements.pointsDisplay.textContent = `${state.points} $twote`;
             domElements.profileLevelDisplay.textContent = `Level: ${state.level}`;
             domElements.energyHeaderDisplay.textContent = `NRG: ${state.energyLevel}%`; // Update header energy

             // Profile Page Details
             domElements.profileNameDisplayInner.textContent = state.userName;
             domElements.pointsValue.textContent = state.points;
             domElements.energyValue.textContent = state.energyLevel;
             domElements.levelName.textContent = state.level;
             domElements.consecutiveDaysValue.textContent = state.consecutiveDays;
             domElements.weeklyStreakValue.textContent = state.weeklyStreak;

             // Referral Link
             if (state.userId) {
                 const botUsername = "ThirdEyeTestDevBot"; // !! IMPORTANT: Replace with your ACTUAL bot username
                 domElements.referralLink.value = `https://t.me/${botUsername}?start=${state.userId}`;
             } else {
                 domElements.referralLink.value = "Link unavailable";
             }

             // Update dynamic components
             updateDailyCheckInButtonState(); // Also updates countdown indirectly via startCountdown
             updateLeaderboardUI();
             updateTaskButtons();
             updateWheelButtons();
             updateAchievementsUI();
             updateMysteryBoxUI();
             updateReferralSpinsUI();
             updateActiveNav(); // Highlight current nav item
         }

         function updateActiveNav() {
            const currentSection = sectionStack[sectionStack.length - 1];
            const navMap = {
                'wellnessManager': domElements.navHome,
                'dailyChallenges': domElements.navHome, // Part of Journey
                'tasksSection': domElements.navTasks,
                'gamePage': domElements.navGame,
                'playerProfile': domElements.navProfile,
                'horoscopeForm': null // No nav item for initial form
            };
             // Remove active class from all
             [domElements.navHome, domElements.navTasks, domElements.navGame, domElements.navProfile].forEach(nav => nav?.classList.remove('active'));
             // Add active class to the current one
             const activeNav = navMap[currentSection];
             if (activeNav) {
                 activeNav.classList.add('active');
             }
         }

         function updateDailyCheckInButtonState() {
            if (!domElements.dailyCheckInBtn) return;
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const canCheckIn = !state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours);

             domElements.dailyCheckInBtn.disabled = !canCheckIn;
             if (canCheckIn) {
                 domElements.dailyCheckInBtn.textContent = "Daily Check-In";
                 domElements.countdownDisplay.textContent = 'Check-in available!';
                 domElements.spinInfo.textContent = 'Complete Daily Check-In to enable spins.';
             } else {
                 domElements.dailyCheckInBtn.textContent = "Checked In Today";
                 domElements.spinInfo.textContent = 'Spins enabled for today!';
                 startCountdown(); // Ensure countdown is running if checked in
             }
             // Wheel buttons depend on check-in, so update them too
             updateWheelButtons();
         }

        function startCountdown() {
             if (window.checkinCountdownInterval) {
                 clearInterval(window.checkinCountdownInterval);
             }
            if (!state.lastCheckInTime || !domElements.countdownDisplay) {
                // If no check-in time, display available message
                if(domElements.countdownDisplay) domElements.countdownDisplay.textContent = 'Check-in available!';
                // Ensure button state is correct even if countdown isn't needed
                updateDailyCheckInButtonState();
                return;
            }

             const twentyFourHours = 24 * 60 * 60 * 1000;
             const endTime = state.lastCheckInTime + twentyFourHours;

             function updateCountdownDisplay() {
                 const now = Date.now();
                 const timeLeft = endTime - now;

                 if (timeLeft <= 0) {
                     domElements.countdownDisplay.textContent = 'Check-in available!';
                     updateDailyCheckInButtonState(); // Enable button
                     clearInterval(window.checkinCountdownInterval);
                     return;
                 }
                 const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                 const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                 const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                 domElements.countdownDisplay.textContent = `Next check-in: ${hours}h ${minutes}m ${seconds}s`;
                 // Ensure button is disabled while countdown is active
                 if (domElements.dailyCheckInBtn) {
                    domElements.dailyCheckInBtn.disabled = true;
                    domElements.dailyCheckInBtn.textContent = "Checked In Today";
                 }
             }
             updateCountdownDisplay(); // Initial display
             window.checkinCountdownInterval = setInterval(updateCountdownDisplay, 1000);
         }

        function updateWheelButtons() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const checkedInToday = state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours);

             wheelTypes.forEach(type => {
                // Construct the ID dynamically
                const isReferral = type === 'referral';
                const btnId = isReferral ? 'useReferralSpinBtn' : `spin${capitalizeFirstLetter(type)}WheelBtn`;
                const button = domElements[btnId];

                 if (button) {
                     const spinsLeft = state.wheelSpins[type] || 0;
                     const canSpin = checkedInToday && spinsLeft > 0;
                     button.disabled = !canSpin;

                     // Update spin count display within the button
                     const spinsLeftSpan = button.querySelector('.spins-left') || (isReferral ? domElements.referralSpinsCount : null);
                     if (spinsLeftSpan) {
                         spinsLeftSpan.textContent = `(${spinsLeft})`;
                     } else if (!isReferral) {
                         // Fallback if span doesn't exist (add it if needed structure changes)
                         // Find the text node and update it, or append span
                         console.warn(`Could not find .spins-left span for button ${btnId}`);
                     }


                     // Update title for tooltip
                     if (!checkedInToday) {
                        button.title = "Complete daily check-in first";
                     } else if (spinsLeft <= 0) {
                         button.title = isReferral ? "No referral spins left" : "No spins left for today";
                     } else {
                         button.title = `Click to spin (${spinsLeft} left)`;
                     }
                 } else {
                    console.warn(`Wheel button with ID ${btnId} not found in domElements.`);
                 }
             });
        }

        function updateReferralSpinsUI() {
             // This is mostly handled by updateWheelButtons now, but keep for clarity
             const spinsLeft = state.wheelSpins.referral || 0;
             if (domElements.referralSpinsCount) {
                 domElements.referralSpinsCount.textContent = `(${spinsLeft})`;
             }
             if (domElements.useReferralSpinBtn) {
                const now = Date.now();
                const twentyFourHours = 24 * 60 * 60 * 1000;
                const checkedInToday = state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours);
                domElements.useReferralSpinBtn.disabled = !(checkedInToday && spinsLeft > 0);
             }
         }

        function updateTaskButtons() {
             state.completedTasks.forEach(taskKey => {
                 const button = domElements[`${taskKey}TaskBtn`];
                 if (button) {
                     button.disabled = true;
                     button.textContent = 'Done';
                     button.classList.remove('btn-custom', 'btn-info'); // Remove base and potential other styles
                     button.classList.add('btn-success'); // Add success style
                 }
             });
            // Ensure buttons for non-completed tasks are styled correctly (optional, but good practice)
            ['telegram', 'twitter', 'instagram', 'youtube'].forEach(taskKey => {
                if (!state.completedTasks.includes(taskKey)) {
                    const button = domElements[`${taskKey}TaskBtn`];
                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Verify';
                        button.classList.remove('btn-success'); // Ensure success style is removed
                        button.classList.add('btn-custom'); // Ensure base style is present
                    }
                }
            });
         }

        function updateAchievementsUI() {
            if (!domElements.achievementsList) return;
             if (!state.achievements || state.achievements.length === 0) {
                 domElements.achievementsList.innerHTML = '<li><i class="fas fa-hourglass-start"></i> No achievements yet</li>';
                 return;
             }

             domElements.achievementsList.innerHTML = state.achievements.map(key => {
                 const achievement = achievementsConfig[key];
                 if (!achievement) return ''; // Skip if config missing for some reason
                 return `<li title="${achievement.description || ''}">
                            <i class="fas ${achievement.icon || 'fa-question-circle'}"></i> ${achievement.name || 'Unknown Achievement'}
                         </li>`;
             }).join('');
         }

        function updateMysteryBoxUI() {
            if (!domElements.mysteryBoxCount || !domElements.openMysteryBoxBtn) return;
            domElements.mysteryBoxCount.textContent = state.mysteryBoxes;
            domElements.openMysteryBoxBtn.disabled = state.mysteryBoxes <= 0;
         }

        function updateLeaderboardUI() {
            if (!domElements.leaderboard) return;
             // Ensure user is in the list before sorting
             ensureUserInLeaderboard();
             // Sort by points descending
             state.leaderboard.sort((a, b) => b.points - a.points);

             domElements.leaderboard.innerHTML = state.leaderboard.slice(0, 100).map((player, index) => `
                 <tr class="${player.userId === state.userId ? 'table-primary' : ''}">
                     <td class="rank-col">${index + 1}</td>
                     <td>${player.name ? escapeHtml(player.name) : 'Anonymous'}</td>
                     <td class="points-col">${player.points}</td>
                 </tr>
             `).join('');
            if(state.leaderboard.length === 0) {
                domElements.leaderboard.innerHTML = '<tr><td colspan="3" class="text-center">Leaderboard is loading or empty.</td></tr>';
            }
         }

        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
         }

        // --- Navigation ---
         function showInitialSection() {
             const firstSection = state.birthdate ? 'wellnessManager' : 'horoscopeForm';
             sectionStack = [firstSection]; // Reset stack to the initial section
             showSection(firstSection, true); // Show without adding to stack history
         }

         function showSection(sectionId, isNavigatingBack = false) {
             // Prevent pushing same section twice
             if (!isNavigatingBack && sectionId === sectionStack[sectionStack.length - 1]) {
                 console.log("Already on section:", sectionId);
                 return;
             }

             if (!isNavigatingBack) {
                 sectionStack.push(sectionId);
             }

             console.log("Showing section:", sectionId, "Stack:", [...sectionStack]);
             sections.forEach(id => {
                 const el = document.getElementById(id);
                 if (el) el.style.display = id === sectionId ? 'block' : 'none';
             });

             // Update Back Button visibility in Telegram
             if (window.Telegram?.WebApp?.BackButton) {
                if (sectionStack.length > 1) {
                    Telegram.WebApp.BackButton.show();
                } else {
                    Telegram.WebApp.BackButton.hide();
                }
             }

             // Trigger section-specific loading/updates
             switch (sectionId) {
                 case 'wellnessManager': loadChallenges(); break;
                 case 'dailyChallenges': displayDailyChallenges(state.currentChallengeDuration); break;
                 case 'playerProfile': loadProfileHistory(); updateLeaderboardUI(); updateAchievementsUI(); break;
                 case 'gamePage': updateWheelButtons(); updateMysteryBoxUI(); updateReferralSpinsUI(); break;
                 case 'tasksSection': updateTaskButtons(); break;
             }

             updateActiveNav(); // Update footer highlight
             window.scrollTo(0, 0); // Scroll to top on section change
         }

        // --- Core Logic Functions ---

        function saveHoroscope() {
             const birthdateInput = document.getElementById('birthdate');
             const birthdate = birthdateInput.value;
             if (birthdate) {
                 // Basic validation (is it a valid date format?)
                 try {
                    const testDate = new Date(birthdate);
                    if (isNaN(testDate.getTime())) throw new Error("Invalid date");
                    // Optional: Check if date is not in the future?
                 } catch (e) {
                    showNotification('Please enter a valid birthdate.', 'warning');
                    birthdateInput.focus();
                    return;
                 }
                 state.birthdate = birthdate;
                 saveData(['birthdate']);
                 showSection('wellnessManager');
             } else {
                 showNotification('Please enter your birthdate.', 'warning');
                 birthdateInput.focus();
             }
         }

        function checkDailyReset() {
            const today = getCurrentDubaiDate(); // Use Dubai date for reset logic consistency
            console.log(`Checking daily reset: Today (Dubai) is ${today}, Last played was ${state.lastPlayedDate}`);

            // Handle Daily Spin Reset
            resetDailySpinsIfNeeded(today);

            // Handle Streak Logic (based on lastPlayedDate)
            if (!state.lastPlayedDate) {
                // First time playing or data reset
                state.consecutiveDays = 0;
                state.weeklyStreak = 0;
                console.log("No last played date found, streaks reset to 0.");
                // No need to save here, will be saved on next check-in
                return; // Don't check diffDays if no last date
             }

             if (state.lastPlayedDate === today) {
                 console.log("Already played today (based on lastPlayedDate), no change to streaks from reset check.");
                 return; // Streaks don't change if played today
             }

             // Calculate difference in days since last play date
             try {
                const todayDate = new Date(today); // Use parsed Dubai date
                const lastPlayedDateObj = new Date(state.lastPlayedDate);
                const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                console.log(`Difference in days: ${diffDays}`);

                if (diffDays > 1) {
                    // Missed one or more days
                    state.consecutiveDays = 0;
                    state.weeklyStreak = 0;
                    console.log("Missed days, resetting streaks to 0.");
                    saveData(['consecutiveDays', 'weeklyStreak']); // Save the reset streaks immediately
                } else if (diffDays === 1) {
                    // Played yesterday, streak is maintained (will increment on check-in)
                    console.log("Consecutive day detected. Streak will increase on check-in.");
                } else if (diffDays <= 0) {
                    // Should not happen if lastPlayedDate is in the past
                    console.warn(`Unexpected day difference: ${diffDays}. Time travel? Ignoring streak change.`);
                }

             } catch(e) {
                console.error("Error calculating date difference for streak:", e);
                // Reset streaks as a safe fallback if date parsing fails
                state.consecutiveDays = 0;
                state.weeklyStreak = 0;
                saveData(['consecutiveDays', 'weeklyStreak']);
             }

            // Cooldown timer logic remains based on lastCheckInTime (timestamp)
            // updateDailyCheckInButtonState will handle button visibility based on cooldown
            updateDailyCheckInButtonState();
        }

        function resetDailySpinsIfNeeded(today) {
            if (state.lastDailySpinReset !== today) {
                console.log(`New day (${today}), resetting daily wheel spins to 1.`);
                let changed = false;
                wheelTypes.forEach(type => {
                    if (type !== 'referral') { // Don't reset referral spins
                        if (state.wheelSpins[type] !== 1) {
                           state.wheelSpins[type] = 1;
                           changed = true;
                        }
                    }
                });
                state.lastDailySpinReset = today;
                if (changed) {
                    saveData(['wheelSpins', 'lastDailySpinReset']);
                    updateWheelButtons(); // Update UI only if spins actually changed
                } else {
                     console.log("Daily spins were already 1, no change needed.");
                     saveData(['lastDailySpinReset']); // Still save the reset date
                }
            } else {
                 console.log("Daily spins already reset for today.");
            }
        }


        function dailyCheckIn() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;

             // Check Cooldown
             if (state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours)) {
                 showNotification('You can check in again after the 24-hour cooldown.', 'warning');
                 return;
             }

            // UI feedback
            domElements.dailyCheckInBtn.disabled = true;
            domElements.dailyCheckInBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Checking In...';

            const today = getCurrentDubaiDate(); // Use Dubai date for consistency
            let pointsAwarded = 5; // Base points
            let streakBonusPoints = 0;
            let newWeeklyStreak = false;
            let streakContinued = false;

            // Grant daily spins if they haven't been granted today yet (redundant check, but safe)
            resetDailySpinsIfNeeded(today);

            // Handle Streaks - Compare with lastPlayedDate
            if (state.lastPlayedDate) {
                try {
                    const lastPlayedDateObj = new Date(state.lastPlayedDate);
                    const todayDate = new Date(today);
                    const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                    if (diffDays === 1) {
                        // Consecutive day
                        state.consecutiveDays++;
                        streakBonusPoints = Math.min(state.consecutiveDays, 7); // Cap bonus at +7 for 7+ days
                        streakContinued = true;
                        console.log(`Streak maintained! Day ${state.consecutiveDays}. Bonus: ${streakBonusPoints}`);

                        // Check for weekly streak completion
                        if (state.consecutiveDays > 0 && state.consecutiveDays % 7 === 0) {
                            state.weeklyStreak++;
                            newWeeklyStreak = true;
                            console.log(`Weekly streak completed! Week ${state.weeklyStreak}.`);
                            awardMysteryBox(1, "Weekly Streak");
                        }
                        // Check achievements
                        if (state.consecutiveDays >= 7) checkAndGrantAchievement('7_DAY_STREAK');

                    } else if (diffDays > 1) {
                        // Streak broken
                        console.log("Streak broken, starting new streak at Day 1.");
                        state.consecutiveDays = 1;
                        state.weeklyStreak = 0; // Reset weekly streak
                    } else if (diffDays === 0) {
                        // Checked in again on the same day (should be blocked by cooldown, but handle defensively)
                        console.warn("Already checked in today based on lastPlayedDate.");
                        // Don't award points or change streaks again
                        pointsAwarded = 0;
                    } else {
                        // Time travel or error
                         console.warn(`Unexpected day difference ${diffDays} during check-in. Resetting streak.`);
                         state.consecutiveDays = 1;
                         state.weeklyStreak = 0;
                    }
                } catch (e) {
                    console.error("Error calculating date difference during check-in:", e);
                    state.consecutiveDays = 1; // Reset streak as fallback
                    state.weeklyStreak = 0;
                }

            } else {
                // First check-in ever
                state.consecutiveDays = 1;
                state.weeklyStreak = 0;
                console.log("First check-in, starting streak at Day 1.");
            }

            // Update state if points were awarded
            if (pointsAwarded > 0 || streakBonusPoints > 0) {
                 checkAndGrantAchievement('FIRST_CHECKIN'); // Grant first check-in achievement (idempotent)
                 state.lastPlayedDate = today; // Update the last played date
                 state.lastCheckInTime = now; // Update the cooldown timestamp

                 awardPoints(pointsAwarded + streakBonusPoints, "Daily Check-in"); // Award base + bonus

                 saveData(['lastPlayedDate', 'lastCheckInTime', 'consecutiveDays', 'weeklyStreak', 'points', 'level', 'leaderboard', 'achievements']); // Save all related state

                 let notificationMsg = `Checked in! Day ${state.consecutiveDays}. +${pointsAwarded + streakBonusPoints} $twote!`;
                 if (newWeeklyStreak) notificationMsg += ` Weekly Streak: ${state.weeklyStreak}! +1 Mystery Box!`;
                 else if (streakContinued) notificationMsg += ` Streak bonus: +${streakBonusPoints} $twote!`;
                 showNotification(notificationMsg, 'success');

            } else {
                 // If no points awarded (e.g., duplicate check-in attempt somehow got through)
                 // Still update UI to reflect current state
                 console.log("No points awarded for check-in.");
            }

             updateUI(); // Refresh UI (disables button, starts countdown)
         }


        function awardPoints(amount, reason = "") {
             if (!Number.isInteger(amount) || amount <= 0) return;

             state.points += amount;
             console.log(`Awarded ${amount} points. Reason: ${reason || 'Unknown'}. New total: ${state.points}`);

             // Update leaderboard entry
             ensureUserInLeaderboard(); // Ensures user exists, then updates points

             const previousLevel = state.level;
             updateUserLevel(); // Check for level up

             // Determine keys to save based on changes
             const keysToSave = ['points', 'leaderboard'];
             if (state.level !== previousLevel) {
                 keysToSave.push('level');
             }
             saveData(keysToSave);

             updateUI(); // Update points display everywhere
             showNotification(`+${amount} $twote! âœ¨ (${reason})`, 'success');
         }

        function awardEnergy(amount, reason = "") {
            if (!Number.isInteger(amount) || amount === 0) return;

            const oldEnergy = state.energyLevel;
            state.energyLevel = Math.min(100, Math.max(0, oldEnergy + amount)); // Clamp between 0 and 100

            if (state.energyLevel !== oldEnergy) {
                console.log(`Awarded ${amount} energy. Reason: ${reason}. New total: ${state.energyLevel}%`);
                saveData(['energyLevel']);
                updateUI(); // Update energy display
                const changeText = amount > 0 ? `+${amount}` : `${amount}`;
                showNotification(`${changeText}% Energy!âš¡ï¸ (${reason})`, 'info');
            }
        }

        function updateUserLevel() {
            let currentLevel = state.level;
            let newLevelData = levels[0]; // Default to lowest

            // Find the highest level the user qualifies for
            for (let i = levels.length - 1; i >= 0; i--) {
                if (state.points >= levels[i].points) {
                    newLevelData = levels[i];
                    break;
                }
            }

            if (newLevelData.name !== currentLevel) {
                state.level = newLevelData.name;
                console.log(`Level up! Reached ${state.level}`);
                showNotification(`Congratulations! You've reached Level: ${state.level}! ðŸŽ‰`, 'success');
                // No need to call saveData here, it's handled by awardPoints

                // Check for level-based achievements
                 if (state.level === "Adept") checkAndGrantAchievement('LEVEL_ADEPT');
                 // Add more checks for other levels if needed

                updateUI(); // Update UI immediately
            }
         }

        function checkAndGrantAchievement(achievementKey) {
              if (!achievementsConfig[achievementKey]) {
                  console.warn(`Invalid achievement key: ${achievementKey}`);
                  return;
              }

              if (!state.achievements.includes(achievementKey)) {
                  state.achievements.push(achievementKey);
                  const achievement = achievementsConfig[achievementKey];
                  console.log(`Achievement Unlocked: ${achievement.name}`);
                  showNotification(`Achievement Unlocked: ${achievement.name}! ðŸ…`, 'success');
                  saveData(['achievements']); // Save immediately
                  updateAchievementsUI(); // Update display
              }
          }

        // --- Challenge Logic ---
        function initializeChallenges() {
             // Create base structure for 150 days
             return Array.from({ length: 150 }, (_, i) => {
                 const goalIndex = i % dailyGoals.length; // Cycle through the 7 goals
                 const goalData = dailyGoals[goalIndex];
                 return {
                     day: i + 1,
                     goal: goalData.goal,
                     meditation: goalData.meditation,
                     task1: goalData.task1,
                     task2: goalData.task2,
                     points: goalData.points,
                     completed: false,
                     completionDate: null, // NEW: Store YYYY-MM-DD when completed
                 };
             });
         }

         function getCompletedDaysCount(maxDay) {
            // Count completed challenges up to maxDay
             if (!state.challenges || state.challenges.length === 0) return 0;
             return state.challenges.slice(0, maxDay).filter(ch => ch.completed).length;
         }

        function isChallengeUnlocked(days) {
             // Determines if the *start button* for a challenge duration should be enabled
             switch (days) {
                 case 7: return true; // 7-day is always available
                 case 21: return getCompletedDaysCount(7) === 7; // Need 7 completed
                 case 41: return getCompletedDaysCount(21) === 21; // Need 21 completed
                 // Advanced tiers requiring workshop access
                 case 66: return state.workshopAccess && getCompletedDaysCount(41) === 41;
                 case 150: return state.workshopAccess && getCompletedDaysCount(66) === 66;
                 default: return false;
             }
         }

         function loadChallenges() {
            // Renders the main challenge selection screen (wellnessManager)
            const challengeDurations = [7, 21, 41, 66, 150];
             const challengeIcons = { 7: 'fas fa-sun', 21: 'fas fa-seedling', 41: 'fas fa-star', 66: 'fas fa-moon', 150: 'fas fa-crown' };
             const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
             domElements.challengeOptions.innerHTML = ''; // Clear previous options

             challengeDurations.forEach(days => {
                 const isUnlocked = isChallengeUnlocked(days);
                 const iconClass = challengeIcons[days] || 'fas fa-question-circle';
                 const title = challengeTitles[days] || `${days}-Day`;
                 const requiresWorkshop = days > 41; // Check if workshop access is needed
                 const prevTierDays = days === 21 ? 7 : (days === 41 ? 21 : (days === 66 ? 41 : (days === 150 ? 66 : 0)));
                 const prevTierTitle = challengeTitles[prevTierDays] || `${prevTierDays}-Day`;
                 const prevTierComplete = getCompletedDaysCount(prevTierDays) === prevTierDays;

                 const div = document.createElement('div');
                 div.className = `challenge-div ${isUnlocked ? '' : 'locked'}`; // Apply 'locked' style if not unlocked

                 let content = `<i class="${iconClass} challenge-icon"></i><h3>${days}-Day: ${title}</h3>`;

                 if (isUnlocked) {
                     content += `<button class="btn btn-custom start-challenge-btn mt-2 btn-sm" data-days="${days}">Begin ${title}</button>`;
                 } else {
                     // Detailed locking reasons
                     if (requiresWorkshop && !state.workshopAccess) {
                          // Needs workshop, but user doesn't have access
                          if (!prevTierComplete && prevTierDays > 0) {
                             content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                          } else {
                             // Previous tier is complete, but needs workshop access
                             content += `<p class="warning-text">Requires Workshop Access</p>
                                         <div class="d-flex justify-content-center gap-2 mt-2">
                                            <button class="btn btn-info enroll-btn btn-sm" data-days="${days}">Enroll Info</button>
                                            <button class="btn btn-secondary attended-btn btn-sm" data-days="${days}">Enter Code</button>
                                         </div>`;
                          }
                     } else if (requiresWorkshop && state.workshopAccess) {
                         // Has workshop access, but previous tier isn't complete
                         if (!prevTierComplete && prevTierDays > 0) {
                            content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                         } else {
                            // Should be unlocked if both conditions met, this case is unlikely
                             content += `<p class="warning-text">Locked (Unknown Reason)</p>`;
                         }
                     } else {
                         // Doesn't require workshop, but previous tier isn't complete
                         if (!prevTierComplete && prevTierDays > 0) {
                             content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                         } else {
                             // Should be unlocked if previous tier complete, this case is unlikely
                             content += `<p class="warning-text">Locked (Unknown Reason)</p>`;
                         }
                     }
                 }

                 div.innerHTML = content;
                 domElements.challengeOptions.appendChild(div);
             });
         }

         function displayDailyChallenges(days) {
             // Renders the list of individual days for a selected challenge duration
             if (!days || !domElements.dailyChallengeList) {
                 console.error("Cannot display daily challenges: Duration not set or element missing.");
                 showSection('wellnessManager'); // Go back if state is invalid
                 return;
             }
             const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
             domElements.challengeTitle.textContent = `${days}-Day Challenge: ${challengeTitles[days] || ''}`;
             domElements.dailyChallengeList.innerHTML = ''; // Clear previous list

             const currentDubaiDate = getCurrentDubaiDate();
             let firstUncompletedIndex = -1; // Find first day eligible to be started

             // Determine the first day that can be started
             for(let i = 0; i < days; i++) {
                const challenge = state.challenges[i];
                if (!challenge.completed) {
                    if (i === 0) { // Day 1 is always startable if not complete
                        firstUncompletedIndex = 0;
                        break;
                    } else {
                        // Check if previous day was completed AND today (Dubai) is after completion date
                        const prevChallenge = state.challenges[i-1];
                        if (prevChallenge.completed && prevChallenge.completionDate && currentDubaiDate > prevChallenge.completionDate) {
                            firstUncompletedIndex = i;
                            break;
                        } else {
                            // Previous not complete or not past midnight yet, stop here
                             break;
                        }
                    }
                }
             }
             // If all are complete within the duration 'days'
             if (firstUncompletedIndex === -1 && getCompletedDaysCount(days) === days) {
                 firstUncompletedIndex = days; // Indicate all done
             }


             state.challenges.slice(0, days).forEach((challenge, index) => {
                 const card = document.createElement('div');
                 card.className = 'challenge-div mb-2'; // Base class
                 const isStartable = index === firstUncompletedIndex;

                 let content = `<h4>Day ${challenge.day}: ${challenge.goal}</h4>`;

                 if (challenge.completed) {
                     content += `<p style="color: green; font-weight: bold;"><i class="fas fa-check-circle"></i> Completed (+${challenge.points} $twote)</p>`;
                     card.classList.add('completed'); // Add class for completed styling if needed
                 } else if (isStartable) {
                     content += `<button class="btn btn-custom btn-sm mt-1 start-day-btn" data-day="${challenge.day}">Start Day ${challenge.day}</button>`;
                     card.classList.add('startable'); // Can be started
                 } else {
                     // Determine why it's locked
                     if (index > 0 && !state.challenges[index - 1].completed) {
                         content += `<p class="warning-text" style="font-size: 0.8em;"><i class="fas fa-lock"></i> Complete Day ${challenge.day - 1}</p>`;
                     } else if (index > 0 && state.challenges[index - 1].completionDate && currentDubaiDate <= state.challenges[index - 1].completionDate) {
                          content += `<p class="text-muted" style="font-size: 0.8em;"><i class="fas fa-clock"></i> Unlocks after midnight (Dubai)</p>`;
                     } else {
                          content += `<p class="text-muted" style="font-size: 0.8em;"><i class="fas fa-lock"></i> Locked</p>`; // Fallback locked state
                     }
                     card.classList.add('locked'); // Add general locked class
                 }
                 card.innerHTML = content;
                 domElements.dailyChallengeList.appendChild(card);
             });
         }


        function startChallenge(day) {
            // Opens the energy log modal to begin a challenge day
            const challenge = state.challenges.find(c => c.day === day);
            if (!challenge) {
                console.error(`Challenge data for day ${day} not found.`);
                return;
            }

             // Reset state for the new attempt
             state.currentChallengeDay = day;
             state.energyBefore = null; // Reset energy before starting

             // Configure and show the 'Before' energy log modal
             domElements.energyLogModalTitle.textContent = `Day ${day}: ${challenge.goal} - Before`;
             domElements.energyLogPrompt.textContent = "Log your current energy level (0-100%).";
             domElements.energySlider.value = state.energyLevel; // Default to current energy level
             domElements.energySliderValue.textContent = `${state.energyLevel}%`;
             domElements.challengeTasks.style.display = 'none'; // Hide tasks section initially
             domElements.proofWarning.style.display = 'none'; // Hide proof warning
             domElements.task1Proof.value = ''; // Clear any previous file selection
             domElements.task2Proof.value = '';
             domElements.submitEnergyLog.textContent = 'Confirm Energy & View Tasks';
             domElements.submitEnergyLog.setAttribute('data-stage', 'before');
             domElements.submitEnergyLog.disabled = false; // Enable submission for 'before' stage
             modalInstances.energyLog.show();
         }

        async function submitEnergyLog() {
             // Handles submission from the energy log modal (both 'before' and 'after' stages)
             const sliderValue = parseInt(domElements.energySlider.value);
             const stage = domElements.submitEnergyLog.getAttribute('data-stage');
             const challenge = state.challenges.find(c => c.day === state.currentChallengeDay);

             if (!challenge) {
                 console.error(`Challenge data missing during submit for day ${state.currentChallengeDay}`);
                 modalInstances.energyLog.hide();
                 return;
             }

             // Disable button during processing
             domElements.submitEnergyLog.disabled = true;
             domElements.submitEnergyLog.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';


             if (stage === 'before') {
                 // --- 'Before' Stage: Log initial energy and reveal tasks ---
                 state.energyBefore = sliderValue;
                 console.log(`Energy Before (Day ${state.currentChallengeDay}): ${state.energyBefore}%`);

                 // Update modal for the 'After' stage
                 domElements.energyLogModalTitle.textContent = `Day ${state.currentChallengeDay}: ${challenge.goal} - After`;
                 domElements.energyLogPrompt.textContent = "Complete tasks & log your energy post-challenge.";
                 domElements.challengeTasks.style.display = 'block'; // Show tasks
                 domElements.meditationTask.textContent = challenge.meditation;
                 domElements.task1Text.textContent = challenge.task1;
                 domElements.task2Text.textContent = challenge.task2;
                 domElements.energySlider.value = sliderValue; // Keep slider at 'before' value initially
                 domElements.energySliderValue.textContent = `${sliderValue}%`;
                 domElements.task1Proof.value = ''; // Ensure file inputs are clear
                 domElements.task2Proof.value = '';
                 domElements.submitEnergyLog.textContent = 'Submit Completion';
                 domElements.submitEnergyLog.setAttribute('data-stage', 'after');
                 // Keep button disabled until proof is uploaded
                 domElements.submitEnergyLog.disabled = true;
                 domElements.proofWarning.style.display = 'block'; // Show warning initially

             } else if (stage === 'after') {
                 // --- 'After' Stage: Log final energy, check proof, complete challenge ---
                 const energyAfter = sliderValue;
                 const task1File = domElements.task1Proof.files[0];
                 const task2File = domElements.task2Proof.files[0];

                 // Validate proof
                 if (!task1File || !task2File) {
                     showNotification('Please upload proof for both tasks.', 'warning');
                     domElements.submitEnergyLog.textContent = 'Submit Completion'; // Reset button text
                     domElements.submitEnergyLog.disabled = false; // Re-enable button
                     domElements.proofWarning.style.display = 'block'; // Ensure warning is visible
                     return; // Stop processing
                 }

                 console.log(`Energy After (Day ${state.currentChallengeDay}): ${energyAfter}%`);

                 // --- Simulate Upload & Process Completion ---
                 // In a real app, you'd upload files here and wait for server confirmation
                 await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay

                 try {
                     // Update challenge state
                     challenge.completed = true;
                     challenge.completionDate = getCurrentDubaiDate(); // Record completion date (Dubai)

                     // Add to history
                     state.challengeHistory.push({
                         day: state.currentChallengeDay,
                         goal: challenge.goal,
                         energyBefore: state.energyBefore,
                         energyAfter,
                         task1ProofProvided: !!task1File, // Record that proof was given
                         task2ProofProvided: !!task2File,
                         completionTimestamp: Date.now() // Optional: record exact time
                     });
                     // Limit history size?
                     if (state.challengeHistory.length > 50) {
                         state.challengeHistory = state.challengeHistory.slice(-50);
                     }


                     // Update overall energy level (average of before/after)
                     updateEnergyLevel(state.energyBefore, energyAfter);
                     // Award points for completion
                     awardPoints(challenge.points, `Challenge Day ${state.currentChallengeDay}`);

                     // Check for challenge completion achievements
                     if (state.currentChallengeDuration === 7 && getCompletedDaysCount(7) === 7) {
                         checkAndGrantAchievement('CHALLENGE_7_COMPLETE');
                     }
                     // TODO: Add checks for 21, 41, 66, 150 day completions if relevant achievements exist

                     // Save all affected data
                     saveData(['challenges', 'challengeHistory', 'energyLevel', 'points', 'level', 'leaderboard', 'achievements']);

                     modalInstances.energyLog.hide();
                     showNotification(`Day ${state.currentChallengeDay} completed! ðŸŽ‰`, 'success');
                     displayDailyChallenges(state.currentChallengeDuration); // Refresh the list view

                 } catch (error) {
                     console.error("Error processing challenge completion:", error);
                     showNotification('Error submitting completion. Please try again.', 'error');
                     // Reset button state on error
                     domElements.submitEnergyLog.textContent = 'Submit Completion';
                     domElements.submitEnergyLog.disabled = false; // Allow retry
                 } finally {
                      // Reset temporary state
                      state.currentChallengeDay = null;
                      state.energyBefore = null;
                 }
             }
        }

        function updateEnergyLevel(before, after) {
             // Calculates and updates the main energy level based on before/after log
             if (before !== null && after !== null) {
                const averageEnergy = Math.round((before + after) / 2);
                 // Maybe weigh the 'after' value more? Or just average? Let's average.
                 // Or maybe it should just reflect the 'after' state? Let's just use 'after' for simplicity.
                 // state.energyLevel = Math.min(Math.max(averageEnergy, 0), 100);
                 const oldEnergy = state.energyLevel;
                 const newEnergy = Math.min(Math.max(after, 0), 100); // Use the 'after' value directly, capped
                 if (newEnergy !== oldEnergy) {
                     state.energyLevel = newEnergy;
                     console.log(`Energy level updated to ${state.energyLevel}% after challenge.`);
                     saveData(['energyLevel']); // Save the new energy level
                     updateUI(); // Update display
                 }
             }
         }


        function showEnrollModal(days) {
             // Prepares and shows the workshop enrollment modal
             domElements.enrollName.textContent = state.userName;
             domElements.enrollEnergy.textContent = state.energyLevel;
             const canEnroll = state.energyLevel >= 70;
             domElements.submitEnrollment.disabled = !canEnroll;
             domElements.enrollRequirement.style.display = canEnroll ? 'none' : 'block';
             // Assign the specific enroll action for this button click
             domElements.submitEnrollment.onclick = () => enroll(); // Removed days param, enroll is generic
             modalInstances.enroll.show();
         }

         function enroll() {
             // Handles the workshop enrollment logic (local state change)
             if (state.energyLevel < 70) {
                 showNotification('Energy level must be 70% or higher to enroll!', 'warning');
                 return;
             }
             if (state.workshopAccess) {
                  showNotification('You already have workshop access!', 'info');
                  modalInstances.enroll.hide();
                  return;
             }

             state.workshopAccess = true;
             saveData(['workshopAccess']);
             modalInstances.enroll.hide();
             showNotification(`Enrollment successful! You now have access to advanced challenges.`, 'success');
             loadChallenges(); // Refresh the challenge list to show newly unlocked tiers
         }

         function showCodeModal(days) {
             // Prepares and shows the workshop code entry modal
             domElements.workshopCode.value = '';
             // Assign the specific submit action
             domElements.submitCode.onclick = () => submitCode(); // Removed days param
             modalInstances.code.show();
         }

         function submitCode() {
             // Handles the workshop code submission
             const codeInput = domElements.workshopCode;
             const code = codeInput.value.trim();
             const correctCode = "WELLNESS"; // Example code - MAKE THIS CONFIGURABLE or hide better

             if (!code) {
                 showNotification('Please enter a code.', 'warning');
                 codeInput.focus();
                 return;
             }

             if (code.toUpperCase() === correctCode) {
                 if (state.workshopAccess) {
                    showNotification('You already have workshop access!', 'info');
                 } else {
                    state.workshopAccess = true;
                    saveData(['workshopAccess']);
                    showNotification(`Workshop code accepted! Access granted.`, 'success');
                    loadChallenges(); // Refresh challenges
                 }
                 modalInstances.code.hide();
             } else {
                 showNotification('Invalid workshop code. Please try again.', 'error');
                 codeInput.focus();
                 codeInput.select();
             }
         }

        // --- Game Page Logic (Wheels, Boxes) ---

         function spinWheel(wheelType) {
             if (isSpinning) {
                 showNotification("Spin already in progress...", "warning");
                 return;
             }
             if (!wheelType || !state.wheelSpins[wheelType] || state.wheelSpins[wheelType] <= 0) {
                 showNotification(`No spins available for ${capitalizeFirstLetter(wheelType)} Wheel.`, 'warning');
                 return;
             }

             const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
             if (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours)) {
                 showNotification('Please perform your Daily Check-In first!', 'warning');
                 return;
             }

             isSpinning = true;
             activeWheelType = wheelType;

             // Use the spin
             state.wheelSpins[wheelType]--;
             saveData(['wheelSpins']); // Save immediately after using spin
             updateWheelButtons(); // Update button display

             // Prepare and show the modal
             domElements.wheelModalTitle.textContent = `Spinning the ${capitalizeFirstLetter(wheelType)} Wheel!`;
             domElements.wheelResultDisplay.textContent = "Spinning...";
             domElements.modalWheel.style.transition = 'none'; // Remove transition for reset
             domElements.modalWheel.style.transform = 'rotate(0deg)'; // Reset position
             modalInstances.wheel.show();

             // Force reflow to apply reset before starting animation
             domElements.modalWheel.offsetHeight; // Trigger reflow

             // Calculate target rotation
             const randomSpins = Math.floor(Math.random() * 5) + 5; // 5 to 9 full rotations
             const randomStopAngle = Math.random() * 360; // Random angle within 360
             const targetRotation = (randomSpins * 360) + randomStopAngle;

             // Apply animation
             domElements.modalWheel.style.transition = 'transform 4s cubic-bezier(0.25, 0.1, 0.25, 1)'; // Spin animation
             domElements.modalWheel.style.transform = `rotate(${targetRotation}deg)`;

             // Add event listener for when the transition (spin) ends
             domElements.modalWheel.addEventListener('transitionend', handleSpinEnd, { once: true });
         }

        function handleSpinEnd(event) {
            if (event.propertyName !== 'transform' || !isSpinning) {
                return; // Ignore other transitions or if spin was cancelled
            }

            const wheelElement = event.target;
            const currentTransform = window.getComputedStyle(wheelElement).transform;
            let finalAngle = 0;

            // Extract angle from matrix - More robust than relying on targetRotation directly
             if (currentTransform && currentTransform !== 'none') {
                 const matrixValues = currentTransform.match(/matrix.*\((.+)\)/);
                 if (matrixValues && matrixValues[1]) {
                     const values = matrixValues[1].split(', ');
                     const a = parseFloat(values[0]);
                     const b = parseFloat(values[1]);
                     finalAngle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
                     if (finalAngle < 0) finalAngle += 360; // Ensure angle is 0-359
                 }
             }
            console.log(`Spin ended. Final angle: ${finalAngle.toFixed(2)} degrees`);

            // Determine winning segment (assuming 8 segments, each 45 degrees)
            const segmentAngle = 360 / WHEEL_SEGMENTS;
            const winningSegmentIndex = Math.floor(finalAngle / segmentAngle); // 0 to 7

            console.log(`Winning segment index: ${winningSegmentIndex}`);

            // --- Determine Reward Based on Segment ---
             // Define rewards per segment (index 0-7) - Customize these!
             // Example: More energy, some points, chance of mystery box
             const rewards = [
                 { type: 'energy', value: 10, message: "+10% Energy!" },
                 { type: 'points', value: 5, message: "+5 $twote!" },
                 { type: 'energy', value: 15, message: "+15% Energy!" },
                 { type: 'mystery_box', value: 1, message: "+1 Mystery Box!" },
                 { type: 'energy', value: 5, message: "+5% Energy!" },
                 { type: 'points', value: 10, message: "+10 $twote!" },
                 { type: 'energy', value: 12, message: "+12% Energy!" },
                 { type: 'points', value: 2, message: "+2 $twote!" },
             ];

             const reward = rewards[winningSegmentIndex] || { type: 'energy', value: 5, message: "+5% Energy!" }; // Fallback reward

             // --- Award the Reward ---
             let resultMessage = `Landed on: ${reward.message}`;
             if (reward.type === 'energy') {
                 awardEnergy(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
             } else if (reward.type === 'points') {
                 awardPoints(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
             } else if (reward.type === 'mystery_box') {
                 awardMysteryBox(reward.value, `${capitalizeFirstLetter(activeWheelType)} Wheel`);
             }

             domElements.wheelResultDisplay.textContent = resultMessage;

             // --- Cleanup ---
              // Hide modal after a short delay to show result
              setTimeout(() => {
                 modalInstances.wheel.hide();
                 isSpinning = false;
                 activeWheelType = null;
                 updateUI(); // Full UI update after spin resolves
              }, 1500); // Show result for 1.5 seconds
         }


         function awardMysteryBox(count = 1, reason = "") {
            if (!Number.isInteger(count) || count <= 0) return;
            state.mysteryBoxes += count;
            console.log(`Awarded ${count} Mystery Box(es). Reason: ${reason}. Total: ${state.mysteryBoxes}`);
            saveData(['mysteryBoxes']);
            showNotification(`You received ${count} Mystery Box! ðŸŽ`, 'success');
            updateMysteryBoxUI(); // Update display immediately
         }

         function updateMysteryBoxUI() {
            if (!domElements.mysteryBoxCount || !domElements.openMysteryBoxBtn) return;
            domElements.mysteryBoxCount.textContent = state.mysteryBoxes;
            domElements.openMysteryBoxBtn.disabled = state.mysteryBoxes <= 0;
         }

         function openMysteryBox() {
            if (isSpinning) { // Prevent opening while wheel is spinning
                showNotification("Please wait for the wheel to finish spinning.", "warning");
                return;
            }
            if (state.mysteryBoxes <= 0) {
                showNotification("You don't have any Mystery Boxes to open.", 'warning');
                return;
            }
             domElements.openMysteryBoxBtn.disabled = true; // Disable while opening
             domElements.openMysteryBoxBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Opening...';

             state.mysteryBoxes--;

             // Simulate opening delay
             setTimeout(() => {
                 // Define possible rewards
                 const possibleRewards = [
                     { type: 'points', value: 15, weight: 4 },
                     { type: 'points', value: 25, weight: 3 },
                     { type: 'points', value: 50, weight: 1 },
                     { type: 'spin', wheel: 'referral', value: 1, weight: 2 }, // Referral spin
                     { type: 'energy', value: 10, weight: 3 }, // Energy boost
                     { type: 'energy', value: 20, weight: 1 }, // Larger energy boost
                 ];

                 // Weighted random selection
                 const totalWeight = possibleRewards.reduce((sum, reward) => sum + reward.weight, 0);
                 let random = Math.random() * totalWeight;
                 let reward = possibleRewards[possibleRewards.length - 1]; // Default to last
                 for(const r of possibleRewards) {
                     if (random < r.weight) {
                         reward = r;
                         break;
                     }
                     random -= r.weight;
                 }


                 let message = "You opened a Mystery Box and found ";
                 if (reward.type === 'points') {
                     message += `${reward.value} $twote!`;
                     awardPoints(reward.value, "Mystery Box");
                 } else if (reward.type === 'spin' && wheelTypes.includes(reward.wheel)) {
                      message += `${reward.value} bonus spin for the ${capitalizeFirstLetter(reward.wheel)} wheel!`;
                      state.wheelSpins[reward.wheel] = (state.wheelSpins[reward.wheel] || 0) + reward.value;
                      saveData(['wheelSpins']);
                      updateReferralSpinsUI();
                 } else if (reward.type === 'energy') {
                      message += `a +${reward.value}% Energy boost!`;
                      awardEnergy(reward.value, "Mystery Box"); // Use awardEnergy function
                 }

                 checkAndGrantAchievement('OPEN_MYSTERY_BOX'); // Check achievement
                 saveData(['mysteryBoxes', 'achievements']); // Save box count and potentially achievements
                 showNotification(message, 'success');

                 // Reset button state
                 domElements.openMysteryBoxBtn.innerHTML = 'Open a Box';
                 updateMysteryBoxUI(); // Update count and button state
                 updateUI(); // General UI update for points/energy/spins

             }, 1500); // Simulate opening time
         }


        // --- Profile & History ---

        function loadProfileHistory() {
             if (!domElements.profileHistory) return;
             const recentHistory = state.challengeHistory.slice(-15).reverse(); // Get last 15, newest first

             if (recentHistory.length === 0) {
                 domElements.profileHistory.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No challenge history yet.</td></tr>';
                 return;
             }
             domElements.profileHistory.innerHTML = recentHistory.map(entry => `
                 <tr>
                     <td class="text-center">${entry.day}</td>
                     <td>${escapeHtml(entry.goal)}</td>
                     <td class="text-center">${entry.energyBefore !== null ? entry.energyBefore + '%' : '-'}</td>
                     <td class="text-center">${entry.energyAfter !== null ? entry.energyAfter + '%' : '-'}</td>
                     <td class="text-center">${entry.task1ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                     <td class="text-center">${entry.task2ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                 </tr>
             `).join('');
         }

        function deleteProgress() {
             const confirmationMessage = 'ARE YOU SURE?\n\nThis will delete ALL your progress:\n- Points & Level\n- Challenge Progress & History\n- Streaks & Check-in Times\n- Achievements & Tasks\n- Mystery Boxes & Spins\n\nThis action cannot be undone!';

             // Use Telegram's confirmation popup if available, otherwise browser confirm
             if (window.Telegram?.WebApp?.showConfirm) {
                Telegram.WebApp.showConfirm(confirmationMessage, (confirmed) => {
                    if (confirmed) {
                        performDeletion();
                    } else {
                        console.log("User cancelled deletion (Telegram Confirm).");
                        showNotification("Deletion cancelled.", "info");
                    }
                });
             } else {
                if (confirm(confirmationMessage)) {
                    performDeletion();
                } else {
                    console.log("User cancelled deletion (Browser Confirm).");
                     showNotification("Deletion cancelled.", "info");
                }
             }
        }

        function performDeletion() {
             console.log("User confirmed deletion. Proceeding...");
             // Show loading overlay
             const loadingOverlay = document.createElement('div');
             loadingOverlay.id = 'temp-loading';
             loadingOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 1.2em;';
             loadingOverlay.innerHTML = 'Deleting All Progress...';
             document.body.appendChild(loadingOverlay);

             // Keep user identity
             const userId = state.userId;
             const userName = state.userName;
             const userPhoto = state.userPhoto;

             // --- Clear Local Storage for this user ---
             const keysToRemove = [
                 'energyLevel', 'points', 'level', 'challenges', 'challengeHistory', 'birthdate',
                 'consecutiveDays', 'weeklyStreak', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks',
                 'workshopAccess', 'leaderboard', 'achievements', 'mysteryBoxes', 'wheelSpins', 'lastDailySpinReset'
             ];

             try {
                 keysToRemove.forEach(key => localStorage.removeItem(getStorageKey(key)));
                 console.log("Cleared Local Storage keys for user:", userId);

                // --- Reset State Object ---
                 state = initializeState(); // Get a fresh default state
                 // Restore user identity
                 state.userId = userId;
                 state.userName = userName;
                 state.userPhoto = userPhoto;

                 // --- Re-initialize Leaderboard ---
                 // Important: The saved leaderboard was cleared. Put the user back into the *default* board.
                 state.leaderboard = initializeState().leaderboard; // Get fresh default board
                 ensureUserInLeaderboard(); // Add the user (with 0 points) back

                 // --- Save Essential Resets ---
                 // Save the now-empty/default state back to local storage
                 saveData(['leaderboard', 'level', 'challenges', 'wheelSpins', 'points', 'energyLevel', 'consecutiveDays', 'weeklyStreak', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks', 'workshopAccess', 'achievements', 'mysteryBoxes', 'lastDailySpinReset', 'challengeHistory', 'birthdate']);

                 console.log("Progress deleted and state reset.");
                 showNotification('Your progress has been completely reset.', 'success');

                 // --- Update UI and Navigate ---
                 updateUI(); // Refresh the entire UI
                 loadProfileHistory(); // Clear history table
                 showInitialSection(); // Go back to the beginning (horoscope or wellness)

             } catch (error) {
                 console.error("Error during progress deletion:", error);
                 showNotification('Failed to completely clear data. Please reload.', 'error');
             } finally {
                   // Remove loading overlay
                   loadingOverlay.remove();
             }
         }

        // --- Task Management ---
        function completeTask(taskKey) {
             if (state.completedTasks.includes(taskKey)) {
                 showNotification('You have already completed this task.', 'info');
                 return;
             }
             const button = domElements[`${taskKey}TaskBtn`];
             if (button) {
                 button.disabled = true;
                 button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>'; // Just spinner
             }

             // Simulate verification delay
             setTimeout(() => {
                 if (!state.completedTasks.includes(taskKey)) { // Double check before awarding
                    state.completedTasks.push(taskKey);
                    saveData(['completedTasks']);
                    awardPoints(10, `Task: ${capitalizeFirstLetter(taskKey)}`); // This saves points/level/leaderboard

                    showNotification(`Task '${capitalizeFirstLetter(taskKey)}' completed! +10 $twote`, 'success');
                    updateTaskButtons(); // Update button state
                 } else {
                    // If somehow completed during the timeout
                     console.warn(`Task ${taskKey} was already completed before timeout finished.`);
                      updateTaskButtons(); // Ensure button state is correct
                 }
             }, 1500); // 1.5 second delay
        }


        // --- Referral Simulation ---
        function simulateReferralCompletion() {
            // DEV ONLY - Placeholder for actual backend-driven referral logic
            console.log("Simulating referral completion...");
            awardPoints(20, "Referral Bonus (Simulated)"); // Award points to referrer

            // Award bonus referral spins
            const referralSpinsAwarded = 3;
            state.wheelSpins.referral = (state.wheelSpins.referral || 0) + referralSpinsAwarded;

            checkAndGrantAchievement('FIRST_REFERRAL'); // Grant achievement (idempotent)

            saveData(['points', 'level', 'leaderboard', 'wheelSpins', 'achievements']); // Save all affected state

            showNotification(`Referral simulation complete! +20 $twote & +${referralSpinsAwarded} Referral Spins!`, 'success');
            updateUI(); // Update points and spin counts
        }


        function copyReferralLink() {
             const referralLinkInput = domElements.referralLink;
             if (!referralLinkInput || !referralLinkInput.value || referralLinkInput.value === "Link unavailable") {
                 showNotification('Referral link not available.', 'warning');
                 return;
             }
             // Use Telegram's clipboard API if available, otherwise navigator
             if (window.Telegram?.WebApp?.clipboard?.writeText) {
                 Telegram.WebApp.clipboard.writeText(referralLinkInput.value, (success) => {
                     if (success) {
                         showNotification('Referral link copied! (via Telegram)', 'success');
                     } else {
                         // Fallback to navigator.clipboard
                         copyUsingNavigator(referralLinkInput.value);
                     }
                 });
             } else {
                 copyUsingNavigator(referralLinkInput.value);
             }
         }

         function copyUsingNavigator(text) {
             navigator.clipboard.writeText(text)
                 .then(() => {
                     showNotification('Referral link copied to clipboard!', 'success');
                 })
                 .catch(err => {
                     console.error('Failed to copy referral link using navigator: ', err);
                     showNotification('Could not copy link automatically. Please copy manually.', 'error');
                     // Select the text for manual copying
                     domElements.referralLink.select();
                     domElements.referralLink.setSelectionRange(0, 99999); // For mobile
                 });
         }

        // --- Event Listeners Setup ---
         function setupEventListeners() {
             console.log("Setting up event listeners...");

             // Header Profile Link
             domElements.profileLink?.addEventListener('click', () => showSection('playerProfile'));

             // Initial Setup
             domElements.saveHoroscopeBtn?.addEventListener('click', saveHoroscope);

             // Footer Navigation
             domElements.navHome?.addEventListener('click', (e) => { e.preventDefault(); showSection('wellnessManager'); });
             domElements.navTasks?.addEventListener('click', (e) => { e.preventDefault(); showSection('tasksSection'); });
             domElements.navGame?.addEventListener('click', (e) => { e.preventDefault(); showSection('gamePage'); });
             domElements.navProfile?.addEventListener('click', (e) => { e.preventDefault(); showSection('playerProfile'); });

             // Wellness Manager (Challenge Selection) - Event Delegation
             domElements.challengeOptions?.addEventListener('click', (event) => {
                 const target = event.target.closest('button'); // Find closest button clicked
                 if (!target) return;

                 const days = parseInt(target.getAttribute('data-days'));
                 if (target.classList.contains('start-challenge-btn')) {
                     state.currentChallengeDuration = days; // Set duration before showing
                     saveData(['currentChallengeDuration']); // Save selected duration? Optional.
                     showSection('dailyChallenges');
                 } else if (target.classList.contains('enroll-btn')) {
                     showEnrollModal(days);
                 } else if (target.classList.contains('attended-btn')) {
                     showCodeModal(days);
                 }
             });

             // Daily Challenge List (Start Day) - Event Delegation
             domElements.dailyChallengeList?.addEventListener('click', (event) => {
                 const target = event.target.closest('button.start-day-btn');
                 if (target) {
                     const day = parseInt(target.getAttribute('data-day'));
                     startChallenge(day);
                 }
             });

             // Energy Log Modal
             domElements.energySlider?.addEventListener('input', () => {
                 domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`;
             });
             domElements.submitEnergyLog?.addEventListener('click', submitEnergyLog);
              // Enable submit button in 'after' stage only when both proofs are selected
             [domElements.task1Proof, domElements.task2Proof].forEach(input => {
                 input?.addEventListener('change', () => {
                     if (domElements.submitEnergyLog.getAttribute('data-stage') === 'after') {
                         const task1File = domElements.task1Proof.files[0];
                         const task2File = domElements.task2Proof.files[0];
                         const bothFiles = task1File && task2File;
                         domElements.submitEnergyLog.disabled = !bothFiles;
                         domElements.proofWarning.style.display = bothFiles ? 'none' : 'block';
                     }
                 });
             });


             // Game Page Buttons
             domElements.dailyCheckInBtn?.addEventListener('click', dailyCheckIn);
             domElements.openMysteryBoxBtn?.addEventListener('click', openMysteryBox);
             domElements.claimReferralRewardBtn?.addEventListener('click', simulateReferralCompletion); // Dev button

             // Wheel Buttons (using data attributes and delegation)
              const wheelGrid = document.querySelector('.wheel-button-grid'); // Use querySelector for class
              wheelGrid?.addEventListener('click', (event) => {
                  const button = event.target.closest('button.wheel-button');
                  if (button && button.dataset.wheel && !button.disabled) {
                      spinWheel(button.dataset.wheel);
                  }
              });

             // Profile Page Buttons
             domElements.deleteProgressBtn?.addEventListener('click', deleteProgress);
             domElements.connectWalletBtn?.addEventListener('click', () => showNotification('Wallet connection feature coming soon!', 'info'));
             domElements.airdropWithdrawBtn?.addEventListener('click', () => showNotification('Airdrop withdrawal feature coming soon!', 'info'));

             console.log("Event listeners setup complete.");
         }


    </script>
</body>
</html>
