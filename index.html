<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Third Eye</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #4E342E;
            --text-color: #FFF8E1;
            --button-color: #FFD700;
            --button-text-color: #3E2723;
            --wellness-manager-color: #3E2723; /* Dark brown */
            --warning-color: #8B0000; /* Deep red */
            --challenge-description-color: #3E2723; /* Dark brown for challenge descriptions */
        }
        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            padding-bottom: 70px;
        }
        #backgroundVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }
        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 15px;
        }
        .section {
            background: rgba(255, 248, 220, 0.1);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .challenge-div {
            background: #fff;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: var(--challenge-description-color); /* Dark brown for challenge descriptions */
        }
         .challenge-div h3 {
             color: var(--challenge-description-color);
             margin-bottom: 10px;
         }
        .challenge-div p {
             color: var(--challenge-description-color);
        }
         .challenge-div .warning-text {
            color: var(--warning-color);
        }
        .challenge-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        .challenge-div .challenge-icon {
            color: var(--challenge-description-color); /* Dark brown for icons in challenge divs */
        }
        .modal-content {
            background: var(--bg-color);
            color: var(--text-color);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .btn-custom {
            background-color: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-custom:hover, .btn-custom:active, .btn-custom:focus {
            transform: scale(1.05);
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -4px -4px 8px rgba(255, 255, 255, 0.3);
            color: var(--button-text-color);
            background-color: var(--button-color);
        }
        .btn-danger {
            background-color: var(--warning-color); /* Deep red for warnings */
            color: #fff;
            border: none;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2);
        }
        .btn-danger:hover, .btn-danger:active, .btn-danger:focus {
            transform: scale(1.05);
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -4px -4px 8px rgba(255, 255, 255, 0.3);
            color: #fff;
        }
        .locked {
            opacity: 0.6; /* Increased opacity slightly */
        }
        canvas {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }
        header img[src="logo.webp"] {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #profilePhoto {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
        }
        h1, h2, h4, body > .container > p {
            color: var(--text-color);
        }
        #wellnessManager h2 { /* Style Wellness H2 specifically */
             color: var(--text-color);
             text-align: center;
             margin-bottom: 20px;
        }
         #dailyChallenges h2 { /* Style Daily Chal H2 specifically */
             color: var(--text-color);
              text-align: center;
             margin-bottom: 20px;
         }
          #tasksSection h2 { /* Style Tasks H2 specifically */
             color: var(--text-color);
             text-align: center;
             margin-bottom: 20px;
         }
         #gamePage h2 { /* Style Game H2 specifically */
             color: var(--text-color);
              text-align: center;
             margin-bottom: 20px;
         }
         #horoscopeWheelPage h2 { /* Style Wheel H2 specifically */
             color: var(--text-color);
             text-align: center;
             margin-bottom: 15px;
         }
         #numerologyPathPage h2 { /* Style Num H2 specifically */
             color: var(--text-color);
             text-align: center;
             margin-bottom: 15px;
         }
         #playerProfile h2 { /* Style Profile H2 specifically */
             color: var(--text-color);
             text-align: center;
             margin-bottom: 20px;
         }
         h3 { /* Default H3 to text color unless overridden (like in challenge-div) */
             color: var(--text-color);
         }

        .warning-text {
            color: var(--warning-color); /* Deep red for warnings */
            font-weight: bold;
        }
        .footer-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(78, 52, 46, 0.8); /* Slightly transparent bg */
            padding: 10px 0; /* Reduced padding */
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px); /* Added blur */
        }
        .footer-nav a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 14px; /* Slightly smaller */
            text-align: center;
            transition: transform 0.2s;
            flex: 1; /* Make items take equal space */
            padding: 5px 0;
        }
        .footer-nav a:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 0.1); /* Subtle hover */
            border-radius: 5px;
        }
        .footer-nav a i {
            display: block;
            font-size: 20px; /* Slightly smaller */
            margin-bottom: 3px; /* Reduced margin */
        }
        .task-icon {
            font-size: 1.75em;
            margin-right: 10px;
            color: var(--text-color);
        }
        #socialMediaTasks ul {
            list-style-type: none;
            padding: 0;
        }
        #socialMediaTasks li {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Align button to the right */
            margin-bottom: 15px; /* Reduced margin */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
         #socialMediaTasks li > div { /* Wrap text/icon */
             display: flex;
             align-items: center;
             margin-right: 10px; /* Space between text and button */
             margin-bottom: 5px; /* Space if button wraps */
         }
        #socialMediaTasks a {
            color: var(--text-color);
            text-decoration: underline; /* Make link clearer */
            margin-left: 5px; /* Space after text */
        }
        #socialMediaTasks a:hover {
            text-decoration: none;
        }
         #socialMediaTasks button {
             padding: 5px 10px; /* Smaller buttons */
             font-size: 0.9em;
         }

        /* Referral Task Layout */
        #referralTask {
            margin-top: 20px;
        }
        #referralTask p {
             margin-bottom: 10px;
         }
         #referralTask input[type="text"] {
             width: calc(100% - 110px); /* Adjust width to fit button */
             margin-right: 10px;
             background-color: rgba(255, 255, 255, 0.1);
             border: 1px solid rgba(255, 255, 255, 0.3);
             color: var(--text-color);
             padding: 8px;
             border-radius: 5px;
         }
         #referralTask button {
             width: 100px; /* Fixed width for copy button */
         }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 0 10px; }
            .section { padding: 20px; margin-bottom: 15px;} /* Adjusted padding/margin */
            .challenge-div { padding: 12px; }
            .challenge-icon { font-size: 2em; }
            .btn-custom {
                /* width: 100%; Don't make all buttons full width */
                margin-bottom: 10px; /* Reduced margin */
                padding: 10px 15px; /* Adjusted padding */
            }
            h1 { font-size: 1.6rem; }
             h2 { font-size: 1.4rem; }
             h3 { font-size: 1.2rem; }
            .challenge-div h3 { font-size: 1.2rem; }
            p { font-size: 0.95rem; }
            .warning-text { font-size: 0.9rem; }
            #socialMediaTasks button { /* Ensure task buttons fit */
                 width: auto; /* Allow button to size naturally */
                 margin-left: auto; /* Push button right if space allows */
            }
             #referralTask input[type="text"] {
                 width: calc(100% - 100px); /* Adjust for smaller screens */
             }
             #referralTask button {
                 width: 90px;
             }
        }
        @media (max-width: 576px) {
            .footer-nav a { font-size: 12px; } /* Even smaller footer text */
            .footer-nav a i { font-size: 18px; } /* Smaller footer icons */
            h1 { font-size: 1.4rem; }
             h2 { font-size: 1.2rem; }
             h3 { font-size: 1.1rem; }
             .challenge-div h3 { font-size: 1.1rem; }
            p { font-size: 0.875rem; }
            .challenge-icon { font-size: 1.75em; }
             #socialMediaTasks li { flex-direction: column; align-items: flex-start;} /* Stack task items */
             #socialMediaTasks li > div { margin-bottom: 8px; }
             #socialMediaTasks button { width: 100%; margin-top: 5px; } /* Full width task buttons */
             #referralTask { display: flex; flex-direction: column; }
             #referralTask input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px;}
             #referralTask button { width: 100%; }
             header { flex-direction: column; text-align: center;} /* Stack header on small screens */
             header > div:last-child { margin-top: 10px; } /* Add space below logo/title */

        }

         /* Loading Indicator Style (in case you re-add it) */
         #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; justify-content: center;
            align-items: center; z-index: 9999; flex-direction: column;
            color: white;
         }
         .spinner-border { color: white; } /* Bootstrap spinner */

        /* Table styling */
        .table {
            color: var(--text-color); /* Light text for table content */
            background-color: rgba(0, 0, 0, 0.2); /* Darker translucent background */
            border-radius: 10px; /* Rounded corners */
            overflow: hidden; /* Ensure contents respect border radius */
            margin-top: 15px;
             border-collapse: separate; /* Needed for border-radius on table */
             border-spacing: 0;
        }
         .table th, .table td {
            border-top: 1px solid rgba(255, 255, 255, 0.2); /* Lighter border between rows */
            padding: 0.6rem 0.5rem; /* Adjust padding */
            vertical-align: middle;
         }
        .table thead th {
             color: var(--button-color); /* Gold color for headers */
             background-color: rgba(0, 0, 0, 0.4); /* Even darker header background */
             border-top: none; /* Remove top border from header cells */
             border-bottom: 2px solid var(--button-color);
             font-weight: bold; /* Make header text bold */
         }
        .table tbody tr:first-child td {
             border-top: none; /* Remove top border from first row body cells */
         }
        .table tbody tr:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Highlight on hover */
        }
         .table img {
             max-width: 40px; /* Smaller images in table */
             height: auto;
             border-radius: 4px;
         }
         .table-primary td, /* Target cells for background */
         .table tr.table-primary td { /* More specific selector */
             background-color: rgba(var(--bs-primary-rgb, 13, 110, 253), 0.2) !important; /* Adjust alpha for subtle highlight */
         }
         .table .table-primary { /* Ensure the row itself keeps its specific style */
            font-weight: bold;
         }
         .table-responsive {
             border-radius: 10px; /* Apply radius to the responsive wrapper */
         }
         .table-sm th, .table-sm td {
            padding: 0.4rem 0.4rem; /* Smaller padding for compact tables */
         }

         /* Modal Styling Enhancements */
        .modal-header, .modal-footer {
            border: none; /* Remove default borders */
        }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%); } /* Ensure close button is visible */
        .form-range::-webkit-slider-thumb { background-color: var(--button-color); }
        .form-range::-moz-range-thumb { background-color: var(--button-color); }


    </style>
</head>
<body>
    <video id="backgroundVideo" autoplay muted loop playsinline> <!-- Added playsinline -->
        <source src="cosmic.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <!-- Loading element removed -->

    <div class="container">
        <header class="d-flex justify-content-between align-items-center py-3">
            <div class="d-flex align-items-center">
                <img src="logo.webp" alt="Logo">
                <h1 style="margin: 0; font-size: 1.8rem;">Third Eye</h1> <!-- Adjusted size -->
            </div>
            <div class="d-flex align-items-center flex-column text-center" id="profileLink"> <!-- Added text-center -->
                <img id="profilePhoto" src="https://via.placeholder.com/40" alt="Profile">
                <span id="profileNameDisplay" style="margin-top: 5px; font-size: 0.9rem; line-height: 1.1;">Guest</span> <!-- Adjusted font/line-height -->
                <span id="pointsDisplay" style="font-size: 0.9rem; color: var(--button-color); font-weight: bold;">0 $twote</span> <!-- Made points stand out -->
            </div>
        </header>

        <!-- Sections remain the same structure -->
        <div id="horoscopeForm" class="section" style="display: none;">
            <h2>Enter Your Birthdate</h2>
            <p>To personalize your journey.</p>
            <input type="date" id="birthdate" class="form-control mb-2">
            <button class="btn btn-custom w-100" id="saveHoroscopeBtn">Save & Continue</button>
        </div>

        <div id="wellnessManager" class="section" style="display: none;">
            <h2>Mindfulness Journey</h2> <!-- Changed title/color -->
            <p style="text-align: center;">Select a challenge duration to begin.</p>
            <div id="challengeOptions" class="mt-3"></div> <!-- Added margin-top -->
        </div>

        <div id="dailyChallenges" class="section" style="display: none;">
            <h2 id="challengeTitle">Challenge</h2>
            <div id="dailyChallengeList"></div>
        </div>

        <div id="tasksSection" class="section" style="display: none;">
            <h2>Earn More $twote</h2>
             <div id="socialMediaTasks">
                 <h3 style="color: var(--text-color); border-bottom: 1px solid var(--button-color); padding-bottom: 5px; margin-bottom: 15px;">Social Tasks</h3>
                 <ul>
                     <li>
                         <div><i class="fab fa-telegram-plane task-icon"></i>Join <a href="https://t.me/ThirdEyeCommunity" target="_blank">Telegram</a></div>
                         <button class="btn btn-custom" id="telegramTaskBtn" onclick="completeTask('telegram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-twitter task-icon"></i>Follow <a href="https://twitter.com/ThirdEyeApp" target="_blank">Twitter</a></div>
                         <button class="btn btn-custom" id="twitterTaskBtn" onclick="completeTask('twitter')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-instagram task-icon"></i>Follow <a href="https://instagram.com/ThirdEyeApp" target="_blank">Instagram</a></div>
                         <button class="btn btn-custom" id="instagramTaskBtn" onclick="completeTask('instagram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-youtube task-icon"></i>Subscribe <a href="https://youtube.com/@ThirdEyeChannel" target="_blank">YouTube</a></div>
                         <button class="btn btn-custom" id="youtubeTaskBtn" onclick="completeTask('youtube')">Verify</button>
                     </li>
                 </ul>
             </div>
             <div id="referralTask" class="mt-4"> <!-- Added margin-top -->
                 <h3 style="color: var(--text-color); border-bottom: 1px solid var(--button-color); padding-bottom: 5px; margin-bottom: 15px;">Referral Task</h3>
                 <p>Share your link! Both you and your friend earn $twote.</p>
                 <div class="d-flex">
                     <input type="text" id="referralLink" class="form-control" readonly style="flex-grow: 1; margin-right: 10px;">
                     <button class="btn btn-custom" onclick="copyReferralLink()">Copy</button>
                 </div>
             </div>
        </div>

        <div id="gamePage" class="section" style="display: none;">
            <h2>Daily Activities</h2>
            <div class="text-center mb-3">
                <button class="btn btn-custom" id="dailyCheckInBtn">Daily Check-In</button>
                <p id="countdownDisplay" style="color: var(--button-color); margin-top: 10px; font-size: 0.9em;"></p>
            </div>
            <div class="d-grid gap-2"> <!-- Use grid for button layout -->
                <button class="btn btn-custom" id="playHoroscopeWheel">ðŸ“Š Play Horoscope Wheel</button>
                <button class="btn btn-custom" id="playNumerologyPath">ðŸ”¢ Play Numerology Path</button>
            </div>
        </div>

        <div id="horoscopeWheelPage" class="section" style="display: none;">
            <h2>Horoscope Wheel</h2>
            <canvas id="astrologyWheelCanvas" width="300" height="300"></canvas> <!-- Slightly smaller canvas -->
            <p id="astrologyMessage" class="text-center mt-3" style="min-height: 40px;"></p> <!-- Added min-height -->
            <div class="text-center mt-3">
                 <button class="btn btn-custom" id="spinWheel">Spin the Wheel</button>
            </div>
        </div>

        <div id="numerologyPathPage" class="section" style="display: none;">
            <h2>Numerology Path</h2>
            <p id="numerologyMessage" class="text-center" style="min-height: 40px;">Select a number to reveal your path!</p>
            <div id="numberGrid" class="text-center mt-3"></div>
        </div>

        <div id="playerProfile" class="section" style="display: none;">
            <h2>Player Profile</h2>
            <div class="text-center mb-3">
                <p>Welcome, <strong id="profileNameDisplayInner" style="color: var(--button-color);">Guest</strong>!</p>
                <div id="energyLevel">Energy Level: <span id="energyValue" style="color: var(--button-color); font-weight:bold;">0</span>%</div>
                <div id="pointsProfileDisplay">Points: <span id="pointsValue" style="color: var(--button-color); font-weight:bold;">0</span> $twote</div>
                <div id="consecutiveDaysDisplay">Consecutive Days: <span id="consecutiveDaysValue" style="color: var(--button-color); font-weight:bold;">0</span></div>
            </div>
             <div class="d-grid gap-2 mb-4">
                 <button class="btn btn-custom" id="connectWalletBtn">Connect Wallet (Soon)</button>
                 <button class="btn btn-custom" id="airdropWithdrawBtn">Withdraw $twote (Soon)</button>
             </div>

            <h3 class="mt-4" style="color: var(--text-color);">Challenge History</h3>
            <div class="table-responsive"> <!-- Make table scrollable on small screens -->
                <table class="table table-sm"> <!-- Added table-sm for compactness -->
                    <thead><tr><th>Day</th><th>Goal</th><th>NRG In</th><th>NRG Out</th><th>T1 Proof</th><th>T2 Proof</th></tr></thead>
                    <tbody id="profileHistory"></tbody>
                </table>
            </div>

            <h3 class="mt-4" style="color: var(--text-color);">Leaderboard (Top 100)</h3>
             <div class="table-responsive">
                 <table class="table table-sm">
                     <thead><tr><th>Rank</th><th>Name</th><th>Points ($twote)</th></tr></thead>
                     <tbody id="leaderboard"></tbody>
                 </table>
             </div>
             <div class="text-center mt-4">
                 <button class="btn btn-danger mt-3" id="deleteProgressBtn">Delete Progress</button>
             </div>
        </div>
    </div>

    <nav class="footer-nav">
        <a href="#" id="navHome"><i class="fas fa-home"></i>Journey</a>
        <a href="#" id="navTasks"><i class="fas fa-tasks"></i>Tasks</a>
        <a href="#" id="navGame"><i class="fas fa-dice"></i>Activity</a> <!-- Changed icon/name -->
        <a href="#" id="navProfile"><i class="fas fa-user-astronaut"></i>Profile</a> <!-- Added Profile Link -->
    </nav>

    <!-- Modals remain the same structure but ensure text contrast -->
    <div class="modal fade" id="energyLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered"> <!-- Centered modal -->
            <div class="modal-content">
                <div class="modal-header"> <!-- Removed border -->
                    <h5 class="modal-title" id="energyLogModalTitle">Energy Log</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> <!-- White close button -->
                </div>
                <div class="modal-body">
                    <p id="energyLogPrompt">How positive is your mind frame?</p>
                    <div class="d-flex align-items-center my-3">
                         <input type="range" min="0" max="100" value="50" class="form-range flex-grow-1 me-3" id="energySlider">
                         <span id="energySliderValue" style="color: var(--button-color); font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                    </div>
                    <div id="challengeTasks" style="display: none; margin-top: 20px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;">
                        <p class="mb-2"><strong>Meditation:</strong> <span id="meditationTask" style="font-style: italic;"></span></p>
                        <p class="mb-1"><strong>Task 1:</strong> <span id="task1Text"></span></p>
                        <input type="file" id="task1Proof" class="form-control form-control-sm mb-2" accept="image/*">
                        <p class="mb-1"><strong>Task 2:</strong> <span id="task2Text"></span></p>
                        <input type="file" id="task2Proof" class="form-control form-control-sm" accept="image/*">
                        <p class="mt-3 text-center warning-text" id="proofWarning" style="display: none; font-size: 0.9em;">Please upload proof for both tasks.</p>
                    </div>
                </div>
                <div class="modal-footer justify-content-center"> <!-- Centered footer button -->
                    <button class="btn btn-custom w-50" id="submitEnergyLog" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="enrollModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enroll in Workshop</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center"> <!-- Centered text -->
                     <p><strong>Name:</strong> <span id="enrollName"></span></p>
                     <p><strong>Horoscope:</strong> <span id="enrollHoroscope"></span></p>
                     <p><strong>Energy Level:</strong> <span id="enrollEnergy" style="color: var(--button-color); font-weight: bold;"></span>%</p>
                     <p id="enrollRequirement" class="warning-text" style="font-size: 0.9em; display: none;">Requires 70% Energy</p>
                     <button class="btn btn-custom mt-3 w-50" id="submitEnrollment" disabled>Submit Enrollment</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="codeModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title">Enter Workshop Code</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body">
                     <input type="text" id="workshopCode" class="form-control mb-3" placeholder="Enter code">
                      <div class="text-center">
                          <button class="btn btn-custom w-50" id="submitCode">Submit</button>
                      </div>
                 </div>
             </div>
         </div>
     </div>

    <!-- Toast Container for Notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100"></div> <!-- Ensure toast is above footer -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script>
        // Constants remain the same
        const dailyGoals = [
            { goal: "Wealth", meditation: "Visualize wealth.", task1: "Write 3 financial goals.", task2: "Plan a budget.", points: 5 },
            { goal: "Peace", meditation: "Reflect on peace.", task1: "5-min gratitude.", task2: "5-min breathing.", points: 5 },
            { goal: "Focus", meditation: "Focus your mind.", task1: "List 3 priorities.", task2: "Organize workspace.", points: 5 },
            { goal: "Creativity", meditation: "Boost creativity.", task1: "Brainstorm 5 ideas.", task2: "Draw something.", points: 5 },
            { goal: "Confidence", meditation: "Build confidence.", task1: "Write 3 positives.", task2: "Power pose 2 min.", points: 5 },
            { goal: "Energy", meditation: "Energize yourself.", task1: "Visualize energy.", task2: "5-min stretch.", points: 5 },
            { goal: "Gratitude", meditation: "Cultivate gratitude.", task1: "Write 3 thanks.", task2: "Send a thank-you.", points: 5 }
        ];
        const zodiacOrder = [
            { sign: "Aries", symbol: "â™ˆ", points: 5 }, { sign: "Taurus", symbol: "â™‰", points: 4 }, { sign: "Gemini", symbol: "â™Š", points: 3 },
            { sign: "Cancer", symbol: "â™‹", points: 2 }, { sign: "Leo", symbol: "â™Œ", points: 5 }, { sign: "Virgo", symbol: "â™", points: 4 },
            { sign: "Libra", symbol: "â™Ž", points: 3 }, { sign: "Scorpio", symbol: "â™", points: 2 }, { sign: "Sagittarius", symbol: "â™", points: 5 },
            { sign: "Capricorn", symbol: "â™‘", points: 4 }, { sign: "Aquarius", symbol: "â™’", points: 3 }, { sign: "Pisces", symbol: "â™“", points: 2 }
        ];
        const astrologyInsights = {
            "Aries": "Bold actions today.", "Taurus": "Stability brings peace.", "Gemini": "Communication opens.",
            "Cancer": "Emotions guide.", "Leo": "Shine bright.", "Virgo": "Details matter.",
            "Libra": "Balance harmonizes.", "Scorpio": "Transformation nears.", "Sagittarius": "Adventure calls.",
            "Capricorn": "Work pays.", "Aquarius": "Innovation changes.", "Pisces": "Imagination fuels."
        };
        const numerologyInsights = {
            1: "Leadership awaits you.", 2: "Harmony brings success.", 3: "Creativity flows freely.",
            4: "Stability builds future.", 5: "Change inspires growth.", 6: "Love guides decisions.",
            7: "Wisdom shapes path.", 8: "Power drives ambition.", 9: "Completion nears now."
        };
        const sections = ['horoscopeForm', 'wellnessManager', 'dailyChallenges', 'tasksSection', 'gamePage', 'horoscopeWheelPage', 'numerologyPathPage', 'playerProfile'];

        let state = {};
        let sectionStack = ['wellnessManager']; // Start with a default section in stack
        let domElements = {}; // Keep it global within the script scope
        let energyLogModalInstance = null;
        let enrollModalInstance = null;
        let codeModalInstance = null;


        function getDomElements() {
            // Consolidate DOM element fetching
            const ids = [
                'profilePhoto', 'profileNameDisplay', 'profileNameDisplayInner', 'pointsDisplay',
                'pointsValue', 'consecutiveDaysValue', 'energyValue', 'challengeOptions',
                'dailyChallengeList', 'challengeTitle', 'energyLogPrompt', 'energySlider',
                'energySliderValue', 'challengeTasks', 'meditationTask', 'task1Text',
                'task2Text', 'task1Proof', 'task2Proof', 'submitEnergyLog', 'profileHistory',
                'astrologyMessage', 'numerologyMessage', 'numberGrid', 'referralLink',
                'dailyCheckInBtn', 'countdownDisplay', 'leaderboard', 'enrollName',
                'enrollHoroscope', 'enrollEnergy', 'submitEnrollment', 'workshopCode',
                'submitCode', /*'loading', */'proofWarning', 'enrollRequirement', 'energyLogModal',
                'enrollModal', 'codeModal'
            ]; // Removed loading ID
            const elements = {};
            ids.forEach(id => elements[id] = document.getElementById(id));
            return elements;
        }

        document.addEventListener('DOMContentLoaded', () => {
            domElements = getDomElements(); // Fetch elements once
            energyLogModalInstance = new bootstrap.Modal(domElements.energyLogModal);
            enrollModalInstance = new bootstrap.Modal(domElements.enrollModal);
            codeModalInstance = new bootstrap.Modal(domElements.codeModal);


            function initializeState() {
                // Default state
                 const defaultLeaderboard = [
                     { userId: 'bot1', name: 'Cosmic Guide', points: 150 },
                     { userId: 'bot2', name: 'Zen Master', points: 120 },
                     { userId: 'bot3', name: 'Astro Explorer', points: 110 },
                     // Add more dummy entries if needed
                 ];
                return {
                    userId: null,
                    userName: "Guest",
                    userPhoto: "https://via.placeholder.com/40",
                    energyLevel: 0,
                    points: 0,
                    challenges: [],
                    challengeHistory: [],
                    birthdate: null,
                    consecutiveDays: 0,
                    lastPlayedDate: null, // Tracks date for streak
                    lastCheckInTime: null, // Tracks exact timestamp for 24h cooldown
                    completedTasks: [], // Track completed one-time tasks
                    workshopAccess: false,
                    currentChallengeDuration: null, // Track which challenge (7, 21 etc.) is active
                    currentChallengeDay: null, // Track the specific day being worked on
                    energyBefore: null, // Temp storage during energy log
                    leaderboard: defaultLeaderboard, // Start with defaults
                    isLoading: true // Track loading state
                };
            }

            function showNotification(message, type = 'info') { // Added type for styling
                const toast = document.createElement('div');
                toast.className = `toast align-items-center text-bg-${type === 'error' ? 'danger' : 'primary'} border-0`; // Use Bootstrap background colors
                toast.setAttribute('role', 'alert');
                toast.setAttribute('aria-live', 'assertive');
                toast.setAttribute('aria-atomic', 'true');
                toast.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                `;
                document.querySelector('.toast-container').appendChild(toast);
                const bsToast = new bootstrap.Toast(toast, { delay: 3000 }); // Auto-hide after 3 seconds
                bsToast.show();
                // Clean up the toast element after it's hidden
                 toast.addEventListener('hidden.bs.toast', () => {
                    toast.remove();
                });
            }


            function initializeApp() {
                 console.log("Initializing App...");
                 // domElements.loading.style.display = 'flex'; // Loading element removed
                 state = initializeState(); // Reset state initially

                 if (window.Telegram?.WebApp) {
                     Telegram.WebApp.ready();
                     Telegram.WebApp.expand(); // Ensure app is expanded
                     const user = Telegram.WebApp.initDataUnsafe?.user;
                     if (user) {
                         console.log("Telegram User Data:", user);
                         state.userId = user.id.toString(); // Ensure userId is string for consistency
                         state.userName = user.first_name || "User";
                         state.userPhoto = user.photo_url || domElements.profilePhoto.src; // Use default if no photo
                     } else {
                         console.warn("Telegram user data not found.");
                         // Generate a simple local ID for non-TG users for testing
                         state.userId = `local_${Date.now()}`;
                     }
                     setTheme();
                     initCloudStorage(); // Use Cloud Storage
                 } else {
                     console.warn("Telegram WebApp not available. Using local storage.");
                     // Generate a simple local ID for non-TG users for testing
                      state.userId = localStorage.getItem('userId') || `local_${Date.now()}`;
                     localStorage.setItem('userId', state.userId); // Save generated ID
                     initLocalStorage(); // Use Local Storage
                 }
            }

            function setTheme() {
                try {
                    const theme = Telegram.WebApp.themeParams;
                     console.log("Applying Telegram theme:", theme);
                    if (theme) {
                        // Apply theme colors cautiously, providing fallbacks
                         document.documentElement.style.setProperty('--bg-color', theme.bg_color || '#4E342E');
                         document.documentElement.style.setProperty('--text-color', theme.text_color || '#FFF8E1');
                         document.documentElement.style.setProperty('--button-color', theme.button_color || '#FFD700');
                         document.documentElement.style.setProperty('--button-text-color', theme.button_text_color || '#3E2723');
                         // Maybe update other colors based on bg_color contrast if needed
                    }
                } catch (error) {
                    console.error("Error applying Telegram theme:", error);
                }
            }

            async function initCloudStorage() {
                 console.log("Initializing with Cloud Storage for user:", state.userId);
                 const keysToFetch = [
                     'energyLevel', 'points', 'challenges', 'challengeHistory', 'birthdate',
                     'consecutiveDays', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks',
                     'workshopAccess', 'leaderboard' // Fetch saved leaderboard
                 ];

                 try {
                     const values = await Promise.all(keysToFetch.map(key =>
                         Telegram.WebApp.CloudStorage.getItem(key)
                             .then(val => {
                                 console.log(`Fetched '${key}':`, val === undefined ? '<not set>' : val);
                                 return val === undefined ? null : val; // Return null if not set
                             })
                             .catch(err => {
                                 console.error(`Error fetching '${key}' from CloudStorage:`, err);
                                 showNotification(`Error loading ${key}. Data might be reset.`, 'error');
                                 return null; // Return null on error
                             })
                     ));

                     const fetchedData = Object.fromEntries(keysToFetch.map((key, i) => [key, values[i]]));

                     // Apply fetched data to state, parsing carefully
                     state.energyLevel = fetchedData.energyLevel !== null ? parseInt(fetchedData.energyLevel) || 0 : 0;
                     state.points = fetchedData.points !== null ? parseInt(fetchedData.points) || 0 : 0;
                     state.challenges = fetchedData.challenges ? JSON.parse(fetchedData.challenges) : initializeChallenges();
                     state.challengeHistory = fetchedData.challengeHistory ? JSON.parse(fetchedData.challengeHistory) : [];
                     state.birthdate = fetchedData.birthdate || null;
                     state.consecutiveDays = fetchedData.consecutiveDays !== null ? parseInt(fetchedData.consecutiveDays) || 0 : 0;
                     state.lastPlayedDate = fetchedData.lastPlayedDate || null;
                     state.lastCheckInTime = fetchedData.lastCheckInTime !== null ? parseInt(fetchedData.lastCheckInTime) : null;
                     state.completedTasks = fetchedData.completedTasks ? JSON.parse(fetchedData.completedTasks) : [];
                     state.workshopAccess = fetchedData.workshopAccess === 'true';
                      // Load leaderboard, merge with defaults if needed, ensure user is present
                     const savedLeaderboard = fetchedData.leaderboard ? JSON.parse(fetchedData.leaderboard) : [];
                     state.leaderboard = mergeLeaderboards(state.leaderboard, savedLeaderboard); // Merge defaults and saved
                     ensureUserInLeaderboard(); // Make sure current user exists


                     // If challenges were empty/reset, save the initialized ones
                     if (!fetchedData.challenges) {
                          console.log("No challenges found in CloudStorage, initializing and saving.");
                          await saveStateToCloud(['challenges']);
                     }
                    if (!fetchedData.leaderboard) {
                        console.log("No leaderboard found, saving initial.");
                        await saveStateToCloud(['leaderboard']);
                    }


                     console.log("State after CloudStorage load:", JSON.parse(JSON.stringify(state))); // Deep copy for logging

                     checkDailyReset(); // Check if day has changed for streak/check-in reset
                     updateUI();
                     startCountdown();
                     showInitialSection();

                 } catch (error) {
                     console.error('Initialization error with CloudStorage:', error);
                     showNotification('Failed to load data from cloud. Using defaults.', 'error');
                     // Fallback to basic initialization if cloud fails massively
                     state.challenges = initializeChallenges();
                     ensureUserInLeaderboard();
                     updateUI();
                     showInitialSection();
                 } finally {
                     state.isLoading = false;
                     // domElements.loading.style.display = 'none'; // Loading element removed
                 }
            }


            function initLocalStorage() {
                 console.log("Initializing with Local Storage for user:", state.userId);
                 try {
                    state.energyLevel = parseInt(localStorage.getItem('energyLevel') || '0');
                    state.points = parseInt(localStorage.getItem('points') || '0');
                    state.challenges = JSON.parse(localStorage.getItem('challenges') || 'null') || initializeChallenges();
                    state.challengeHistory = JSON.parse(localStorage.getItem('challengeHistory') || '[]');
                    state.birthdate = localStorage.getItem('birthdate') || null;
                    state.consecutiveDays = parseInt(localStorage.getItem('consecutiveDays') || '0');
                    state.lastPlayedDate = localStorage.getItem('lastPlayedDate') || null;
                    state.lastCheckInTime = localStorage.getItem('lastCheckInTime') ? parseInt(localStorage.getItem('lastCheckInTime')) : null;
                    state.completedTasks = JSON.parse(localStorage.getItem('completedTasks') || '[]');
                    state.workshopAccess = localStorage.getItem('workshopAccess') === 'true';
                    // Load leaderboard from local storage
                    const savedLeaderboard = JSON.parse(localStorage.getItem('leaderboard') || 'null') || [];
                    state.leaderboard = mergeLeaderboards(state.leaderboard, savedLeaderboard); // Merge defaults and saved
                    ensureUserInLeaderboard(); // Make sure current user exists

                     // Save initialized challenges/leaderboard if they were missing
                     if (!localStorage.getItem('challenges')) {
                         localStorage.setItem('challenges', JSON.stringify(state.challenges));
                     }
                    if (!localStorage.getItem('leaderboard')) {
                         localStorage.setItem('leaderboard', JSON.stringify(state.leaderboard));
                     }


                     console.log("State after LocalStorage load:", JSON.parse(JSON.stringify(state)));

                     checkDailyReset();
                     updateUI();
                     startCountdown();
                     showInitialSection();

                 } catch (error) {
                     console.error('Initialization error with LocalStorage:', error);
                     showNotification('Failed to load local data. Using defaults.', 'error');
                     state.challenges = initializeChallenges();
                     ensureUserInLeaderboard();
                     updateUI();
                     showInitialSection();
                 } finally {
                      state.isLoading = false;
                      // domElements.loading.style.display = 'none'; // Loading element removed
                 }
            }

            function mergeLeaderboards(defaultBoard, savedBoard) {
                const merged = [...defaultBoard];
                const defaultUserIds = new Set(defaultBoard.map(u => u.userId));
                savedBoard.forEach(savedUser => {
                    if (!defaultUserIds.has(savedUser.userId)) {
                        merged.push(savedUser);
                    } else {
                        // Optional: Update points of default users if they exist in saved data
                        const defaultUser = merged.find(u => u.userId === savedUser.userId);
                        if (defaultUser && savedUser.points > defaultUser.points) {
                            defaultUser.points = savedUser.points;
                        }
                    }
                });
                return merged;
            }

             function ensureUserInLeaderboard() {
                 if (!state.leaderboard.find(p => p.userId === state.userId)) {
                     console.log(`User ${state.userId} not found in leaderboard, adding.`);
                     state.leaderboard.push({ userId: state.userId, name: state.userName, points: state.points });
                     // No need to save here, will be saved when points change or explicitly
                 } else {
                    // Ensure user's points in leaderboard match current state points
                    const userEntry = state.leaderboard.find(p => p.userId === state.userId);
                    if (userEntry.points !== state.points) {
                        console.log(`Updating leaderboard points for user ${state.userId} from ${userEntry.points} to ${state.points}`);
                        userEntry.points = state.points;
                    }
                 }
             }


            async function saveStateToCloud(keysToSave) {
                if (!window.Telegram?.WebApp) return; // Only save if TG is available
                 if (state.isLoading) {
                     console.warn("Attempted to save state while still loading, skipping.");
                     return; // Prevent saving during initialization
                 }

                 console.log(`Saving keys to CloudStorage: ${keysToSave.join(', ')}`);
                const promises = keysToSave.map(key => {
                    let valueToSave;
                    switch (key) {
                        case 'challenges':
                        case 'challengeHistory':
                        case 'completedTasks':
                        case 'leaderboard':
                            valueToSave = JSON.stringify(state[key]);
                            break;
                        case 'workshopAccess':
                            valueToSave = state[key] ? 'true' : 'false';
                            break;
                        case 'birthdate':
                        case 'lastPlayedDate':
                             valueToSave = state[key]; // Already strings or null
                             break;
                        default: // For numbers like points, energyLevel, consecutiveDays, lastCheckInTime
                            valueToSave = state[key] !== null ? state[key].toString() : null;
                            break;
                    }

                    // Don't try to save null values unless it's intentional (like clearing a date)
                    if (valueToSave === null && key !== 'birthdate' && key !== 'lastPlayedDate' && key !== 'lastCheckInTime') {
                        // Optionally remove the item if setting to null/undefined equivalent
                        // return Telegram.WebApp.CloudStorage.removeItem(key);
                         console.warn(`Skipping save for key '${key}' as value is null/undefined.`);
                         return Promise.resolve(); // Resolve promise without saving
                    }

                    console.log(`Saving ${key}:`, valueToSave);
                    return Telegram.WebApp.CloudStorage.setItem(key, valueToSave)
                         .catch(err => {
                              console.error(`Error saving '${key}' to CloudStorage:`, err);
                              showNotification(`Error saving ${key}`, 'error');
                              // Don't reject Promise.all, just log the error for the specific key
                         });
                 });

                 try {
                     await Promise.all(promises);
                     console.log(`Successfully completed save operation for keys: ${keysToSave.join(', ')}`);
                 } catch (error) {
                     // This catch block might not be reached if individual promises handle errors
                     console.error("Error during Promise.all for saving state:", error);
                 }
            }

            function saveStateToLocal(keysToSave) {
                 if (window.Telegram?.WebApp) return; // Only save if TG is NOT available
                  if (state.isLoading) {
                     console.warn("Attempted to save state while still loading, skipping.");
                     return;
                 }

                console.log(`Saving keys to LocalStorage: ${keysToSave.join(', ')}`);
                keysToSave.forEach(key => {
                     try {
                        let valueToSave;
                         switch (key) {
                            case 'challenges':
                            case 'challengeHistory':
                            case 'completedTasks':
                            case 'leaderboard':
                                 valueToSave = JSON.stringify(state[key]);
                                 break;
                             case 'workshopAccess':
                                valueToSave = state[key] ? 'true' : 'false';
                                break;
                            default: // numbers, strings, nulls
                                 valueToSave = state[key];
                                break;
                         }

                        if (valueToSave !== null && valueToSave !== undefined) {
                             localStorage.setItem(key, valueToSave);
                             console.log(`Saved ${key}:`, valueToSave);
                         } else {
                            // If value is null/undefined, remove from local storage
                             localStorage.removeItem(key);
                             console.log(`Removed ${key} from LocalStorage.`);
                         }
                     } catch (error) {
                         console.error(`Error saving '${key}' to LocalStorage:`, error);
                          showNotification(`Error saving ${key}`, 'error');
                     }
                 });
            }

             // Helper to save specific keys based on environment
             async function saveData(keys) {
                 if (window.Telegram?.WebApp) {
                     await saveStateToCloud(keys);
                 } else {
                     saveStateToLocal(keys);
                 }
             }

             function showInitialSection() {
                // Determine the first screen based on state
                 const firstSection = state.birthdate ? 'wellnessManager' : 'horoscopeForm';
                 sectionStack = [firstSection]; // Reset stack to the initial section
                 showSection(firstSection, true); // Show without pushing to stack again
             }


             function updateUI() {
                 domElements.profilePhoto.src = state.userPhoto;
                 domElements.profileNameDisplay.textContent = state.userName;
                 domElements.profileNameDisplayInner.textContent = state.userName;
                 domElements.pointsDisplay.textContent = `${state.points} $twote`;
                 domElements.pointsValue.textContent = state.points;
                 domElements.consecutiveDaysValue.textContent = state.consecutiveDays;
                 domElements.energyValue.textContent = state.energyLevel;
                 if (state.userId) {
                     // Assuming your bot username is ThirdEyeTestDevBot or similar
                     const botUsername = "ThirdEyeTestDevBot"; // Replace with your actual bot username
                     domElements.referralLink.value = `https://t.me/${botUsername}?start=${state.userId}`;
                 }
                 updateDailyCheckInButtonState(); // Update button text/disabled state
                 updateLeaderboard(); // Refresh leaderboard display
                 // Update task buttons based on state.completedTasks
                 updateTaskButtons();
             }

             function updateDailyCheckInButtonState() {
                const now = Date.now();
                const twentyFourHours = 24 * 60 * 60 * 1000;
                const canCheckIn = !state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours);

                 if (canCheckIn) {
                     domElements.dailyCheckInBtn.disabled = false;
                     domElements.dailyCheckInBtn.textContent = "Daily Check-In";
                      domElements.countdownDisplay.textContent = ''; // Clear countdown if ready
                 } else {
                     domElements.dailyCheckInBtn.disabled = true;
                     domElements.dailyCheckInBtn.textContent = "Checked In";
                     startCountdown(); // Ensure countdown is running if needed
                 }
             }

            function showSection(sectionId, isInitial = false) {
                 // Only push to stack if it's not the initial load and different from current top
                 if (!isInitial && sectionId !== sectionStack[sectionStack.length - 1]) {
                     sectionStack.push(sectionId);
                 } else if (isInitial) {
                    sectionStack = [sectionId]; // Ensure stack starts correctly on initial load
                 }

                 console.log("Showing section:", sectionId, "Stack:", sectionStack);

                 sections.forEach(id => {
                     const el = document.getElementById(id);
                     if (el) el.style.display = id === sectionId ? 'block' : 'none';
                 });

                 // Update Telegram back button visibility
                 if (window.Telegram?.WebApp) {
                    if (sectionStack.length > 1) {
                        Telegram.WebApp.BackButton.show();
                    } else {
                        Telegram.WebApp.BackButton.hide();
                    }
                 }

                 // Trigger section-specific loading logic
                 switch (sectionId) {
                     case 'wellnessManager': loadChallenges(); break;
                     case 'dailyChallenges': displayDailyChallenges(state.currentChallengeDuration); break;
                     // case 'tasksSection': updateTaskButtons(); break; // updateUI already calls this
                     case 'playerProfile': loadProfileHistory(); updateLeaderboard(); break; // Reload history/leaderboard on profile view
                     case 'horoscopeWheelPage': drawAstrologyWheel(); break;
                     case 'numerologyPathPage': initNumerologyPath(); break;
                 }
             }

             // Setup Telegram Back Button listener
             if (window.Telegram?.WebApp) {
                 Telegram.WebApp.BackButton.onClick(() => {
                     console.log("Back button clicked. Stack before pop:", sectionStack);
                     if (sectionStack.length > 1) {
                         sectionStack.pop();
                         const previousSection = sectionStack[sectionStack.length - 1];
                         console.log("Navigating back to:", previousSection);
                         showSection(previousSection, true); // Show previous without pushing again
                     } else {
                         console.log("Back button clicked, but stack is too small.");
                         // Optionally close the web app or do nothing
                         // Telegram.WebApp.close();
                     }
                 });
             }

             async function saveHoroscope() {
                 const birthdateInput = document.getElementById('birthdate');
                 const birthdate = birthdateInput.value;
                 if (birthdate) {
                     state.birthdate = birthdate;
                     await saveData(['birthdate']); // Save the birthdate
                     showSection('wellnessManager');
                 } else {
                     showNotification('Please enter your birthdate.', 'error');
                     birthdateInput.focus();
                 }
             }

            async function updateEnergyLevel(before = null, after = null) {
                if (before !== null && after !== null) {
                    // Calculate new energy level (average, capped at 100)
                    state.energyLevel = Math.min(Math.max(Math.round((before + after) / 2), 0), 100);
                    domElements.energyValue.textContent = state.energyLevel; // Update UI immediately
                     await saveData(['energyLevel']); // Persist the new energy level
                 }
             }

             async function awardPoints(amount) {
                 if (amount <= 0) return; // No points to award

                 state.points += amount;
                 console.log(`Awarded ${amount} points. New total: ${state.points}`);

                 // Update leaderboard state
                 const playerIndex = state.leaderboard.findIndex(p => p.userId === state.userId);
                 if (playerIndex > -1) {
                     state.leaderboard[playerIndex].points = state.points;
                 } else {
                     // This case should be handled by ensureUserInLeaderboard, but as a fallback:
                     state.leaderboard.push({ userId: state.userId, name: state.userName, points: state.points });
                      console.warn("User was not in leaderboard, added during awardPoints.");
                 }

                 // Save points and leaderboard
                 await saveData(['points', 'leaderboard']);

                 updateUI(); // Update points display everywhere
                 showNotification(`+${amount} $twote earned! âœ¨`, 'success'); // Use success type
             }

            function checkDailyReset() {
                const today = new Date().toISOString().split('T')[0];
                 console.log(`Checking daily reset: Today is ${today}, Last played was ${state.lastPlayedDate}`);

                if (!state.lastPlayedDate) {
                    // First time playing or data reset
                    state.consecutiveDays = 0;
                     console.log("No last played date, streak set to 0.");
                    return;
                 }

                 if (state.lastPlayedDate === today) {
                     console.log("Already played today, no change to streak.");
                     return; // Already played today, no change
                 }

                 const todayDate = new Date(today);
                 const lastPlayedDateObj = new Date(state.lastPlayedDate);

                 // Calculate difference in days, accounting for DST changes is complex,
                 // but for simple day difference, this usually works:
                 const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                 const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24)); // Use Math.round for closer dates

                 console.log(`Difference in days: ${diffDays}`);

                 if (diffDays === 1) {
                    // Consecutive day
                     // state.consecutiveDays++; // Increment handled during check-in
                     console.log("Consecutive day detected (streak will increase on check-in).");
                 } else if (diffDays > 1) {
                    // Missed one or more days
                    state.consecutiveDays = 0;
                    console.log("Missed days, resetting streak to 0.");
                    saveData(['consecutiveDays']); // Save the reset streak immediately
                 } else if (diffDays <= 0) {
                     // This case might happen with time zone shifts or errors, treat as same day or reset.
                     console.warn(`Unexpected day difference: ${diffDays}. Treating as no streak change or reset.`);
                     // Optionally reset streak if diffDays is negative (clock moved back significantly?)
                     // state.consecutiveDays = 0;
                 }

                 // Reset the 24-hour check-in timer if the day has rolled over
                 const now = Date.now();
                 const twentyFourHours = 24 * 60 * 60 * 1000;
                 if (state.lastCheckInTime && (now - state.lastCheckInTime >= twentyFourHours)) {
                     // If 24 hours passed OR if the date string changed (handled above), allow new check-in.
                     // We just need to ensure the button state reflects this.
                     console.log("24-hour check-in period elapsed or new day started.");
                 }
                 // updateDailyCheckInButtonState will handle the button enablement/countdown display
            }


            async function dailyCheckIn() {
                const now = Date.now();
                const twentyFourHours = 24 * 60 * 60 * 1000;

                 // Double check cooldown server-side if necessary, client-side check:
                 if (state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours)) {
                     showNotification('You can check in again after the 24-hour cooldown.', 'warning');
                     return;
                 }

                domElements.dailyCheckInBtn.disabled = true; // Disable immediately
                 domElements.dailyCheckInBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Checking In...'; // Loading state


                const today = new Date().toISOString().split('T')[0];
                 let pointsAwarded = 5; // Base points

                // Check streak logic *before* updating lastPlayedDate
                 if (state.lastPlayedDate) {
                     const lastPlayedDateObj = new Date(state.lastPlayedDate);
                     const todayDate = new Date(today);
                     const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                     const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                     if (diffDays === 1) {
                         state.consecutiveDays++;
                         pointsAwarded += Math.min(state.consecutiveDays, 5); // Bonus points for streak (max +5)
                         console.log(`Streak maintained! Day ${state.consecutiveDays}. Bonus points: ${Math.min(state.consecutiveDays, 5)}`);
                     } else if (diffDays > 1) {
                         state.consecutiveDays = 1; // Start new streak
                         console.log("Streak broken, starting new streak at Day 1.");
                     } else {
                        // Already checked in today or date issue, but state.lastCheckInTime check should prevent this.
                        // If somehow reached, assume starting streak
                         if (state.lastPlayedDate !== today) state.consecutiveDays = 1;
                     }
                 } else {
                    state.consecutiveDays = 1; // First check-in ever
                    console.log("First check-in, starting streak at Day 1.");
                 }

                 // Update state *after* calculations
                 state.lastPlayedDate = today;
                 state.lastCheckInTime = now;

                 // Save all relevant state changes
                 await saveData(['lastPlayedDate', 'lastCheckInTime', 'consecutiveDays']);
                 await awardPoints(pointsAwarded); // Award points (this also saves points & leaderboard)

                 updateUI(); // Refresh UI elements including button state and countdown
                 showNotification(`Checked in! Day ${state.consecutiveDays}.`, 'success');
             }

            function startCountdown() {
                // Clear any existing interval
                 if (window.checkinCountdownInterval) {
                     clearInterval(window.checkinCountdownInterval);
                 }

                if (!state.lastCheckInTime) {
                    domElements.countdownDisplay.textContent = ''; // No countdown needed
                    updateDailyCheckInButtonState(); // Ensure button is enabled if needed
                    return;
                }

                 const twentyFourHours = 24 * 60 * 60 * 1000;
                 const endTime = state.lastCheckInTime + twentyFourHours;

                 function updateCountdownDisplay() {
                     const now = Date.now();
                     const timeLeft = endTime - now;

                     if (timeLeft <= 0) {
                         domElements.countdownDisplay.textContent = '';
                         // No need to clear lastCheckInTime here, dailyCheckIn logic handles it
                         updateDailyCheckInButtonState(); // Enable button
                         clearInterval(window.checkinCountdownInterval); // Stop interval
                         return;
                     }

                     const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                     const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                     const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                     domElements.countdownDisplay.textContent = `Next check-in: ${hours}h ${minutes}m ${seconds}s`;
                     domElements.dailyCheckInBtn.disabled = true; // Ensure button remains disabled
                      domElements.dailyCheckInBtn.textContent = "Checked In"; // Ensure text is correct
                 }

                 updateCountdownDisplay(); // Run immediately
                 window.checkinCountdownInterval = setInterval(updateCountdownDisplay, 1000); // Update every second
             }


             function initializeChallenges() {
                 // Generate 150 days of challenges, cycling through goals
                 return Array.from({ length: 150 }, (_, i) => {
                     const goalIndex = i % dailyGoals.length;
                     return {
                         day: i + 1,
                         goal: dailyGoals[goalIndex].goal,
                         meditation: dailyGoals[goalIndex].meditation,
                         task1: dailyGoals[goalIndex].task1,
                         task2: dailyGoals[goalIndex].task2,
                         points: dailyGoals[goalIndex].points,
                         completed: false,
                         // Add placeholders for proof if needed, maybe not necessary until completion
                         // task1Image: null,
                         // task2Image: null
                     };
                 });
             }

             function getCompletedDaysCount(maxDay) {
                // Count completed challenges up to a certain day number
                 return state.challenges.slice(0, maxDay).filter(ch => ch.completed).length;
             }

             function isChallengeUnlocked(days) {
                // Simplified logic: Check if previous tier is fully completed
                 switch (days) {
                     case 7: return true; // Always unlocked
                     case 21: return getCompletedDaysCount(7) === 7; // Requires 7-day completion
                     case 41: return getCompletedDaysCount(21) === 21; // Requires 21-day completion
                     // Workshop challenges
                     case 66: return state.workshopAccess && getCompletedDaysCount(41) === 41;
                     case 150: return state.workshopAccess && getCompletedDaysCount(66) === 66;
                     default: return false;
                 }
             }

             function loadChallenges() {
                const challengeDurations = [7, 21, 41, 66, 150];
                 const challengeIcons = { 7: 'fas fa-sun', 21: 'fas fa-seedling', 41: 'fas fa-star', 66: 'fas fa-moon', 150: 'fas fa-crown' }; // Updated icons
                 const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' }; // Added descriptive titles

                 domElements.challengeOptions.innerHTML = ''; // Clear previous options

                 challengeDurations.forEach(days => {
                     const isUnlocked = isChallengeUnlocked(days);
                     const iconClass = challengeIcons[days] || 'fas fa-question-circle';
                     const title = challengeTitles[days] || `${days}-Day`;
                     const requiresWorkshop = days > 41;
                     const prevTierDays = days === 21 ? 7 : (days === 41 ? 21 : (days === 66 ? 41 : (days === 150 ? 66 : 0)));
                     const prevTierTitle = challengeTitles[prevTierDays] || `${prevTierDays}-Day`;

                     const div = document.createElement('div');
                     div.className = `challenge-div ${isUnlocked ? '' : 'locked'}`; // Apply 'locked' class for visual styling

                     let content = `
                         <i class="${iconClass} challenge-icon"></i>
                         <h3>${days}-Day: ${title}</h3>
                     `;

                     if (isUnlocked) {
                         content += `<button class="btn btn-custom start-challenge-btn mt-2" data-days="${days}">Begin ${title}</button>`;
                     } else {
                         if (requiresWorkshop && !state.workshopAccess) {
                             // Requires workshop access which user doesn't have
                              if (getCompletedDaysCount(prevTierDays) !== prevTierDays) {
                                 // Also needs previous tier completion
                                 content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                             } else {
                                // Previous tier done, but needs workshop
                                 content += `<p class="warning-text">Requires Workshop Access</p>
                                             <button class="btn btn-custom enroll-btn mt-2" data-days="${days}" style="font-size: 0.9em;">Enroll Info</button>
                                             <button class="btn btn-secondary attended-btn mt-2 ms-1" data-days="${days}" style="font-size: 0.9em;">Enter Code</button>`;
                             }
                         } else if (requiresWorkshop && state.workshopAccess) {
                            // Has workshop access, but needs previous tier completion
                             content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                         }
                         else {
                             // Doesn't require workshop, just needs previous tier completion
                             content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`;
                         }
                     }

                     div.innerHTML = content;
                     domElements.challengeOptions.appendChild(div);
                 });

                 // Add event listeners (using event delegation is often better for dynamic content)
                 domElements.challengeOptions.addEventListener('click', (event) => {
                     const target = event.target;
                     if (target.classList.contains('start-challenge-btn')) {
                         const days = parseInt(target.getAttribute('data-days'));
                         state.currentChallengeDuration = days;
                          // No need to save duration to state yet, only used for display logic
                         showSection('dailyChallenges');
                     } else if (target.classList.contains('enroll-btn')) {
                         const days = parseInt(target.getAttribute('data-days'));
                         showEnrollModal(days);
                     } else if (target.classList.contains('attended-btn')) {
                         const days = parseInt(target.getAttribute('data-days'));
                         showCodeModal(days);
                     }
                 });
             }

             function displayDailyChallenges(days) {
                 if (!days) {
                     console.error("No challenge duration set.");
                     showSection('wellnessManager'); // Go back if duration is missing
                     return;
                 }

                 const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
                 domElements.challengeTitle.textContent = `${days}-Day Challenge: ${challengeTitles[days] || ''}`;
                 domElements.dailyChallengeList.innerHTML = ''; // Clear previous list

                 // Find the first uncompleted day within the current challenge duration
                 let firstUncompletedIndex = state.challenges.slice(0, days).findIndex(ch => !ch.completed);
                 if (firstUncompletedIndex === -1) firstUncompletedIndex = days; // All completed

                 state.challenges.slice(0, days).forEach((challenge, index) => {
                     const card = document.createElement('div');
                     card.className = 'challenge-div mb-2'; // Use mb-2 for less spacing
                     const isLocked = index > 0 && !state.challenges[index - 1].completed; // Locked if previous day isn't done
                     const canStart = index === firstUncompletedIndex; // Can start if it's the first uncompleted day

                     let content = `<h4 style="color: var(--challenge-description-color); font-size: 1.1rem;">Day ${challenge.day}: ${challenge.goal}</h4>`; // Apply color explicitly

                     if (challenge.completed) {
                         content += `<p style="color: green; font-weight: bold;"><i class="fas fa-check-circle"></i> Completed (+${challenge.points} $twote)</p>`;
                     } else if (isLocked) {
                         content += `<p class="warning-text" style="font-size: 0.9em;"><i class="fas fa-lock"></i> Complete Day ${challenge.day - 1} first</p>`;
                         card.classList.add('locked'); // Add locked style
                     } else if (canStart) {
                         content += `<button class="btn btn-custom btn-sm mt-1" data-day="${challenge.day}">Start Day ${challenge.day}</button>`;
                     } else {
                        // Future days that are not yet the 'first uncompleted'
                         content += `<p style="color: #aaa; font-size: 0.9em;"><i class="fas fa-hourglass-start"></i> Pending</p>`;
                         card.classList.add('locked');
                     }

                     card.innerHTML = content;
                     domElements.dailyChallengeList.appendChild(card);
                 });

                 // Add event listeners for the start buttons
                 domElements.dailyChallengeList.querySelectorAll('button.btn-custom').forEach(btn => {
                     btn.addEventListener('click', () => startChallenge(parseInt(btn.getAttribute('data-day'))));
                 });
             }


            function startChallenge(day) {
                const challenge = state.challenges.find(c => c.day === day);
                if (!challenge) {
                    console.error(`Challenge data for day ${day} not found.`);
                    return;
                }

                 // Reset state for the modal
                 state.currentChallengeDay = day;
                 state.energyBefore = null; // Reset energyBefore

                 // Configure the modal for the 'before' stage
                 document.getElementById('energyLogModalTitle').textContent = `Day ${day}: ${challenge.goal} - Before`;
                 domElements.energyLogPrompt.textContent = "Log your current energy level (0-100%).";
                 domElements.energySlider.value = 50; // Default slider position
                 domElements.energySliderValue.textContent = '50%';
                 domElements.challengeTasks.style.display = 'none'; // Hide tasks initially
                 domElements.proofWarning.style.display = 'none'; // Hide proof warning
                 domElements.submitEnergyLog.textContent = 'Confirm Energy & View Tasks';
                 domElements.submitEnergyLog.setAttribute('data-stage', 'before');
                 domElements.submitEnergyLog.disabled = false; // Enable button

                 // Clear file inputs (important!)
                 domElements.task1Proof.value = '';
                 domElements.task2Proof.value = '';

                 energyLogModalInstance.show(); // Show the modal
             }

            // Update slider display on input
            domElements.energySlider.addEventListener('input', () => {
                domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`;
                // No need to enable/disable submit button here, handled by stages
            });

            // Handle file input changes to enable submission in 'after' stage
             [domElements.task1Proof, domElements.task2Proof].forEach(input => {
                 input.addEventListener('change', () => {
                     if (domElements.submitEnergyLog.getAttribute('data-stage') === 'after') {
                         const task1File = domElements.task1Proof.files[0];
                         const task2File = domElements.task2Proof.files[0];
                         domElements.submitEnergyLog.disabled = !(task1File && task2File);
                          domElements.proofWarning.style.display = (task1File && task2File) ? 'none' : 'block';
                     }
                 });
             });


             domElements.submitEnergyLog.addEventListener('click', async () => {
                 const sliderValue = parseInt(domElements.energySlider.value);
                 const stage = domElements.submitEnergyLog.getAttribute('data-stage');
                 const challenge = state.challenges.find(c => c.day === state.currentChallengeDay);

                 if (!challenge) {
                     console.error("Challenge data missing during submission.");
                     energyLogModalInstance.hide();
                     return;
                 }

                 domElements.submitEnergyLog.disabled = true; // Disable button during processing

                 if (stage === 'before') {
                     state.energyBefore = sliderValue; // Record starting energy
                     console.log(`Energy Before (Day ${state.currentChallengeDay}): ${state.energyBefore}%`);

                     // Update modal for 'after' stage
                     document.getElementById('energyLogModalTitle').textContent = `Day ${state.currentChallengeDay}: ${challenge.goal} - After`;
                     domElements.energyLogPrompt.textContent = "Complete tasks & log your energy post-challenge.";
                     domElements.challengeTasks.style.display = 'block'; // Show tasks
                     domElements.meditationTask.textContent = challenge.meditation;
                     domElements.task1Text.textContent = challenge.task1;
                     domElements.task2Text.textContent = challenge.task2;

                     // Reset slider for 'after' log, keep file inputs empty
                     domElements.energySlider.value = 50;
                     domElements.energySliderValue.textContent = '50%';
                     domElements.task1Proof.value = '';
                     domElements.task2Proof.value = '';

                     domElements.submitEnergyLog.textContent = 'Submit Completion';
                     domElements.submitEnergyLog.setAttribute('data-stage', 'after');
                     // Keep button disabled until proof is uploaded
                     domElements.submitEnergyLog.disabled = true;
                     domElements.proofWarning.style.display = 'block'; // Show proof warning initially


                 } else if (stage === 'after') {
                     const energyAfter = sliderValue;
                     const task1File = domElements.task1Proof.files[0];
                     const task2File = domElements.task2Proof.files[0];

                     if (!task1File || !task2File) {
                         showNotification('Please upload proof for both tasks.', 'error');
                         domElements.submitEnergyLog.disabled = false; // Re-enable button
                         domElements.proofWarning.style.display = 'block';
                         return;
                     }

                     console.log(`Energy After (Day ${state.currentChallengeDay}): ${energyAfter}%`);
                     domElements.submitEnergyLog.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...'; // Loading indicator


                     try {
                        // Simulate image upload/processing - In real app, upload to server/storage
                        // For now, we just mark as completed. Storing base64 in CloudStorage is NOT recommended for large images.
                        // We'll just store a marker or small data in history.
                        // const [task1Image, task2Image] = await Promise.all([
                        //     readFileAsDataURL(task1File),
                        //     readFileAsDataURL(task2File)
                        // ]);

                         // Update challenge state
                         challenge.completed = true;

                         // Add entry to history (without large image data)
                         state.challengeHistory.push({
                             day: state.currentChallengeDay,
                             goal: challenge.goal,
                             energyBefore: state.energyBefore,
                             energyAfter,
                             task1ProofProvided: true, // Mark as provided instead of storing image data
                             task2ProofProvided: true
                             // task1Image: task1Image, // Avoid storing large data here
                             // task2Image: task2Image
                         });

                         // Update overall energy level and award points
                         await updateEnergyLevel(state.energyBefore, energyAfter); // This saves energyLevel
                         await awardPoints(challenge.points); // This saves points & leaderboard

                         // Save the updated challenges and history
                         await saveData(['challenges', 'challengeHistory']);

                         energyLogModalInstance.hide();
                         showNotification(`Day ${state.currentChallengeDay} completed! ðŸŽ‰`, 'success');
                         displayDailyChallenges(state.currentChallengeDuration); // Refresh the challenge list view

                     } catch (error) {
                         console.error("Error processing challenge completion:", error);
                         showNotification('Error submitting completion. Please try again.', 'error');
                         domElements.submitEnergyLog.textContent = 'Submit Completion'; // Reset button text
                         domElements.submitEnergyLog.disabled = false; // Re-enable on error
                     }
                 }
             });

             // Removed readFileAsDataURL function - avoid storing large data client-side long-term

             function getHoroscope(birthdate) {
                 if (!birthdate) return "Unknown";
                 try {
                     const date = new Date(birthdate);
                     const month = date.getMonth() + 1; // 1-12
                     const day = date.getDate();
                     // Simplified mapping (adjust dates slightly if needed for cusp accuracy)
                     if ((month == 3 && day >= 21) || (month == 4 && day <= 19)) return "Aries";
                     if ((month == 4 && day >= 20) || (month == 5 && day <= 20)) return "Taurus";
                     if ((month == 5 && day >= 21) || (month == 6 && day <= 21)) return "Gemini"; // Adjusted end date
                     if ((month == 6 && day >= 22) || (month == 7 && day <= 22)) return "Cancer"; // Adjusted start date
                     if ((month == 7 && day >= 23) || (month == 8 && day <= 22)) return "Leo";
                     if ((month == 8 && day >= 23) || (month == 9 && day <= 22)) return "Virgo";
                     if ((month == 9 && day >= 23) || (month == 10 && day <= 23)) return "Libra"; // Adjusted end date
                     if ((month == 10 && day >= 24) || (month == 11 && day <= 21)) return "Scorpio"; // Adjusted start date
                     if ((month == 11 && day >= 22) || (month == 12 && day <= 21)) return "Sagittarius";
                     if ((month == 12 && day >= 22) || (month == 1 && day <= 19)) return "Capricorn";
                     if ((month == 1 && day >= 20) || (month == 2 && day <= 18)) return "Aquarius";
                     if ((month == 2 && day >= 19) || (month == 3 && day <= 20)) return "Pisces";
                 } catch (e) {
                     console.error("Error parsing birthdate:", e);
                 }
                 return "Unknown";
             }

            function showEnrollModal(days) {
                 domElements.enrollName.textContent = state.userName;
                 domElements.enrollHoroscope.textContent = getHoroscope(state.birthdate);
                 domElements.enrollEnergy.textContent = state.energyLevel;
                 const canEnroll = state.energyLevel >= 70;
                 domElements.submitEnrollment.disabled = !canEnroll;
                 domElements.enrollRequirement.style.display = canEnroll ? 'none' : 'block';
                 // Update the click listener specifically for this call
                 domElements.submitEnrollment.onclick = () => enroll(days);
                 enrollModalInstance.show();
             }

             async function enroll(days) {
                 // Re-check energy level just in case
                 if (state.energyLevel < 70) {
                     showNotification('Energy level must be 70% or higher to enroll!', 'error');
                     return;
                 }
                 // In a real app, this would likely involve communication with a backend
                 // to verify workshop enrollment status or payment.
                 // For this demo, we'll just grant access locally.
                 state.workshopAccess = true;
                 await saveData(['workshopAccess']); // Persist the access change

                 enrollModalInstance.hide();
                 loadChallenges(); // Refresh the challenge list to show unlocked state
                 showNotification(`Enrollment successful! You now have access to advanced challenges.`, 'success');
             }

             function showCodeModal(days) {
                 domElements.workshopCode.value = ''; // Clear previous code
                 // Update the click listener specifically for this call
                 domElements.submitCode.onclick = () => submitCode(days);
                 codeModalInstance.show();
             }

             async function submitCode(days) {
                 const code = domElements.workshopCode.value.trim();
                 // Simple hardcoded code check for demo purposes
                 if (code.toLowerCase() === "wellness") { // Case-insensitive check
                     state.workshopAccess = true;
                     await saveData(['workshopAccess']); // Persist the access change

                     codeModalInstance.hide();
                     loadChallenges(); // Refresh the challenge list
                     showNotification(`Workshop code accepted! Access granted.`, 'success');
                 } else {
                     showNotification('Invalid workshop code. Please try again.', 'error');
                     domElements.workshopCode.focus(); // Keep focus on input
                 }
             }

             // --- Game Logic ---

             function drawAstrologyWheel() {
                 const canvas = domElements.astrologyWheelCanvas;
                 if (!canvas) return;
                 const ctx = canvas.getContext('2d');
                 const centerX = canvas.width / 2;
                 const centerY = canvas.height / 2;
                 const radius = Math.min(centerX, centerY) - 15; // Adjust radius based on canvas size, add padding
                 const numSegments = zodiacOrder.length;
                 const anglePerSegment = (2 * Math.PI) / numSegments;

                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 ctx.font = `${Math.max(radius * 0.15, 10)}px Nunito`; // Dynamic font size
                 ctx.textBaseline = 'middle';
                 ctx.textAlign = 'center';

                 zodiacOrder.forEach((zodiac, index) => {
                     const startAngle = index * anglePerSegment - Math.PI / 2 - anglePerSegment / 2; // Shift start for top alignment
                     const endAngle = startAngle + anglePerSegment;

                     // Draw segment
                     ctx.beginPath();
                     ctx.moveTo(centerX, centerY);
                     ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                     ctx.closePath();

                     // Alternate colors for better visibility
                     ctx.fillStyle = index % 2 === 0 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                     ctx.fill();
                     ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Add subtle border
                     ctx.stroke();


                     // Draw symbol
                     const textAngle = startAngle + anglePerSegment / 2;
                     const textRadius = radius * 0.75; // Position symbol within the segment
                     const textX = centerX + Math.cos(textAngle) * textRadius;
                     const textY = centerY + Math.sin(textAngle) * textRadius;

                     ctx.fillStyle = '#FFF8E1'; // Use light text color for symbols
                     ctx.fillText(zodiac.symbol, textX, textY);
                 });

                 // Draw pointer
                 ctx.beginPath();
                 ctx.moveTo(centerX + radius * 0.9, centerY); // Point slightly inwards
                 ctx.lineTo(centerX + radius * 1.1, centerY - 10); // Arrow base
                 ctx.lineTo(centerX + radius * 1.1, centerY + 10); // Arrow base
                 ctx.closePath();
                 ctx.fillStyle = 'var(--button-color)'; // Gold pointer
                 ctx.fill();
                 ctx.strokeStyle = 'var(--button-text-color)'; // Dark outline for pointer
                 ctx.lineWidth = 1;
                 ctx.stroke();

             }

             let isSpinning = false; // Prevent multiple spins

             function spinWheel() {
                 if (isSpinning) return;

                 const now = Date.now();
                 const twentyFourHours = 24 * 60 * 60 * 1000;
                 if (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours)) {
                     showNotification('Please perform your Daily Check-In first!', 'warning');
                     return;
                 }

                 isSpinning = true;
                 domElements.spinWheel.disabled = true;
                 domElements.spinWheel.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Spinning...';
                 domElements.astrologyMessage.textContent = 'Spinning the cosmic wheel...';


                 const canvas = domElements.astrologyWheelCanvas;
                 const ctx = canvas.getContext('2d');
                 const numSegments = zodiacOrder.length;
                 const anglePerSegment = (2 * Math.PI) / numSegments;

                 // More complex spin: random duration, ease-out effect
                 const spinDuration = Math.random() * 2000 + 4000; // 4-6 seconds
                 const totalRotations = Math.random() * 5 + 10; // 10-15 full rotations + final position
                 const finalAngle = Math.random() * 2 * Math.PI; // Random end position

                 const totalAngle = totalRotations * 2 * Math.PI + finalAngle;
                 let startAngle = 0; // Keep track of current rotation

                 const startTime = performance.now();

                 function easeOutQuad(t) { return t * (2 - t); }

                 function animateSpin(currentTime) {
                     const elapsedTime = currentTime - startTime;
                     const progress = Math.min(elapsedTime / spinDuration, 1); // 0 to 1
                     const easedProgress = easeOutQuad(progress);

                     const currentAngle = startAngle + easedProgress * totalAngle;

                     ctx.clearRect(0, 0, canvas.width, canvas.height);
                     ctx.save();
                     ctx.translate(canvas.width / 2, canvas.height / 2);
                     ctx.rotate(currentAngle); // Rotate the whole context
                     ctx.translate(-canvas.width / 2, -canvas.height / 2);
                     drawAstrologyWheel(); // Redraw the base wheel (it's rotated now)
                     ctx.restore(); // Restore context to draw pointer correctly

                     // --- Redraw Pointer (Stationary) ---
                     const pointerRadius = Math.min(canvas.width / 2, canvas.height / 2) - 15;
                     ctx.beginPath();
                     ctx.moveTo(canvas.width / 2 + pointerRadius * 0.9, canvas.height / 2);
                     ctx.lineTo(canvas.width / 2 + pointerRadius * 1.1, canvas.height / 2 - 10);
                     ctx.lineTo(canvas.width / 2 + pointerRadius * 1.1, canvas.height / 2 + 10);
                     ctx.closePath();
                     ctx.fillStyle = 'var(--button-color)';
                     ctx.fill();
                     ctx.strokeStyle = 'var(--button-text-color)';
                     ctx.lineWidth = 1;
                     ctx.stroke();
                     // --- End Redraw Pointer ---

                     if (progress < 1) {
                         requestAnimationFrame(animateSpin);
                     } else {
                         // Spin finished
                         // Calculate the winning segment based on final angle relative to the pointer (top)
                         const normalizedAngle = (currentAngle + Math.PI / 2 + anglePerSegment / 2) % (2 * Math.PI); // Adjust for initial rotation and make positive
                         const winningIndex = Math.floor(normalizedAngle / anglePerSegment);
                         const selectedSign = zodiacOrder[winningIndex];

                         if (selectedSign) {
                             domElements.astrologyMessage.textContent = `Landed on ${selectedSign.sign}! ${astrologyInsights[selectedSign.sign]}`;
                             awardPoints(selectedSign.points);
                         } else {
                            domElements.astrologyMessage.textContent = 'The wheel stopped between signs!';
                             console.error("Could not determine winning sign index:", winningIndex, "angle:", normalizedAngle);
                         }

                         isSpinning = false;
                         domElements.spinWheel.disabled = false;
                         domElements.spinWheel.textContent = 'Spin the Wheel';
                     }
                 }

                 requestAnimationFrame(animateSpin);
             }

             let numerologyPlayed = false; // Track if numerology was played since last check-in/page load

             function initNumerologyPath() {
                 domElements.numberGrid.innerHTML = ''; // Clear previous grid
                 domElements.numerologyMessage.textContent = 'Select a number to reveal your path!'; // Reset message
                 numerologyPlayed = false; // Reset played status for this session/view

                 const now = Date.now();
                 const twentyFourHours = 24 * 60 * 60 * 1000;
                 if (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours)) {
                      domElements.numerologyMessage.innerHTML = '<span class="warning-text">Please perform your Daily Check-In first!</span>';
                     return;
                 }

                 // Determine numbers based on streak, minimum 3, maximum 9
                 const maxNumbers = Math.max(3, 9 - Math.floor(state.consecutiveDays / 3)); // Fewer choices for higher streaks
                 const availableNumbers = Array.from({ length: 9 }, (_, i) => i + 1); // 1 to 9
                 // Shuffle and pick
                 const numbersToShow = availableNumbers.sort(() => 0.5 - Math.random()).slice(0, maxNumbers);

                 numbersToShow.forEach(num => {
                     const button = document.createElement('button');
                     button.className = 'btn btn-custom m-1';
                     button.textContent = num;
                     button.dataset.number = num; // Store number in data attribute
                     button.addEventListener('click', handleNumberSelection);
                     domElements.numberGrid.appendChild(button);
                 });
             }

            function handleNumberSelection(event) {
                 if (numerologyPlayed) {
                     showNotification("You've already chosen your number for this session.", "warning");
                     return;
                 }

                 const selectedNumber = parseInt(event.target.dataset.number);
                 const insight = numerologyInsights[selectedNumber] || "A mysterious path unfolds.";
                 const points = selectedNumber; // Points equal to the number chosen

                 domElements.numerologyMessage.textContent = `Number ${selectedNumber}: ${insight}`;
                 awardPoints(points);
                 numerologyPlayed = true; // Mark as played

                 // Disable other buttons visually
                 domElements.numberGrid.querySelectorAll('button').forEach(button => {
                     button.disabled = true;
                     if (parseInt(button.dataset.number) !== selectedNumber) {
                         button.classList.add('locked'); // Style non-selected buttons
                         button.classList.remove('btn-custom');
                         button.classList.add('btn-secondary');
                     } else {
                         button.classList.add('active'); // Highlight selected
                     }
                     // Remove event listener to prevent further clicks
                     button.removeEventListener('click', handleNumberSelection);
                 });
             }


            // --- Profile & Leaderboard ---

            function loadProfileHistory() {
                 // Display max 10-15 recent history items for performance
                 const recentHistory = state.challengeHistory.slice(-15).reverse(); // Get last 15, newest first

                 if (recentHistory.length === 0) {
                     domElements.profileHistory.innerHTML = '<tr><td colspan="6" class="text-center">No challenge history yet.</td></tr>';
                     return;
                 }

                 domElements.profileHistory.innerHTML = recentHistory.map(entry => `
                     <tr>
                         <td>${entry.day}</td>
                         <td>${entry.goal}</td>
                         <td>${entry.energyBefore}%</td>
                         <td>${entry.energyAfter}%</td>
                         <td class="text-center">${entry.task1ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                         <td class="text-center">${entry.task2ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                         <!-- Avoid displaying images directly:
                         <td><img src="${entry.task1Image}" alt="Task 1 Proof" ></td>
                         <td><img src="${entry.task2Image}" alt="Task 2 Proof" ></td>
                         -->
                     </tr>
                 `).join('');
             }

             function updateLeaderboard() {
                // Sort leaderboard by points descending
                 state.leaderboard.sort((a, b) => b.points - a.points);

                 // Update the table, limit to top 100
                 domElements.leaderboard.innerHTML = state.leaderboard.slice(0, 100).map((player, index) => `
                     <tr class="${player.userId === state.userId ? 'table-primary' : ''}">
                         <td>${index + 1}</td>
                         <td>${player.name || 'Anonymous'}</td>
                         <td>${player.points}</td>
                     </tr>
                 `).join('');

                // Add a message if leaderboard is empty
                if(state.leaderboard.length === 0) {
                    domElements.leaderboard.innerHTML = '<tr><td colspan="3" class="text-center">Leaderboard is empty.</td></tr>';
                }
             }

            async function deleteProgress() {
                // Use Telegram's confirmation dialog if available
                 const confirmationMessage = 'Are you sure you want to delete ALL your progress? This includes points, challenges, streak, and settings. This action cannot be undone.';

                 const confirmed = await new Promise((resolve) => {
                     if (window.Telegram?.WebApp?.showConfirm) {
                         Telegram.WebApp.showConfirm(confirmationMessage, (ok) => resolve(ok));
                     } else {
                         resolve(confirm(confirmationMessage)); // Fallback to browser confirm
                     }
                 });


                 if (confirmed) {
                     console.log("User confirmed deletion.");
                    // Show loading indicator manually if needed (since the element was removed)
                     document.body.insertAdjacentHTML('beforeend', '<div id="temp-loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 1.2em;">Deleting Progress...</div>');


                     // Clear relevant parts of the state object
                      const userId = state.userId; // Keep user ID and name/photo
                      const userName = state.userName;
                      const userPhoto = state.userPhoto;
                      state = initializeState(); // Reset state to defaults
                      // Restore user identification
                      state.userId = userId;
                      state.userName = userName;
                      state.userPhoto = userPhoto;
                     // Ensure user is back in the default leaderboard (with 0 points)
                     ensureUserInLeaderboard();


                     // Clear cloud/local storage
                     const keysToRemove = [
                         'energyLevel', 'points', 'challenges', 'challengeHistory', 'birthdate',
                         'consecutiveDays', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks',
                         'workshopAccess', 'leaderboard' // Also reset leaderboard stored data
                     ];

                     try {
                         if (window.Telegram?.WebApp) {
                             await Promise.all(keysToRemove.map(key =>
                                 Telegram.WebApp.CloudStorage.removeItem(key)
                                     .catch(err => console.error(`Failed to remove ${key}:`, err)) // Log errors but continue
                             ));
                             // Explicitly save the now-default (but user-identified) leaderboard
                             await saveStateToCloud(['leaderboard']);
                         } else {
                             keysToRemove.forEach(key => localStorage.removeItem(key));
                             // Explicitly save the now-default (but user-identified) leaderboard
                              saveStateToLocal(['leaderboard']);
                         }

                         console.log("Progress deleted.");
                         showNotification('Your progress has been reset.', 'success');

                         // Reset UI and navigation
                         updateUI(); // Update displays to 0 etc.
                         loadProfileHistory(); // Clear history table
                         showInitialSection(); // Go back to the start (horoscope or wellness)

                     } catch (error) {
                         console.error("Error during progress deletion:", error);
                         showNotification('Failed to completely clear data. Please reload.', 'error');
                     } finally {
                          // Remove loading indicator
                           const tempLoading = document.getElementById('temp-loading');
                           if (tempLoading) tempLoading.remove();
                     }
                 } else {
                     console.log("User cancelled deletion.");
                 }
            }

            // --- Task Management ---
             function updateTaskButtons() {
                 const taskButtons = {
                     twitter: document.getElementById('twitterTaskBtn'),
                     telegram: document.getElementById('telegramTaskBtn'),
                     instagram: document.getElementById('instagramTaskBtn'),
                     youtube: document.getElementById('youtubeTaskBtn')
                 };

                 for (const taskKey in taskButtons) {
                     const button = taskButtons[taskKey];
                     if (button) {
                         if (state.completedTasks.includes(taskKey)) {
                             button.disabled = true;
                             button.textContent = 'Done';
                             button.classList.remove('btn-custom');
                             button.classList.add('btn-success'); // Change style to success
                         } else {
                             button.disabled = false;
                             button.textContent = 'Verify'; // Or "Complete"
                             button.classList.remove('btn-success');
                             button.classList.add('btn-custom');
                         }
                     }
                 }
             }

            async function completeTask(taskKey) {
                 if (state.completedTasks.includes(taskKey)) {
                     showNotification('You have already completed this task.', 'info');
                     return;
                 }

                 const button = document.getElementById(`${taskKey}TaskBtn`);
                 if (button) {
                     button.disabled = true;
                     button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Verifying...';
                 }

                 // Simulate verification (e.g., checking API, or just assume completion after a delay)
                 // In a real app, you'd open the link and have a callback or manual verification.
                 await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate check delay

                 // Assume verification success
                 state.completedTasks.push(taskKey);
                 await saveData(['completedTasks']); // Save the updated list
                 await awardPoints(10); // Award points (this saves points/leaderboard)

                 showNotification(`Task '${taskKey}' completed! +10 $twote`, 'success');
                 updateTaskButtons(); // Update button state in the UI
            }

            function copyReferralLink() {
                 const referralLinkInput = domElements.referralLink;
                 if (!referralLinkInput || !referralLinkInput.value) {
                     showNotification('Referral link not available.', 'error');
                     return;
                 }

                 navigator.clipboard.writeText(referralLinkInput.value)
                     .then(() => {
                         showNotification('Referral link copied to clipboard!', 'success');
                     })
                     .catch(err => {
                         console.error('Failed to copy referral link: ', err);
                         // Fallback for older browsers (less reliable)
                         try {
                             referralLinkInput.select();
                             document.execCommand('copy');
                             showNotification('Referral link copied (fallback method)!', 'success');
                         } catch (fallbackErr) {
                             showNotification('Could not copy link. Please copy manually.', 'error');
                             console.error('Fallback copy failed:', fallbackErr);
                         }
                     });
             }

            // --- Event Listeners Setup ---
             function setupEventListeners() {
                 document.getElementById('profileLink').addEventListener('click', () => showSection('playerProfile'));
                 document.getElementById('saveHoroscopeBtn').addEventListener('click', saveHoroscope);

                 // Footer Navigation
                 document.getElementById('navHome').addEventListener('click', (e) => { e.preventDefault(); showSection('wellnessManager'); });
                 document.getElementById('navTasks').addEventListener('click', (e) => { e.preventDefault(); showSection('tasksSection'); });
                 document.getElementById('navGame').addEventListener('click', (e) => { e.preventDefault(); showSection('gamePage'); });
                 document.getElementById('navProfile').addEventListener('click', (e) => { e.preventDefault(); showSection('playerProfile'); }); // Added profile nav

                 // Game Page Buttons
                 document.getElementById('dailyCheckInBtn').addEventListener('click', dailyCheckIn);
                 document.getElementById('playHoroscopeWheel').addEventListener('click', () => showSection('horoscopeWheelPage'));
                 document.getElementById('playNumerologyPath').addEventListener('click', () => showSection('numerologyPathPage'));

                 // Game Interaction Buttons
                 document.getElementById('spinWheel').addEventListener('click', spinWheel);
                 // Numerology buttons are added dynamically with listeners

                 // Profile Page Buttons
                 document.getElementById('deleteProgressBtn').addEventListener('click', deleteProgress);
                 document.getElementById('connectWalletBtn').addEventListener('click', () => showNotification('Wallet connection coming soon!', 'info'));
                 document.getElementById('airdropWithdrawBtn').addEventListener('click', () => showNotification('Airdrop withdrawal feature coming soon!', 'info'));

                 // Task buttons have onclick attributes for simplicity here, but could be added via JS too
                 // Example: document.getElementById('twitterTaskBtn').addEventListener('click', () => completeTask('twitter'));

                 // Ensure challenge options listeners are setup in loadChallenges via delegation or re-binding
                 // Energy Log Modal listeners are already setup (slider input, submit button)
             }

            // --- Initialize the App ---
             setupEventListeners();
             initializeApp();

        }); // End DOMContentLoaded
    </script>
    <!-- Extra script tag and style block removed from here -->
</body>
</html>
```
189.8s

Failed to load data from cloud error and the horoscope whele does not show neither does the delete progress and the twote persistance also keeps disapearing when i refresh. keep the code as is only correct te functionality. give me just the code. do not explain
Thoughts
*The thoughts produced by the model are experimental
experiment
Expand to view model thoughts
10.3s
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added user-scalable=no -->
    <title>Third Eye</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Defer script loading -->
    <script src="https://telegram.org/js/telegram-web-app.js" defer></script>
    <style>
        :root {
            --bg-color: #4E342E;
            --text-color: #FFF8E1;
            --button-color: #FFD700;
            --button-text-color: #3E2723;
            --wellness-manager-color: #3E2723; /* Dark brown */
            --warning-color: #8B0000; /* Deep red */
            --challenge-description-color: #3E2723; /* Dark brown for challenge descriptions */
        }
        html, body {
            height: 100%; /* Ensure html and body take full height */
            margin: 0;
            padding: 0;
             overflow-x: hidden; /* Prevent horizontal scroll */
             /* overflow-y: scroll; Allows vertical scroll */
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            /* padding-bottom: 70px; /* Adjust dynamically if footer overlap issue persists */
             display: flex;
             flex-direction: column;
             min-height: 100vh; /* Make body at least viewport height */

        }
        #backgroundVideo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }
         .app-container { /* Renamed .container to avoid conflicts? */
             width: 100%;
             max-width: 800px;
             margin: 0 auto;
             padding: 0 15px;
             flex-grow: 1; /* Allows container to grow and push footer down */
             padding-bottom: 80px; /* Space above the fixed footer */

         }
        .section {
            background: rgba(255, 248, 220, 0.1);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
             /* Hide sections initially */
            display: none;
        }
        .section.active {
            display: block; /* Show only the active section */
        }

        .challenge-div {
            background: #fff;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: var(--challenge-description-color); /* Dark brown for challenge descriptions */
        }
         .challenge-div h3 {
             color: var(--challenge-description-color);
             margin-bottom: 10px;
         }
        .challenge-div p {
             color: var(--challenge-description-color);
        }
         .challenge-div .warning-text {
            color: var(--warning-color);
        }
        .challenge-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        .challenge-div .challenge-icon {
            color: var(--challenge-description-color); /* Dark brown for icons in challenge divs */
        }
        .modal-content {
            background: var(--bg-color);
            color: var(--text-color);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .btn-custom {
            background-color: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold; /* Make button text bolder */
        }
        .btn-custom:hover, .btn-custom:active, .btn-custom:focus {
            transform: scale(1.02); /* Slightly less pronounced scale */
            box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.25), -3px -3px 6px rgba(255, 255, 255, 0.25); /* Slightly adjusted shadow */
            color: var(--button-text-color);
            background-color: var(--button-color);
            opacity: 0.95; /* Slight dim on hover/active */

        }
        .btn-danger {
            background-color: var(--warning-color); /* Deep red for warnings */
            color: #fff;
            border: none;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2);
        }
        .btn-danger:hover, .btn-danger:active, .btn-danger:focus {
            transform: scale(1.02);
            box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.25), -3px -3px 6px rgba(255, 255, 255, 0.25);
            color: #fff;
        }
        .locked {
            opacity: 0.6; /* Increased opacity slightly */
             filter: grayscale(50%); /* Add grayscale effect */
        }

        canvas {
            display: block;
            margin: 20px auto; /* Add vertical margin */
            max-width: 100%;
            height: auto;
            border-radius: 50%; /* Make the canvas area appear round */
            background-color: rgba(0,0,0,0.1); /* Slight background for canvas area */
            box-shadow: 0 0 15px rgba(0,0,0,0.2); /* Add shadow to canvas */

        }
        header img[src="logo.webp"] {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #profilePhoto {
            width: 45px; /* Slightly larger */
            height: 45px;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
             border: 2px solid var(--button-color); /* Add border */

        }
        h1, h2, h4, .app-container > p { /* Adjust selector if needed */
            color: var(--text-color);
        }
         /* Specific H2 styles for sections */
        #wellnessManager h2, #dailyChallenges h2, #tasksSection h2, #gamePage h2,
        #horoscopeWheelPage h2, #numerologyPathPage h2, #playerProfile h2 {
             color: var(--text-color);
             text-align: center;
             margin-bottom: 20px;
             font-weight: bold; /* Make titles bolder */
         }
         #horoscopeWheelPage h2, #numerologyPathPage h2 { margin-bottom: 15px; }

        h3 {
             color: var(--text-color); /* Default h3 color */
             /* Make specific H3s stand out more */
              border-bottom: 1px solid rgba(var(--button-color-rgb, 255, 215, 0), 0.5); /* Add subtle underline */
              padding-bottom: 5px;
              margin-bottom: 15px;
              font-weight: 600; /* Slightly bolder */

         }
         /* Override H3 color inside challenge divs */
         .challenge-div h3 {
              color: var(--challenge-description-color);
             border-bottom: none; /* Remove underline inside challenge divs */
             padding-bottom: 0;
             margin-bottom: 10px;
         }


        .warning-text {
            color: var(--warning-color); /* Deep red for warnings */
            font-weight: bold;
        }
        .footer-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(78, 52, 46, 0.9); /* Less transparent bg */
            padding: 8px 0; /* Slightly reduced padding */
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -3px 15px rgba(0,0,0,0.25); /* Enhanced shadow */
            backdrop-filter: blur(8px); /* More blur */
            border-top: 1px solid rgba(255, 255, 255, 0.1); /* Subtle top border */

        }
        .footer-nav a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 13px; /* Fine-tuned size */
            text-align: center;
            transition: transform 0.2s, color 0.2s; /* Added color transition */
            flex: 1;
            padding: 5px 0;
            display: flex; /* Use flex for icon + text alignment */
            flex-direction: column; /* Stack icon over text */
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically */
        }

        .footer-nav a:hover {
            transform: translateY(-2px); /* Lift slightly on hover */
            color: var(--button-color); /* Highlight color on hover */
            /* background-color: rgba(255, 255, 255, 0.05); /* More subtle hover bg */
            /* border-radius: 5px; */
        }
         /* Active state for footer? Add manually with JS */
         .footer-nav a.active {
            color: var(--button-color);
             font-weight: bold;
         }

        .footer-nav a i {
            /* display: block; /* Flex handles display */
            font-size: 18px; /* Slightly smaller icon */
            margin-bottom: 2px; /* Fine-tuned margin */
        }
        .task-icon {
            font-size: 1.75em;
            margin-right: 10px;
            color: var(--text-color);
             width: 30px; /* Fixed width for alignment */
        }

        #socialMediaTasks ul {
            list-style-type: none;
            padding: 0;
        }
        #socialMediaTasks li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            flex-wrap: wrap;
            background-color: rgba(0,0,0,0.1); /* Add background to list items */
            padding: 10px 15px; /* Add padding */
            border-radius: 8px; /* Rounded corners */
            border: 1px solid rgba(255,255,255,0.1); /* Subtle border */
        }

         #socialMediaTasks li > div { /* Wrapper for icon/text/link */
             display: flex;
             align-items: center;
             flex-grow: 1; /* Allow text to take available space */
             margin-right: 10px;
             margin-bottom: 5px;
         }
        #socialMediaTasks a {
            color: var(--text-color);
            text-decoration: underline;
            margin-left: 5px;
             word-break: break-all; /* Prevent long links from overflowing */
        }

        #socialMediaTasks a:hover {
             color: var(--button-color); /* Link hover color */
             text-decoration: none;
        }
         #socialMediaTasks button {
             padding: 6px 12px; /* Adjust button size */
             font-size: 0.85em; /* Adjust font size */
             flex-shrink: 0; /* Prevent button from shrinking */

         }

        /* Referral Task Layout */
        #referralTask {
             margin-top: 25px; /* Increased margin */
              background-color: rgba(0,0,0,0.1); /* Add background */
              padding: 15px;
              border-radius: 8px;
              border: 1px solid rgba(255,255,255,0.1);
        }

        #referralTask h3 { /* Adjust referral h3 specifically */
             border-bottom: none;
             padding-bottom: 0;
             margin-bottom: 10px;
        }
        #referralTask p {
             margin-bottom: 15px; /* Increased spacing */
         }
        #referralTask input[type="text"] {
             /* width: calc(100% - 110px); /* Handled by flex */
             background-color: rgba(255, 255, 255, 0.1);
             border: 1px solid rgba(255, 255, 255, 0.3);
             color: var(--text-color);
             padding: 8px;
             border-radius: 5px;
             flex-grow: 1; /* Input takes available space */
             margin-right: 10px;
         }
          #referralTask .d-flex button {
             flex-shrink: 0; /* Prevent button from shrinking */
              padding: 8px 15px; /* Adjust padding */
         }


        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container { padding: 0 10px; padding-bottom: 80px;}
            .section { padding: 20px; margin-bottom: 15px;}
            .challenge-div { padding: 12px; }
            .challenge-icon { font-size: 2em; }
            .btn-custom, .btn-danger { /* Target most buttons */
                margin-bottom: 10px;
                padding: 10px 15px;
            }
            h1 { font-size: 1.6rem; }
             h2 { font-size: 1.4rem; }
             h3 { font-size: 1.2rem; padding-bottom: 4px; margin-bottom: 12px; }
             /* Maintain challenge h3 contrast */
            .challenge-div h3 { font-size: 1.2rem; }
            p { font-size: 0.95rem; }
            .warning-text { font-size: 0.9rem; }
             #socialMediaTasks button {
                 /* Allow button size based on content */
                 margin-left: auto; /* Pushes to right if space */
            }
             #referralTask input[type="text"] {
                 /* Flex handles width */
             }

        }
        @media (max-width: 576px) {
            .footer-nav a { font-size: 11px; } /* Smaller footer text */
            .footer-nav a i { font-size: 16px; margin-bottom: 1px;} /* Smaller footer icons */
             .app-container { padding-bottom: 70px; } /* Reduce padding slightly */
            h1 { font-size: 1.5rem; }
             h2 { font-size: 1.3rem; margin-bottom: 15px; }
             h3 { font-size: 1.1rem; padding-bottom: 3px; margin-bottom: 10px;}
             /* Maintain challenge h3 contrast */
             .challenge-div h3 { font-size: 1.1rem; }
            p { font-size: 0.9rem; } /* Slightly smaller p text */
            .challenge-icon { font-size: 1.8em; } /* Adjusted icon size */

             #socialMediaTasks li { flex-direction: column; align-items: stretch;} /* Stack vertically, stretch content */
             #socialMediaTasks li > div { margin-right: 0; margin-bottom: 8px; } /* No right margin when stacked */
             #socialMediaTasks button { width: 100%; margin-top: 8px; } /* Full width buttons */

             #referralTask { display: flex; flex-direction: column; }
             #referralTask .d-flex { flex-direction: column; } /* Stack input and button */
             #referralTask input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px;}
             #referralTask button { width: 100%; } /* Full width button */

              header { flex-direction: column; text-align: center; margin-bottom: 15px;} /* Stack header, add margin */
              header > div:first-child { margin-bottom: 10px; } /* Space below logo/title */
               #profilePhoto { width: 40px; height: 40px; } /* Smaller photo on small screens */


        }

         /* Loading Style */
        #loading-overlay { /* Renamed ID */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); /* Darker overlay */
            display: flex; justify-content: center;
            align-items: center; z-index: 10001; /* High z-index */
             flex-direction: column;
             color: white;
             opacity: 1;
            transition: opacity 0.5s ease-out; /* Fade out transition */
         }
          #loading-overlay.hidden {
             opacity: 0;
             pointer-events: none; /* Allow clicks through when hidden */
          }

         #loading-overlay p { margin-top: 15px; font-size: 1.1em;}
         .spinner-border { color: white; width: 3rem; height: 3rem;}


        /* Table styling */
        .table {
            color: var(--text-color);
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
             border-collapse: separate;
             border-spacing: 0;
        }
         .table th, .table td {
            border-top: 1px solid rgba(255, 255, 255, 0.15); /* Slightly more visible border */
            padding: 0.6rem 0.5rem;
            vertical-align: middle;
             text-align: center; /* Center table text */
         }
        .table thead th {
             color: var(--button-color);
             background-color: rgba(0, 0, 0, 0.4);
             border-top: none;
             border-bottom: 2px solid var(--button-color);
             font-weight: bold;
             white-space: nowrap; /* Prevent header wrapping */
         }
        .table tbody tr:first-child td {
             border-top: none;
         }
        .table tbody tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
         .table img {
             max-width: 35px; /* Slightly smaller images */
             height: auto;
             border-radius: 4px;
             display: inline-block; /* Center image if needed */
         }
        .table-primary td,
        .table tr.table-primary td {
             background-color: rgba(var(--button-color-rgb, 255, 215, 0), 0.15) !important; /* Subtler highlight using button color base */
              font-weight: bold; /* Bold text in highlighted row */
         }
         .table-responsive {
             border-radius: 10px;
         }
         .table-sm th, .table-sm td {
            padding: 0.4rem 0.4rem;
         }
        /* Center align proof icons */
        #profileHistory td .fa-check { color: #28a745; }
        #profileHistory td .fa-times { color: #dc3545; }

         /* Modal Styling Enhancements */
        .modal-header, .modal-footer {
            border: none;
        }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%); }
        .form-range::-webkit-slider-thumb { background-color: var(--button-color); }
        .form-range::-moz-range-thumb { background-color: var(--button-color); }
         .form-control-sm { font-size: 0.875rem; } /* Ensure file inputs are reasonably sized */


    </style>
</head>
<body>
    <video id="backgroundVideo" autoplay muted loop playsinline poster="fallback-image.jpg"> <!-- Optional: Added poster -->
        <source src="cosmic.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <!-- Loading Overlay -->
     <div id="loading-overlay">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p>Loading Your Cosmic Journey...</p>
    </div>


    <div class="app-container">
        <header class="d-flex justify-content-between align-items-center py-3">
            <div class="d-flex align-items-center">
                <img src="logo.webp" alt="Logo">
                <h1 style="margin: 0; font-size: 1.8rem;">Third Eye</h1>
            </div>
            <div class="d-flex align-items-center flex-column text-center" id="profileLink">
                <img id="profilePhoto" src="https://via.placeholder.com/45" alt="Profile"> <!-- Default src -->
                <span id="profileNameDisplay" style="margin-top: 5px; font-size: 0.9rem; line-height: 1.1;">Guest</span>
                <span id="pointsDisplay" style="font-size: 0.9rem; color: var(--button-color); font-weight: bold;">0 $twote</span>
            </div>
        </header>

        <!-- Sections -->
        <div id="horoscopeForm" class="section">
            <h2>Enter Your Birthdate</h2>
            <p>To personalize your journey.</p>
            <input type="date" id="birthdate" class="form-control mb-2">
            <button class="btn btn-custom w-100" id="saveHoroscopeBtn">Save & Continue</button>
        </div>

        <div id="wellnessManager" class="section">
            <h2>Mindfulness Journey</h2>
            <p style="text-align: center;">Select a challenge duration to begin.</p>
            <div id="challengeOptions" class="mt-3"></div>
        </div>

        <div id="dailyChallenges" class="section">
            <h2 id="challengeTitle">Challenge</h2>
            <div id="dailyChallengeList"></div>
        </div>

        <div id="tasksSection" class="section">
            <h2>Earn More $twote</h2>
             <div id="socialMediaTasks">
                 <h3>Social Tasks</h3>
                 <ul>
                     <li>
                         <div><i class="fab fa-telegram-plane task-icon"></i>Join <a href="https://t.me/ThirdEyeCommunity" target="_blank" rel="noopener noreferrer">Telegram</a></div>
                         <button class="btn btn-custom" id="telegramTaskBtn" onclick="completeTask('telegram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-twitter task-icon"></i>Follow <a href="https://twitter.com/ThirdEyeApp" target="_blank" rel="noopener noreferrer">Twitter</a></div>
                         <button class="btn btn-custom" id="twitterTaskBtn" onclick="completeTask('twitter')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-instagram task-icon"></i>Follow <a href="https://instagram.com/ThirdEyeApp" target="_blank" rel="noopener noreferrer">Instagram</a></div>
                         <button class="btn btn-custom" id="instagramTaskBtn" onclick="completeTask('instagram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-youtube task-icon"></i>Subscribe <a href="https://youtube.com/@ThirdEyeChannel" target="_blank" rel="noopener noreferrer">YouTube</a></div>
                         <button class="btn btn-custom" id="youtubeTaskBtn" onclick="completeTask('youtube')">Verify</button>
                     </li>
                 </ul>
             </div>
             <div id="referralTask" class="mt-4">
                 <h3>Referral Task</h3>
                 <p>Share your link! Both you and your friend earn $twote.</p>
                 <div class="d-flex">
                     <input type="text" id="referralLink" class="form-control" readonly style="flex-grow: 1; margin-right: 10px;">
                     <button class="btn btn-custom" onclick="copyReferralLink()">Copy</button>
                 </div>
             </div>
        </div>

        <div id="gamePage" class="section">
            <h2>Daily Activities</h2>
            <div class="text-center mb-3">
                <button class="btn btn-custom" id="dailyCheckInBtn">Daily Check-In</button>
                <p id="countdownDisplay" style="color: var(--button-color); margin-top: 10px; font-size: 0.9em; min-height: 1.2em;"></p> <!-- Added min-height -->
            </div>
            <div class="d-grid gap-2">
                <button class="btn btn-custom" id="playHoroscopeWheel">ðŸ“Š Play Horoscope Wheel</button>
                <button class="btn btn-custom" id="playNumerologyPath">ðŸ”¢ Play Numerology Path</button>
            </div>
        </div>

        <div id="horoscopeWheelPage" class="section">
            <h2>Horoscope Wheel</h2>
            <canvas id="astrologyWheelCanvas" width="300" height="300"></canvas>
            <p id="astrologyMessage" class="text-center mt-3" style="min-height: 40px; color: var(--text-color);"></p> <!-- Ensure text color -->
            <div class="text-center mt-3">
                 <button class="btn btn-custom" id="spinWheel">Spin the Wheel</button>
            </div>
        </div>

        <div id="numerologyPathPage" class="section">
            <h2>Numerology Path</h2>
            <p id="numerologyMessage" class="text-center" style="min-height: 40px; color: var(--text-color);">Select a number to reveal your path!</p> <!-- Ensure text color -->
            <div id="numberGrid" class="text-center mt-3 d-flex flex-wrap justify-content-center"></div> <!-- Flex wrap for numbers -->
        </div>

        <div id="playerProfile" class="section">
            <h2>Player Profile</h2>
            <div class="text-center mb-3">
                <p>Welcome, <strong id="profileNameDisplayInner" style="color: var(--button-color);">Guest</strong>!</p>
                <div id="energyLevel">Energy Level: <span id="energyValue" style="color: var(--button-color); font-weight:bold;">0</span>%</div>
                <div id="pointsProfileDisplay">Points: <span id="pointsValue" style="color: var(--button-color); font-weight:bold;">0</span> $twote</div>
                <div id="consecutiveDaysDisplay">Consecutive Days: <span id="consecutiveDaysValue" style="color: var(--button-color); font-weight:bold;">0</span></div>
            </div>
             <div class="d-grid gap-2 mb-4">
                 <button class="btn btn-custom" id="connectWalletBtn">Connect Wallet (Soon)</button>
                 <button class="btn btn-custom" id="airdropWithdrawBtn">Withdraw $twote (Soon)</button>
             </div>

            <h3>Challenge History</h3>
            <div class="table-responsive">
                <table class="table table-sm">
                    <thead><tr><th>Day</th><th>Goal</th><th>NRG In</th><th>NRG Out</th><th>T1 Proof</th><th>T2 Proof</th></tr></thead>
                    <tbody id="profileHistory"></tbody>
                </table>
            </div>

            <h3 class="mt-4">Leaderboard (Top 100)</h3>
             <div class="table-responsive">
                 <table class="table table-sm">
                     <thead><tr><th>Rank</th><th>Name</th><th>Points ($twote)</th></tr></thead>
                     <tbody id="leaderboard"></tbody>
                 </table>
             </div>
             <div class="text-center mt-4">
                 <button class="btn btn-danger mt-3" id="deleteProgressBtn">Delete Progress</button>
             </div>
        </div>
    </div> <!-- End app-container -->

    <nav class="footer-nav">
        <a href="#" id="navHome" class="active"><i class="fas fa-home"></i>Journey</a>
        <a href="#" id="navTasks"><i class="fas fa-tasks"></i>Tasks</a>
        <a href="#" id="navGame"><i class="fas fa-dice"></i>Activity</a>
        <a href="#" id="navProfile"><i class="fas fa-user-astronaut"></i>Profile</a>
    </nav>

    <!-- Modals -->
    <div class="modal fade" id="energyLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="energyLogModalTitle">Energy Log</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p id="energyLogPrompt">How positive is your mind frame?</p>
                    <div class="d-flex align-items-center my-3">
                         <input type="range" min="0" max="100" value="50" class="form-range flex-grow-1 me-3" id="energySlider">
                         <span id="energySliderValue" style="color: var(--button-color); font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                    </div>
                    <div id="challengeTasks" style="display: none; margin-top: 20px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;">
                        <p class="mb-2"><strong>Meditation:</strong> <span id="meditationTask" style="font-style: italic;"></span></p>
                        <p class="mb-1"><strong>Task 1:</strong> <span id="task1Text"></span></p>
                        <input type="file" id="task1Proof" class="form-control form-control-sm mb-2" accept="image/*">
                        <p class="mb-1"><strong>Task 2:</strong> <span id="task2Text"></span></p>
                        <input type="file" id="task2Proof" class="form-control form-control-sm" accept="image/*">
                        <p class="mt-3 text-center warning-text" id="proofWarning" style="display: none; font-size: 0.9em;">Please upload proof for both tasks.</p>
                    </div>
                </div>
                <div class="modal-footer justify-content-center">
                    <button class="btn btn-custom w-50" id="submitEnergyLog" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="enrollModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enroll in Workshop</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                     <p><strong>Name:</strong> <span id="enrollName"></span></p>
                     <p><strong>Horoscope:</strong> <span id="enrollHoroscope"></span></p>
                     <p><strong>Energy Level:</strong> <span id="enrollEnergy" style="color: var(--button-color); font-weight: bold;"></span>%</p>
                     <p id="enrollRequirement" class="warning-text" style="font-size: 0.9em; display: none;">Requires 70% Energy</p>
                     <button class="btn btn-custom mt-3 w-50" id="submitEnrollment" disabled>Submit Enrollment</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="codeModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title">Enter Workshop Code</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body">
                     <input type="text" id="workshopCode" class="form-control mb-3" placeholder="Enter code">
                      <div class="text-center">
                          <button class="btn btn-custom w-50" id="submitCode">Submit</button>
                      </div>
                 </div>
             </div>
         </div>
     </div>

    <!-- Toast Container for Notifications -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100"></div> <!-- Ensure toast is above footer -->

    <!-- Defer script loading -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" defer></script>
    <script>
        // --- Constants ---
        const dailyGoals = [
            { goal: "Wealth", meditation: "Visualize abundance flowing.", task1: "Write 3 specific financial goals.", task2: "Review budget or track spending.", points: 5 },
            { goal: "Peace", meditation: "Focus on your breath, find stillness.", task1: "List 5 things you are grateful for.", task2: "Engage in 5 minutes of slow breathing.", points: 5 },
            { goal: "Focus", meditation: "Sharpen your concentration.", task1: "Identify your top 3 priorities for the day.", task2: "Dedicate 25 min (Pomodoro) to one task.", points: 5 },
            { goal: "Creativity", meditation: "Open your mind to inspiration.", task1: "Brainstorm 5 new ideas (any topic).", task2: "Sketch, write, or doodle for 10 min.", points: 5 },
            { goal: "Confidence", meditation: "Affirm your strengths.", task1: "List 3 positive qualities about yourself.", task2: "Practice a power pose for 2 minutes.", points: 5 },
            { goal: "Energy", meditation: "Visualize vibrant energy.", task1: "Drink a glass of water mindfully.", task2: "Do 5 minutes of stretching or light exercise.", points: 5 },
            { goal: "Gratitude", meditation: "Cultivate thankfulness.", task1: "Write down 3 things that made you smile today.", task2: "Send a brief thank-you message to someone.", points: 5 }
        ];
        const zodiacOrder = [ // Added colors for wheel segments
            { sign: "Aries", symbol: "â™ˆ", points: 5, color: "#FF4500" }, { sign: "Taurus", symbol: "â™‰", points: 4, color: "#2E8B57" }, { sign: "Gemini", symbol: "â™Š", points: 3, color: "#FFD700" },
            { sign: "Cancer", symbol: "â™‹", points: 2, color: "#B0C4DE" }, { sign: "Leo", symbol: "â™Œ", points: 5, color: "#FFA500" }, { sign: "Virgo", symbol: "â™", points: 4, color: "#8FBC8F" },
            { sign: "Libra", symbol: "â™Ž", points: 3, color: "#FFB6C1" }, { sign: "Scorpio", symbol: "â™", points: 2, color: "#8B0000" }, { sign: "Sagittarius", symbol: "â™", points: 5, color: "#9370DB" },
            { sign: "Capricorn", symbol: "â™‘", points: 4, color: "#708090" }, { sign: "Aquarius", symbol: "â™’", points: 3, color: "#00BFFF" }, { sign: "Pisces", symbol: "â™“", points: 2, color: "#4682B4" }
        ];
        const astrologyInsights = {
            "Aries": "Channel your fiery energy into action.", "Taurus": "Find comfort in grounding routines.", "Gemini": "Express your thoughts clearly today.",
            "Cancer": "Trust your intuition and nurture yourself.", "Leo": "Let your creativity shine brightly.", "Virgo": "Focus on details and organization.",
            "Libra": "Seek balance and harmony in relationships.", "Scorpio": "Embrace transformation and let go.", "Sagittarius": "Adventure awaits, explore new ideas.",
            "Capricorn": "Disciplined effort leads to rewards.", "Aquarius": "Innovate and connect with your community.", "Pisces": "Tap into your empathy and imagination."
        };
        const numerologyInsights = {
            1: "New beginnings and leadership.", 2: "Cooperation and diplomacy.", 3: "Creativity and self-expression.",
            4: "Structure and stability.", 5: "Freedom and change.", 6: "Harmony and responsibility.",
            7: "Introspection and wisdom.", 8: "Abundance and personal power.", 9: "Completion and humanitarianism."
        };
        const SECTION_IDS = ['horoscopeForm', 'wellnessManager', 'dailyChallenges', 'tasksSection', 'gamePage', 'horoscopeWheelPage', 'numerologyPathPage', 'playerProfile'];
        const DEFAULT_PHOTO_URL = 'https://via.placeholder.com/45';
        const CLOUD_STORAGE_KEYS = [
             'energyLevel', 'points', 'challenges', 'challengeHistory', 'birthdate',
             'consecutiveDays', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks',
             'workshopAccess', 'leaderboard'
        ];
        const BOT_USERNAME = "ThirdEyeTestDevBot"; // <-- !!! Replace with your ACTUAL bot username !!!

        // --- Global State & Variables ---
        let state = {};
        let sectionStack = []; // Managed dynamically
        let domElements = {};
        let modalInstances = {}; // Store modal instances
        let telegramApp = null;
        let isSpinning = false;
        let numerologyPlayed = false;
        let currentWheelAngle = 0; // Store current angle for smooth rotation redraw
        let checkinCountdownInterval = null; // Store interval ID

        // --- Utility Functions ---
        function showNotification(message, type = 'info') {
             try {
                const toastContainer = document.querySelector('.toast-container');
                if (!toastContainer) return; // Exit if container not found
                const toast = document.createElement('div');
                // Use bg-* for background color
                const bgClass = type === 'error' ? 'bg-danger' : (type === 'success' ? 'bg-success' : 'bg-primary');
                 toast.className = `toast align-items-center text-white ${bgClass} border-0`; // Ensure text is white
                toast.setAttribute('role', 'alert');
                toast.setAttribute('aria-live', 'assertive');
                toast.setAttribute('aria-atomic', 'true');
                toast.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                `;
                 toastContainer.appendChild(toast);
                const bsToast = new bootstrap.Toast(toast, { delay: 3500 }); // Slightly longer delay
                 bsToast.show();
                 toast.addEventListener('hidden.bs.toast', () => toast.remove());
             } catch (error) {
                 console.error("ShowNotification error:", error, message);
             }
        }

         function hideLoadingOverlay() {
            const overlay = domElements.loadingOverlay;
            if (overlay) {
                overlay.classList.add('hidden');
                // Optional: Remove after transition completes
                // setTimeout(() => { overlay.style.display = 'none'; }, 500);
            }
        }

         // --- DOM Ready Event ---
         document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Loaded. Initializing...");
             // Cache DOM elements
             const ids = [...SECTION_IDS, 'profilePhoto', 'profileNameDisplay', 'profileNameDisplayInner', 'pointsDisplay',
                          'pointsValue', 'consecutiveDaysValue', 'energyValue', 'challengeOptions',
                          'dailyChallengeList', 'challengeTitle', 'energyLogPrompt', 'energySlider',
                          'energySliderValue', 'challengeTasks', 'meditationTask', 'task1Text',
                          'task2Text', 'task1Proof', 'task2Proof', 'submitEnergyLog', 'profileHistory',
                          'astrologyMessage', 'numerologyMessage', 'numberGrid', 'referralLink',
                          'dailyCheckInBtn', 'countdownDisplay', 'leaderboard', 'enrollName',
                          'enrollHoroscope', 'enrollEnergy', 'submitEnrollment', 'workshopCode',
                          'submitCode', 'proofWarning', 'enrollRequirement', 'energyLogModal',
                          'enrollModal', 'codeModal', 'loading-overlay', 'astrologyWheelCanvas', // Added canvas explicitly
                          'spinWheel', // Added spin button
                          ];
            ids.forEach(id => domElements[id] = document.getElementById(id));

            // Initialize Modals
             if (domElements.energyLogModal) modalInstances.energyLog = new bootstrap.Modal(domElements.energyLogModal);
             if (domElements.enrollModal) modalInstances.enroll = new bootstrap.Modal(domElements.enrollModal);
             if (domElements.codeModal) modalInstances.code = new bootstrap.Modal(domElements.codeModal);


            initializeApp(); // Start the main initialization
            setupEventListeners(); // Setup event listeners
        });

        // --- Initialization ---
        function initializeState() {
            console.log("Initializing default state.");
            const defaultLeaderboard = [
                { userId: 'bot1', name: 'Cosmic Guide', points: 150 },
                { userId: 'bot2', name: 'Zen Master', points: 120 },
                { userId: 'bot3', name: 'Astro Explorer', points: 110 },
            ];
            return {
                userId: null,
                userName: "Guest",
                userPhoto: DEFAULT_PHOTO_URL,
                energyLevel: 0,
                points: 0,
                challenges: [],
                challengeHistory: [],
                birthdate: null,
                consecutiveDays: 0,
                lastPlayedDate: null,
                lastCheckInTime: null,
                completedTasks: [],
                workshopAccess: false,
                currentChallengeDuration: null,
                currentChallengeDay: null,
                energyBefore: null,
                leaderboard: defaultLeaderboard,
                isLoading: true,
                storageType: 'none' // 'cloud' or 'local'
            };
        }

         function initializeApp() {
             console.log("Starting App Initialization...");
             state = initializeState();

             // Attempt to initialize Telegram WebApp
             try {
                telegramApp = window.Telegram?.WebApp;
                 if (telegramApp && telegramApp.initData) {
                     telegramApp.ready();
                     telegramApp.expand();
                     console.log("Telegram WebApp SDK initialized.");

                     const user = telegramApp.initDataUnsafe?.user;
                     if (user && user.id) {
                         state.userId = user.id.toString();
                         state.userName = user.first_name || "User";
                         // Only update photo if a valid URL is provided
                          if (user.photo_url) {
                             state.userPhoto = user.photo_url;
                         } else {
                             state.userPhoto = DEFAULT_PHOTO_URL; // Ensure default if TG provides no photo
                         }
                         console.log(`Telegram User: ID=${state.userId}, Name=${state.userName}`);
                     } else {
                         console.warn("Telegram user data incomplete or missing ID.");
                         state.userId = `guest_${Date.now()}`; // Fallback temporary ID
                     }

                     // Apply Theme (safe call)
                     setTheme();

                     // Try Cloud Storage
                     initCloudStorage();

                 } else {
                    console.warn("Telegram WebApp SDK not available or no initData. Falling back to Local Storage.");
                    initLocalStorage(); // Fallback
                 }
             } catch (error) {
                 console.error("Error during Telegram WebApp initialization:", error);
                 showNotification("Error initializing Telegram features.", "error");
                 initLocalStorage(); // Fallback on error
             }
        }


         function setTheme() {
             if (!telegramApp || !telegramApp.themeParams) return;
             try {
                 const theme = telegramApp.themeParams;
                 console.log("Applying Telegram theme:", theme);
                 const rootStyle = document.documentElement.style;
                 if (theme.bg_color) rootStyle.setProperty('--bg-color', theme.bg_color);
                 if (theme.text_color) rootStyle.setProperty('--text-color', theme.text_color);
                 if (theme.button_color) rootStyle.setProperty('--button-color', theme.button_color);
                 if (theme.button_text_color) rootStyle.setProperty('--button-text-color', theme.button_text_color);
             } catch (error) {
                 console.error("Error applying Telegram theme:", error);
             }
         }


        // --- Data Storage ---
        async function initCloudStorage() {
             state.storageType = 'cloud';
             console.log("Initializing with Cloud Storage for user:", state.userId);

             try {
                // Fetch all keys simultaneously
                 const items = await telegramApp.CloudStorage.getItems(CLOUD_STORAGE_KEYS);
                 console.log("CloudStorage getItems result:", items);

                // Apply fetched data carefully, checking for null/undefined
                 state.energyLevel = parseInt(items.energyLevel || '0') || 0;
                 state.points = parseInt(items.points || '0') || 0; // Ensure points default to 0 on parse error
                 state.challenges = items.challenges ? JSON.parse(items.challenges) : initializeChallenges();
                 state.challengeHistory = items.challengeHistory ? JSON.parse(items.challengeHistory) : [];
                 state.birthdate = items.birthdate || null;
                 state.consecutiveDays = parseInt(items.consecutiveDays || '0') || 0;
                 state.lastPlayedDate = items.lastPlayedDate || null;
                 state.lastCheckInTime = items.lastCheckInTime ? parseInt(items.lastCheckInTime) : null;
                 state.completedTasks = items.completedTasks ? JSON.parse(items.completedTasks) : [];
                 state.workshopAccess = items.workshopAccess === 'true';

                const savedLeaderboard = items.leaderboard ? JSON.parse(items.leaderboard) : [];
                state.leaderboard = mergeLeaderboards(state.leaderboard, savedLeaderboard);
                 ensureUserInLeaderboard(); // Important: Ensure user exists and points sync

                // If core data like challenges/leaderboard wasn't found, initialize and save
                 let needsSave = false;
                 if (!items.challenges) {
                     console.log("No challenges found in CloudStorage, saving defaults.");
                     needsSave = true;
                 }
                 if (!items.leaderboard) {
                     console.log("No leaderboard found, saving defaults.");
                     needsSave = true;
                 }
                // Make sure initial leaderboard always contains the current user after loading
                if (!state.leaderboard.find(p => p.userId === state.userId)) {
                    ensureUserInLeaderboard();
                    needsSave = true;
                }

                if (needsSave) await saveStateToCloud(); // Save only if necessary

                 console.log("State after CloudStorage load:", JSON.parse(JSON.stringify(state)));
                 finishInitialization();

             } catch (error) {
                console.error("Error loading data from CloudStorage:", error);
                showNotification('Failed to load data from cloud. Using defaults/local.', 'error');
                // Critical failure, attempt fallback to LocalStorage or just use defaults
                // For simplicity here, we will fallback to trying LocalStorage
                 initLocalStorage(); // Fallback to local if cloud fails
            }
        }

        function initLocalStorage() {
             state.storageType = 'local';
            console.log("Initializing with Local Storage.");
             if (!state.userId) state.userId = localStorage.getItem('userId') || `local_${Date.now()}`; // Ensure userId exists for local
             localStorage.setItem('userId', state.userId); // Save potentially generated ID

             try {
                 state.energyLevel = parseInt(localStorage.getItem('energyLevel') || '0') || 0;
                 state.points = parseInt(localStorage.getItem('points') || '0') || 0; // Ensure default
                 state.challenges = JSON.parse(localStorage.getItem('challenges') || 'null') || initializeChallenges();
                 state.challengeHistory = JSON.parse(localStorage.getItem('challengeHistory') || '[]');
                 state.birthdate = localStorage.getItem('birthdate') || null;
                 state.consecutiveDays = parseInt(localStorage.getItem('consecutiveDays') || '0') || 0;
                 state.lastPlayedDate = localStorage.getItem('lastPlayedDate') || null;
                 state.lastCheckInTime = localStorage.getItem('lastCheckInTime') ? parseInt(localStorage.getItem('lastCheckInTime')) : null;
                 state.completedTasks = JSON.parse(localStorage.getItem('completedTasks') || '[]');
                 state.workshopAccess = localStorage.getItem('workshopAccess') === 'true';

                const savedLeaderboard = JSON.parse(localStorage.getItem('leaderboard') || 'null') || [];
                 state.leaderboard = mergeLeaderboards(state.leaderboard, savedLeaderboard);
                ensureUserInLeaderboard(); // Ensure user exists and points sync


                 if (!localStorage.getItem('challenges')) {
                     localStorage.setItem('challenges', JSON.stringify(state.challenges));
                 }
                 if (!localStorage.getItem('leaderboard')) {
                     localStorage.setItem('leaderboard', JSON.stringify(state.leaderboard));
                 }

                 console.log("State after LocalStorage load:", JSON.parse(JSON.stringify(state)));
                finishInitialization();

             } catch (error) {
                 console.error('Error loading data from LocalStorage:', error);
                 showNotification('Failed to load local data. Using defaults.', 'error');
                 // Last resort: Use purely default state
                 state.challenges = initializeChallenges();
                 ensureUserInLeaderboard();
                finishInitialization(); // Still finish init with defaults
             }
        }

        // Centralized function called after data load (cloud or local)
        function finishInitialization() {
             console.log("Finishing initialization: Checking daily reset, updating UI.");
             checkDailyReset();
             updateUI();
             startCountdown();
             showInitialSection();
             state.isLoading = false;
             hideLoadingOverlay();
        }

        async function saveStateToCloud(keys = CLOUD_STORAGE_KEYS) { // Default to save all keys
             if (state.storageType !== 'cloud' || !telegramApp || !telegramApp.CloudStorage || state.isLoading) return;
             console.log(`Saving keys to CloudStorage: ${keys.join(', ')}`);
             const dataToSave = {};
             keys.forEach(key => {
                 const value = state[key];
                 if (typeof value === 'object' && value !== null) {
                     dataToSave[key] = JSON.stringify(value);
                 } else if (value !== null && value !== undefined) {
                     dataToSave[key] = String(value); // Ensure value is string
                 }
                 // Implicitly handle removal if key is not present (or value is null/undefined)? TG API might just ignore these keys
             });

             try {
                 await telegramApp.CloudStorage.save(dataToSave);
                 console.log("CloudStorage save successful for keys:", Object.keys(dataToSave));
             } catch (error) {
                 console.error("Error saving state to CloudStorage:", error);
                 showNotification(`Error saving data: ${error.message || error}`, 'error');
             }
        }

        function saveStateToLocal(keys = CLOUD_STORAGE_KEYS) { // Default to save all keys
             if (state.storageType !== 'local' || state.isLoading) return;
             console.log(`Saving keys to LocalStorage: ${keys.join(', ')}`);
             keys.forEach(key => {
                 try {
                     const value = state[key];
                     if (value === null || value === undefined) {
                         localStorage.removeItem(key);
                         // console.log(`Removed ${key} from LocalStorage.`);
                     } else if (typeof value === 'object') {
                         localStorage.setItem(key, JSON.stringify(value));
                     } else {
                         localStorage.setItem(key, String(value));
                     }
                 } catch (error) {
                     console.error(`Error saving ${key} to LocalStorage:`, error);
                     showNotification(`Error saving ${key}`, 'error');
                 }
             });
             // console.log("LocalStorage save completed.");
        }

        // Helper to save data based on storage type
        async function saveData(keys = CLOUD_STORAGE_KEYS) {
             if (state.storageType === 'cloud') {
                 await saveStateToCloud(keys);
             } else if (state.storageType === 'local') {
                 saveStateToLocal(keys);
             }
        }


        function mergeLeaderboards(defaultBoard, savedBoard) {
             const mergedMap = new Map();
            // Add defaults first
            defaultBoard.forEach(user => mergedMap.set(user.userId, { ...user }));
            // Add/update with saved data
            savedBoard.forEach(user => mergedMap.set(user.userId, { ...user }));
             return Array.from(mergedMap.values());
         }

        function ensureUserInLeaderboard() {
            let userEntry = state.leaderboard.find(p => p.userId === state.userId);
             if (!userEntry) {
                 console.log(`User ${state.userId} not found in leaderboard, adding.`);
                 userEntry = { userId: state.userId, name: state.userName, points: state.points };
                 state.leaderboard.push(userEntry);
                // No immediate save needed, will be saved with points updates
             } else {
                // Sync leaderboard points with current state points *IF* different
                 if (userEntry.points !== state.points) {
                     console.log(`Syncing leaderboard points for user ${state.userId} from ${userEntry.points} to ${state.points}`);
                     userEntry.points = state.points;
                    // No immediate save needed here, leaderboard saves when points are awarded/state saves
                 }
                 // Sync leaderboard name/photo? Maybe less critical
                 if (userEntry.name !== state.userName) userEntry.name = state.userName;
                 // if (userEntry.photo !== state.userPhoto) userEntry.photo = state.userPhoto;
             }
         }


        // --- UI Management ---
         function updateUI() {
            console.log("Updating UI elements...");
             domElements.profilePhoto.src = state.userPhoto || DEFAULT_PHOTO_URL; // Fallback src
             domElements.profileNameDisplay.textContent = state.userName || 'Guest';
             domElements.profileNameDisplayInner.textContent = state.userName || 'Guest';
             domElements.pointsDisplay.textContent = `${state.points || 0} $twote`;
             domElements.pointsValue.textContent = state.points || 0;
             domElements.consecutiveDaysValue.textContent = state.consecutiveDays || 0;
             domElements.energyValue.textContent = state.energyLevel || 0;
             if (state.userId) {
                 domElements.referralLink.value = `https://t.me/${BOT_USERNAME}?start=${state.userId}`;
             } else {
                 domElements.referralLink.value = 'Link available after login';
             }
             updateDailyCheckInButtonState();
             updateLeaderboard(); // Update leaderboard display
             updateTaskButtons();
            // Ensure correct profile picture also updates on profile page if needed (using same ID)
         }


         function updateDailyCheckInButtonState() {
             if (!domElements.dailyCheckInBtn) return;
             const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
             const canCheckIn = !state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours);

             if (canCheckIn) {
                 domElements.dailyCheckInBtn.disabled = false;
                 domElements.dailyCheckInBtn.textContent = "Daily Check-In";
                 if (domElements.countdownDisplay) domElements.countdownDisplay.textContent = ''; // Clear countdown
                 if (checkinCountdownInterval) { clearInterval(checkinCountdownInterval); checkinCountdownInterval = null;} // Stop interval if running

             } else {
                 domElements.dailyCheckInBtn.disabled = true;
                 domElements.dailyCheckInBtn.textContent = "Checked In";
                 startCountdown(); // Ensure countdown starts/continues
             }
         }

         function showInitialSection() {
             const firstSection = state.birthdate ? 'wellnessManager' : 'horoscopeForm';
             sectionStack = [firstSection]; // Reset stack
             showSection(firstSection, true); // Show without adding to stack again
              // Update footer active state
              updateFooterNav(firstSection);

         }

        function showSection(sectionId, isInitial = false) {
             // Ensure valid sectionId
            if (!SECTION_IDS.includes(sectionId)) {
                 console.error(`Invalid section ID requested: ${sectionId}`);
                 sectionId = 'wellnessManager'; // Fallback to default
            }


             // Manage section stack for back button navigation
            if (!isInitial) {
                // Prevent pushing the same section consecutively
                if (sectionStack[sectionStack.length - 1] !== sectionId) {
                    sectionStack.push(sectionId);
                }
            } else {
                // If it's an initial load or explicit back navigation, set the stack
                sectionStack = [sectionId]; // Usually just the target section
            }

             console.log("Showing section:", sectionId, "Stack:", sectionStack);

            // Update section visibility using CSS classes
            SECTION_IDS.forEach(id => {
                const el = domElements[id];
                 if (el) {
                    el.classList.toggle('active', id === sectionId);
                 }
            });


             // Update Telegram back button visibility
             if (telegramApp && telegramApp.BackButton) {
                 if (sectionStack.length > 1) {
                     telegramApp.BackButton.show();
                 } else {
                     telegramApp.BackButton.hide();
                 }
             }

            // Update footer active state
            updateFooterNav(sectionId);

             // Trigger section-specific loading/refresh logic AFTER display change
              requestAnimationFrame(() => { // Ensure display is updated before drawing/loading
                 switch (sectionId) {
                     case 'wellnessManager': loadChallenges(); break;
                     case 'dailyChallenges': if(state.currentChallengeDuration) displayDailyChallenges(state.currentChallengeDuration); break;
                     case 'playerProfile': loadProfileHistory(); updateLeaderboard(); break; // Reload history/leaderboard
                     case 'horoscopeWheelPage': drawAstrologyWheel(); break; // Draw wheel when section shown
                     case 'numerologyPathPage': initNumerologyPath(); break; // Init numerology when section shown
                 }
             });

         }

        function handleBackButton() {
             console.log("Back button clicked. Stack before pop:", [...sectionStack]);
             if (sectionStack.length > 1) {
                 sectionStack.pop(); // Remove current
                 const previousSection = sectionStack[sectionStack.length - 1]; // Get new top
                 console.log("Navigating back to:", previousSection);
                 // Show previous section, treat as initial load for stack purposes (don't push again)
                 showSection(previousSection, true);
             } else {
                 console.log("Back button clicked, but stack is at root.");
                 // Optionally close the web app
                  // if (telegramApp) telegramApp.close();
             }
         }
        // Setup Telegram Back Button listener
        if (window.Telegram?.WebApp?.BackButton) {
             window.Telegram.WebApp.BackButton.onClick(handleBackButton);
         } else {
            // If loaded before TG script, retry after a delay? Less ideal.
             console.warn("Telegram BackButton not immediately available for binding.");
        }

         function updateFooterNav(activeSectionId) {
             const mapping = {
                 'wellnessManager': 'navHome',
                 'dailyChallenges': 'navHome', // Also map challenges to home
                 'tasksSection': 'navTasks',
                 'gamePage': 'navGame',
                 'horoscopeWheelPage': 'navGame', // Map games to game tab
                 'numerologyPathPage': 'navGame',
                 'playerProfile': 'navProfile',
                 'horoscopeForm': null // No active footer for setup
             };
             const activeNavId = mapping[activeSectionId];

             document.querySelectorAll('.footer-nav a').forEach(link => {
                 link.classList.toggle('active', link.id === activeNavId);
             });
         }

        // --- Feature Logic (Horoscope, Challenges, Energy, Points, Games etc.) ---

         async function saveHoroscope() {
             const birthdateInput = domElements.birthdate;
             const birthdate = birthdateInput.value;
             if (birthdate && /^\d{4}-\d{2}-\d{2}$/.test(birthdate)) { // Basic format check
                 state.birthdate = birthdate;
                 await saveData(['birthdate']);
                 showSection('wellnessManager');
             } else {
                 showNotification('Please enter a valid birthdate (YYYY-MM-DD).', 'error');
                 birthdateInput.focus();
             }
         }

         async function updateEnergyLevel(before = null, after = null) {
             if (before !== null && after !== null) {
                 state.energyLevel = Math.min(Math.max(Math.round((before + after) / 2), 0), 100);
                 console.log("Updating energy level to:", state.energyLevel);
                 domElements.energyValue.textContent = state.energyLevel;
                 await saveData(['energyLevel']);
             }
         }

         async function awardPoints(amount) {
             if (!amount || amount <= 0 || isNaN(amount)) return;
             amount = Math.round(amount); // Ensure integer

             state.points = (state.points || 0) + amount; // Ensure state.points is a number
             console.log(`Awarded ${amount} points. New total: ${state.points}`);
             ensureUserInLeaderboard(); // Ensure user exists and sync points

             // Update UI immediately for responsiveness
             domElements.pointsDisplay.textContent = `${state.points} $twote`;
             domElements.pointsValue.textContent = state.points;
              updateLeaderboard(); // Update leaderboard display too


             // Save points and leaderboard state
              // Debounce saving? Or save immediately? Let's save immediately for now.
             await saveData(['points', 'leaderboard']);

              // Use a success-styled notification
             showNotification(`+${amount} $twote! âœ¨`, 'success');
         }


         function checkDailyReset() {
             const today = new Date().toISOString().split('T')[0];
             console.log(`Check Daily Reset: Today=${today}, LastPlayed=${state.lastPlayedDate}`);
             if (!state.lastPlayedDate) {
                 state.consecutiveDays = 0; // No history, reset streak
                 return;
             }
             if (state.lastPlayedDate === today) return; // Already played today

             const todayDate = new Date(today);
             const lastPlayedDateObj = new Date(state.lastPlayedDate);
             const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
             const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

             if (diffDays > 1) {
                console.log(`Streak broken (${diffDays} days). Resetting streak.`);
                state.consecutiveDays = 0;
                saveData(['consecutiveDays']); // Save the reset streak
             } else if (diffDays === 1) {
                console.log("Eligible for streak increase on next check-in.");
                 // Streak increase happens *during* check-in, not here
             } else {
                 console.warn(`Unexpected day difference: ${diffDays}. No streak change.`);
             }
             // Update button state (important if date changed)
             updateDailyCheckInButtonState();
        }


         async function dailyCheckIn() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;

             if (state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours)) {
                 showNotification('Cooldown active. Check in later.', 'warning');
                 return;
             }

            domElements.dailyCheckInBtn.disabled = true;
            domElements.dailyCheckInBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';

            const today = new Date().toISOString().split('T')[0];
            let pointsAwarded = 5; // Base points

            // --- Streak Logic ---
            let streakIncreased = false;
            if (!state.lastPlayedDate) { // First check-in
                 state.consecutiveDays = 1;
                 streakIncreased = true;
                 console.log("First check-in, starting streak at Day 1.");
             } else {
                 const lastPlayedDateObj = new Date(state.lastPlayedDate);
                 const todayDate = new Date(today);
                 const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                 const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays === 1) { // Consecutive day
                     state.consecutiveDays = (state.consecutiveDays || 0) + 1;
                     pointsAwarded += Math.min(state.consecutiveDays, 5); // Add streak bonus (capped)
                     streakIncreased = true;
                     console.log(`Streak increased to Day ${state.consecutiveDays}. Bonus: ${pointsAwarded-5}`);
                } else if (diffDays > 1) { // Missed days
                    state.consecutiveDays = 1; // Reset streak to 1
                     streakIncreased = true; // Considered an increase from 0 or previous value
                    console.log("Streak broken, resetting to Day 1.");
                 } // If diffDays <= 0, it means already checked in today, which cooldown should prevent.
             }
            // --- End Streak Logic ---

             // Update state
            state.lastPlayedDate = today;
            state.lastCheckInTime = now;

             try {
                 // Save critical state updates first
                await saveData(['lastPlayedDate', 'lastCheckInTime', 'consecutiveDays']);
                // Then award points (which saves points & leaderboard)
                await awardPoints(pointsAwarded);

                // Update UI *after* successful save & award
                 updateUI(); // Refreshes streak display, points, button state, countdown
                 showNotification(`Checked in! Day ${state.consecutiveDays} registered.`, 'success');

             } catch (error) {
                console.error("Error during daily check-in process:", error);
                showNotification('Check-in failed. Please try again.', 'error');
                // Rollback state if necessary? Complex. Or just leave button enabled?
                 domElements.dailyCheckInBtn.disabled = false; // Re-enable button on error
                 domElements.dailyCheckInBtn.textContent = "Daily Check-In";
            }
        }


        function startCountdown() {
            if (checkinCountdownInterval) clearInterval(checkinCountdownInterval); // Clear existing interval
             if (!domElements.countdownDisplay) return; // Exit if display element is missing


             if (!state.lastCheckInTime) {
                domElements.countdownDisplay.textContent = '';
                 return; // No timer needed if never checked in or cooldown elapsed
             }

            const twentyFourHours = 24 * 60 * 60 * 1000;
            const endTime = state.lastCheckInTime + twentyFourHours;

            function updateCountdown() {
                const now = Date.now();
                const timeLeft = endTime - now;

                 if (timeLeft <= 0) {
                     domElements.countdownDisplay.textContent = ''; // Clear display when done
                     updateDailyCheckInButtonState(); // Update button to be enabled
                     if (checkinCountdownInterval) clearInterval(checkinCountdownInterval); // Stop this interval
                     checkinCountdownInterval = null;
                    return;
                 }

                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                domElements.countdownDisplay.textContent = `Next check-in: ${hours}h ${minutes}m ${seconds}s`;
                 domElements.dailyCheckInBtn.disabled = true; // Ensure button stays disabled
                 domElements.dailyCheckInBtn.textContent = "Checked In";
             }

             updateCountdown(); // Run immediately
             checkinCountdownInterval = setInterval(updateCountdown, 1000); // Update every second
         }


         function initializeChallenges() {
             return Array.from({ length: 150 }, (_, i) => {
                 const goalIndex = i % dailyGoals.length;
                 return { day: i + 1, goal: dailyGoals[goalIndex].goal, meditation: dailyGoals[goalIndex].meditation,
                          task1: dailyGoals[goalIndex].task1, task2: dailyGoals[goalIndex].task2, points: dailyGoals[goalIndex].points, completed: false };
             });
         }

        function getCompletedDaysCount(maxDay) {
            return state.challenges.slice(0, maxDay).filter(ch => ch && ch.completed).length; // Added check for ch
        }

        function isChallengeUnlocked(days) {
            switch (days) {
                case 7: return true;
                case 21: return getCompletedDaysCount(7) === 7;
                case 41: return getCompletedDaysCount(21) === 21;
                case 66: return state.workshopAccess && getCompletedDaysCount(41) === 41;
                case 150: return state.workshopAccess && getCompletedDaysCount(66) === 66;
                default: return false;
            }
        }

         function loadChallenges() {
            const challengeDurations = [7, 21, 41, 66, 150];
             const challengeIcons = { 7: 'fas fa-sun', 21: 'fas fa-seedling', 41: 'fas fa-star', 66: 'fas fa-moon', 150: 'fas fa-crown' };
             const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };

             if (!domElements.challengeOptions) return;
            domElements.challengeOptions.innerHTML = ''; // Clear previous

            challengeDurations.forEach(days => {
                const isUnlocked = isChallengeUnlocked(days);
                 const iconClass = challengeIcons[days] || 'fas fa-question-circle';
                 const title = challengeTitles[days] || `${days}-Day`;
                 const requiresWorkshop = days > 41;
                 const prevTierDays = days === 21 ? 7 : (days === 41 ? 21 : (days === 66 ? 41 : (days === 150 ? 66 : 0)));
                 const prevTierTitle = challengeTitles[prevTierDays] || `${prevTierDays}-Day`;
                 const prevTierComplete = prevTierDays === 0 || getCompletedDaysCount(prevTierDays) === prevTierDays;

                const div = document.createElement('div');
                div.className = `challenge-div ${isUnlocked ? '' : 'locked'}`;

                let content = `
                    <i class="${iconClass} challenge-icon"></i>
                    <h3>${days}-Day: ${title}</h3>
                `;

                 if (isUnlocked) {
                     content += `<button class="btn btn-custom start-challenge-btn mt-2" data-days="${days}">Begin ${title}</button>`;
                 } else {
                    let reason = '';
                     if (!prevTierComplete) {
                         reason = `Complete the ${prevTierTitle} challenge first.`;
                     } else if (requiresWorkshop && !state.workshopAccess) {
                        reason = 'Requires Workshop Access';
                         content += `<button class="btn btn-custom enroll-btn mt-2" data-days="${days}" style="font-size: 0.9em;">Enroll Info</button>
                                     <button class="btn btn-secondary attended-btn mt-2 ms-1" data-days="${days}" style="font-size: 0.9em;">Enter Code</button>`;
                     }
                     content = `
                        <i class="${iconClass} challenge-icon"></i>
                        <h3>${days}-Day: ${title}</h3>
                         <p class="warning-text">${reason}</p>
                         ${ (requiresWorkshop && !state.workshopAccess && prevTierComplete) ? // Only show buttons if appropriate
                            `<button class="btn btn-custom enroll-btn mt-2" data-days="${days}" style="font-size: 0.9em;">Enroll Info</button>
                             <button class="btn btn-secondary attended-btn mt-2 ms-1" data-days="${days}" style="font-size: 0.9em;">Enter Code</button>` : ''
                          }
                    `;
                 }
                div.innerHTML = content;
                domElements.challengeOptions.appendChild(div);
            });
            // Listeners setup in main setupEventListeners function
        }

         function displayDailyChallenges(days) {
             if (!days || !domElements.dailyChallengeList) return;
            const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
             domElements.challengeTitle.textContent = `${days}-Day Challenge: ${challengeTitles[days] || ''}`;
            domElements.dailyChallengeList.innerHTML = ''; // Clear previous

            let firstUncompletedIndex = state.challenges.slice(0, days).findIndex(ch => ch && !ch.completed);
            if (firstUncompletedIndex === -1) firstUncompletedIndex = days;

            state.challenges.slice(0, days).forEach((challenge, index) => {
                if (!challenge) return; // Skip if challenge data is missing
                const card = document.createElement('div');
                card.className = 'challenge-div mb-2';
                 const isLocked = index > 0 && !(state.challenges[index - 1]?.completed); // Locked if previous not done
                const canStart = index === firstUncompletedIndex && !isLocked;

                let content = `<h4 style="color: var(--challenge-description-color); font-size: 1.1rem;">Day ${challenge.day}: ${challenge.goal}</h4>`;

                if (challenge.completed) {
                     content += `<p style="color: green; font-weight: bold;"><i class="fas fa-check-circle"></i> Completed (+${challenge.points} $twote)</p>`;
                 } else if (isLocked) {
                     content += `<p class="warning-text" style="font-size: 0.9em;"><i class="fas fa-lock"></i> Complete Day ${challenge.day - 1} first</p>`;
                     card.classList.add('locked');
                 } else if (canStart) {
                     content += `<button class="btn btn-custom btn-sm mt-1 start-day-btn" data-day="${challenge.day}">Start Day ${challenge.day}</button>`;
                 } else {
                    content += `<p style="color: #aaa; font-size: 0.9em;"><i class="fas fa-hourglass-start"></i> Pending</p>`;
                    card.classList.add('locked');
                 }
                card.innerHTML = content;
                domElements.dailyChallengeList.appendChild(card);
            });
             // Listener setup in main setupEventListeners
        }


         function startChallenge(day) {
            const challenge = state.challenges.find(c => c.day === day);
             if (!challenge) return console.error(`Challenge data for day ${day} not found.`);

            state.currentChallengeDay = day;
            state.energyBefore = null;

             document.getElementById('energyLogModalTitle').textContent = `Day ${day}: ${challenge.goal} - Before`;
             domElements.energyLogPrompt.textContent = "Log your current energy level (0-100%).";
             domElements.energySlider.value = state.energyLevel || 50; // Default to current energy or 50
             domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`;
             domElements.challengeTasks.style.display = 'none';
             domElements.proofWarning.style.display = 'none';
             domElements.submitEnergyLog.textContent = 'Confirm Energy & View Tasks';
             domElements.submitEnergyLog.setAttribute('data-stage', 'before');
             domElements.submitEnergyLog.disabled = false;
             domElements.task1Proof.value = '';
             domElements.task2Proof.value = '';

            modalInstances.energyLog?.show();
         }

         async function handleEnergyLogSubmit() {
            const sliderValue = parseInt(domElements.energySlider.value);
            const stage = domElements.submitEnergyLog.getAttribute('data-stage');
            const challenge = state.challenges.find(c => c.day === state.currentChallengeDay);

            if (!challenge) {
                modalInstances.energyLog?.hide();
                 return console.error("Challenge data missing during submission.");
             }

            domElements.submitEnergyLog.disabled = true;

             if (stage === 'before') {
                state.energyBefore = sliderValue;
                 console.log(`Energy Before (Day ${state.currentChallengeDay}): ${state.energyBefore}%`);

                 document.getElementById('energyLogModalTitle').textContent = `Day ${state.currentChallengeDay}: ${challenge.goal} - After`;
                 domElements.energyLogPrompt.textContent = "Complete tasks & log your energy post-challenge.";
                 domElements.challengeTasks.style.display = 'block';
                 domElements.meditationTask.textContent = challenge.meditation;
                 domElements.task1Text.textContent = challenge.task1;
                 domElements.task2Text.textContent = challenge.task2;

                domElements.energySlider.value = state.energyBefore; // Start 'after' slider at 'before' value
                 domElements.energySliderValue.textContent = `${state.energyBefore}%`;
                 domElements.task1Proof.value = '';
                 domElements.task2Proof.value = '';

                 domElements.submitEnergyLog.textContent = 'Submit Completion';
                 domElements.submitEnergyLog.setAttribute('data-stage', 'after');
                 domElements.submitEnergyLog.disabled = true; // Disabled until proof uploaded
                 domElements.proofWarning.style.display = 'block';

            } else if (stage === 'after') {
                 const energyAfter = sliderValue;
                 const task1File = domElements.task1Proof.files[0];
                 const task2File = domElements.task2Proof.files[0];

                 if (!task1File || !task2File) {
                     showNotification('Please upload proof for both tasks.', 'error');
                     domElements.submitEnergyLog.disabled = false;
                     domElements.proofWarning.style.display = 'block';
                     return;
                 }

                 console.log(`Energy After (Day ${state.currentChallengeDay}): ${energyAfter}%`);
                 domElements.submitEnergyLog.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';

                 try {
                    // Mark challenge complete
                     challenge.completed = true;

                    // Add to history (simple proof confirmation)
                     state.challengeHistory.push({
                         day: state.currentChallengeDay, goal: challenge.goal,
                         energyBefore: state.energyBefore, energyAfter,
                         task1ProofProvided: true, task2ProofProvided: true
                     });

                    // Update energy and award points (these functions handle saving)
                     await updateEnergyLevel(state.energyBefore, energyAfter);
                    await awardPoints(challenge.points);

                    // Save the state of challenges and history explicitly
                    await saveData(['challenges', 'challengeHistory']);

                     modalInstances.energyLog?.hide();
                     showNotification(`Day ${state.currentChallengeDay} completed! ðŸŽ‰`, 'success');
                     if(state.currentChallengeDuration) displayDailyChallenges(state.currentChallengeDuration); // Refresh list

                 } catch (error) {
                    console.error("Error processing challenge completion:", error);
                    showNotification('Error submitting completion. Please try again.', 'error');
                     // Restore button state on error
                     domElements.submitEnergyLog.textContent = 'Submit Completion';
                    domElements.submitEnergyLog.disabled = false;
                 }
             }
         }


         function getHoroscope(birthdate) {
             if (!birthdate) return "Unknown";
             try {
                 const date = new Date(birthdate + 'T00:00:00'); // Ensure date is parsed consistently
                 if (isNaN(date.getTime())) return "Invalid Date"; // Check for invalid date
                 const month = date.getMonth() + 1;
                 const day = date.getDate();
                 // Classic western astrology dates
                 if ((month == 3 && day >= 21) || (month == 4 && day <= 19)) return "Aries";
                 if ((month == 4 && day >= 20) || (month == 5 && day <= 20)) return "Taurus";
                 if ((month == 5 && day >= 21) || (month == 6 && day <= 21)) return "Gemini"; // Corrected end June
                 if ((month == 6 && day >= 22) || (month == 7 && day <= 22)) return "Cancer"; // Corrected start June
                 if ((month == 7 && day >= 23) || (month == 8 && day <= 22)) return "Leo";
                 if ((month == 8 && day >= 23) || (month == 9 && day <= 22)) return "Virgo";
                 if ((month == 9 && day >= 23) || (month == 10 && day <= 23)) return "Libra"; // Corrected end Oct
                 if ((month == 10 && day >= 24) || (month == 11 && day <= 21)) return "Scorpio";// Corrected start Oct
                 if ((month == 11 && day >= 22) || (month == 12 && day <= 21)) return "Sagittarius";
                 if ((month == 12 && day >= 22) || (month == 1 && day <= 19)) return "Capricorn";
                 if ((month == 1 && day >= 20) || (month == 2 && day <= 18)) return "Aquarius";
                 if ((month == 2 && day >= 19) || (month == 3 && day <= 20)) return "Pisces";
                 return "Unknown"; // Fallback if dates don't match
             } catch (e) { console.error("Error parsing birthdate:", e); return "Error"; }
         }

        function showEnrollModal(days) {
            domElements.enrollName.textContent = state.userName;
            domElements.enrollHoroscope.textContent = getHoroscope(state.birthdate);
            domElements.enrollEnergy.textContent = state.energyLevel;
            const canEnroll = state.energyLevel >= 70;
            domElements.submitEnrollment.disabled = !canEnroll;
            domElements.enrollRequirement.style.display = canEnroll ? 'none' : 'block';
            domElements.submitEnrollment.onclick = () => enroll(days); // Set click handler contextually
            modalInstances.enroll?.show();
        }

        async function enroll(days) {
            if (state.energyLevel < 70) {
                 showNotification('Energy level must be 70% or higher!', 'error'); return;
             }
            state.workshopAccess = true;
            await saveData(['workshopAccess']);
             modalInstances.enroll?.hide();
             loadChallenges(); // Refresh challenge list view
             showNotification(`Enrollment successful! Advanced challenges accessible.`, 'success');
        }

        function showCodeModal(days) {
            domElements.workshopCode.value = '';
             domElements.submitCode.onclick = () => submitCode(days); // Set click handler contextually
             modalInstances.code?.show();
        }

        async function submitCode(days) {
            const code = domElements.workshopCode.value.trim();
            if (code.toLowerCase() === "wellness") {
                 state.workshopAccess = true;
                 await saveData(['workshopAccess']);
                 modalInstances.code?.hide();
                 loadChallenges();
                 showNotification(`Workshop code accepted! Access granted.`, 'success');
             } else {
                 showNotification('Invalid workshop code.', 'error');
                 domElements.workshopCode.focus();
             }
        }

         // --- Game Logic ---
        function drawAstrologyWheel() {
             const canvas = domElements.astrologyWheelCanvas;
             if (!canvas || !canvas.getContext) return console.error("Canvas not found or not supported");
             const ctx = canvas.getContext('2d');
             const centerX = canvas.width / 2;
             const centerY = canvas.height / 2;
             const radius = Math.min(centerX, centerY) - 15;
             const numSegments = zodiacOrder.length;
             const anglePerSegment = (2 * Math.PI) / numSegments;

             // Clear previous frame
             ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context and rotate
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentWheelAngle); // Rotate based on current spin state
            ctx.translate(-centerX, -centerY);

            // Draw segments
             ctx.font = `${Math.max(radius * 0.1, 9)}px Nunito`; // Smaller font for symbols
             ctx.textBaseline = 'middle';
             ctx.textAlign = 'center';

            zodiacOrder.forEach((zodiac, index) => {
                const startAngle = index * anglePerSegment - Math.PI / 2 - anglePerSegment / 2;
                const endAngle = startAngle + anglePerSegment;

                 ctx.beginPath();
                 ctx.moveTo(centerX, centerY);
                 ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                 ctx.closePath();
                 ctx.fillStyle = zodiac.color || (index % 2 === 0 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'); // Use defined color or alternate
                 ctx.fill();
                 ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // Slightly lighter stroke
                 ctx.stroke();

                // Draw symbol centered within segment
                 const textAngle = startAngle + anglePerSegment / 2;
                 const textRadius = radius * 0.7;
                 const textX = centerX + Math.cos(textAngle) * textRadius;
                 const textY = centerY + Math.sin(textAngle) * textRadius;
                 ctx.fillStyle = '#FFF8E1';
                 ctx.fillText(zodiac.symbol, textX, textY);
             });
            ctx.restore(); // Restore context to draw pointer unrotated

             // Draw Stationary Pointer
             const pointerSize = radius * 0.15;
             ctx.beginPath();
              ctx.moveTo(centerX + radius + 2, centerY); // Point pointing inwards
              ctx.lineTo(centerX + radius + pointerSize, centerY - pointerSize / 2);
              ctx.lineTo(centerX + radius + pointerSize, centerY + pointerSize / 2);

             ctx.closePath();
             ctx.fillStyle = 'var(--button-color)';
             ctx.fill();
              ctx.strokeStyle = 'var(--button-text-color)';
             ctx.lineWidth = 1.5;
             ctx.stroke();

              // Redraw inner circle if desired
               ctx.beginPath();
               ctx.arc(centerX, centerY, radius * 0.2, 0, 2 * Math.PI);
               ctx.fillStyle = 'rgba(0,0,0,0.3)';
               ctx.fill();
               ctx.strokeStyle = 'rgba(255,255,255,0.3)';
               ctx.stroke();


         }


         function spinWheel() {
             if (isSpinning) return;
             const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
              if (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours)) {
                 showNotification('Please Check-In before playing!', 'warning');
                 return;
             }

             isSpinning = true;
             domElements.spinWheel.disabled = true;
             domElements.spinWheel.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Spinning...';
             domElements.astrologyMessage.textContent = 'Spinning...';

            const numSegments = zodiacOrder.length;
             const anglePerSegment = (2 * Math.PI) / numSegments;
             const spinDuration = Math.random() * 2000 + 4000; // 4-6 seconds
            const rotations = 10 + Math.random() * 10; // 10-20 rotations
             const targetSegment = Math.floor(Math.random() * numSegments); // Target segment index
             const targetAngle = -(targetSegment * anglePerSegment + anglePerSegment / 2); // Target angle relative to top pointer
            const finalAngleOffset = (Math.random() - 0.5) * anglePerSegment * 0.6; // Add slight randomness within the segment

            const totalAngleToSpin = rotations * 2 * Math.PI + targetAngle + finalAngleOffset - currentWheelAngle; // Angle difference to spin

             const startTime = performance.now();

             function easeOutCubic(t) { return (--t) * t * t + 1; }

             function animateSpin(currentTime) {
                 const elapsedTime = currentTime - startTime;
                 const progress = Math.min(elapsedTime / spinDuration, 1);
                 const easedProgress = easeOutCubic(progress);

                currentWheelAngle += (totalAngleToSpin / spinDuration) * (currentTime - (startTime + elapsedTime * (1-easedProgress)/progress *0)); // Complex angle update

                 // More direct angle calculation based on progress
                const startAngle = currentWheelAngle; // Record angle at frame start
                 currentWheelAngle = startAngle + easedProgress * (totalAngleToSpin - startAngle); // Interpolate angle directly - Might be wrong approach

                // Simplest angle update based on delta:
                // currentWheelAngle += (totalAngleToSpin / (spinDuration/16.66)); // Approximate delta assuming 60fps - Needs improvement


                 // --- Calculate currentAngle based on progress and total angle difference ---
                let frameStartAngle = currentWheelAngle; // Store angle at start of frame if needed for calculation

                // Calculate how much angle *should* have been covered by now based on eased progress
                let newTargetAngle = frameStartAngle + easedProgress * totalAngleToSpin;

                // Better approach: directly set the angle based on progress
                currentWheelAngle = startAngle + easedProgress * totalAngleToSpin; // Use initial start angle for calc

                 drawAstrologyWheel(); // Redraw with the new currentWheelAngle

                 if (progress < 1) {
                     requestAnimationFrame(animateSpin);
                 } else {
                     // --- Spin Finished ---
                    // Ensure final angle aligns (optional adjustment)
                    // currentWheelAngle = startAngle + totalAngleToSpin;
                    // drawAstrologyWheel(); // Final draw

                    // Calculate winning segment based on the final angle
                     // Pointer is at the top (effective angle 0 relative to segments)
                     // Calculate the effective angle of the wheel relative to the fixed pointer
                    const effectiveAngle = (currentWheelAngle + Math.PI / 2 + anglePerSegment / 2) % (2 * Math.PI);
                     let winningIndex = Math.floor(effectiveAngle / anglePerSegment);
                     // Adjust index if needed (can be negative due to modulo, though unlikely here)
                      winningIndex = (winningIndex + numSegments) % numSegments;

                     const selectedSign = zodiacOrder[winningIndex];

                     if (selectedSign) {
                        domElements.astrologyMessage.textContent = `Landed on ${selectedSign.sign}! ${astrologyInsights[selectedSign.sign]}`;
                        awardPoints(selectedSign.points);
                    } else {
                         domElements.astrologyMessage.textContent = 'Wheel stopped unexpectedly!';
                         console.error("Error determining winner. Index:", winningIndex, "Effective Angle:", effectiveAngle);
                     }

                    isSpinning = false;
                     domElements.spinWheel.disabled = false;
                     domElements.spinWheel.textContent = 'Spin Again'; // Maybe limit spins per day?
                 }
             }

             const startingAngle = currentWheelAngle; // Store angle at the start of the whole spin
            requestAnimationFrame(animateSpin);
         }


         function initNumerologyPath() {
             domElements.numberGrid.innerHTML = '';
             domElements.numerologyMessage.textContent = 'Select a number for insight!';
             numerologyPlayed = false;

            const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
             if (!state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours)) {
                 domElements.numerologyMessage.innerHTML = '<span class="warning-text">Daily Check-In required!</span>';
                 return;
             }

            const maxNumbers = Math.max(3, 9 - Math.floor(state.consecutiveDays / 4)); // Fewer choices sooner
            const availableNumbers = Array.from({ length: 9 }, (_, i) => i + 1);
            const numbersToShow = availableNumbers.sort(() => 0.5 - Math.random()).slice(0, maxNumbers);

            numbersToShow.forEach(num => {
                const button = document.createElement('button');
                button.className = 'btn btn-custom m-1';
                 button.style.width = '60px'; // Give numbers fixed size
                 button.style.height = '60px';
                 button.style.fontSize = '1.2em';

                button.textContent = num;
                button.dataset.number = num;
                 button.onclick = handleNumberSelection; // Assign handler directly
                domElements.numberGrid.appendChild(button);
            });
         }

         function handleNumberSelection(event) {
            if (numerologyPlayed) {
                showNotification("Insight already received for this session.", "warning");
                return;
             }

            const selectedButton = event.target;
            const selectedNumber = parseInt(selectedButton.dataset.number);
            const insight = numerologyInsights[selectedNumber] || "A unique path unfolds...";
            const points = selectedNumber;

            domElements.numerologyMessage.textContent = `Number ${selectedNumber}: ${insight}`;
            awardPoints(points);
            numerologyPlayed = true;

             // Disable all buttons, highlight selected
             domElements.numberGrid.querySelectorAll('button').forEach(button => {
                 button.disabled = true;
                 button.onclick = null; // Remove listener
                 if (button === selectedButton) {
                     button.classList.add('active');
                      button.classList.remove('btn-custom');
                     button.classList.add('btn-success'); // Visually mark selected
                 } else {
                     button.classList.add('locked');
                 }
             });
         }

        // --- Profile & Leaderboard ---
        function loadProfileHistory() {
            if (!domElements.profileHistory) return;
            const recentHistory = state.challengeHistory.slice(-10).reverse(); // Max 10 recent items

             if (recentHistory.length === 0) {
                 domElements.profileHistory.innerHTML = '<tr><td colspan="6" class="text-center fst-italic">No challenge history.</td></tr>';
                 return;
             }

             domElements.profileHistory.innerHTML = recentHistory.map(entry => `
                 <tr>
                     <td>${entry.day || '?'}</td>
                     <td>${entry.goal || '-'}</td>
                     <td>${entry.energyBefore ?? '?'}%</td>
                     <td>${entry.energyAfter ?? '?'}%</td>
                     <td>${entry.task1ProofProvided ? '<i class="fas fa-check"></i>' : '<i class="fas fa-times"></i>'}</td>
                     <td>${entry.task2ProofProvided ? '<i class="fas fa-check"></i>' : '<i class="fas fa-times"></i>'}</td>
                 </tr>
             `).join('');
         }

        function updateLeaderboard() {
             if (!domElements.leaderboard) return;
             state.leaderboard.sort((a, b) => (b.points || 0) - (a.points || 0)); // Sort safely

             domElements.leaderboard.innerHTML = state.leaderboard.slice(0, 100).map((player, index) => `
                 <tr class="${player.userId === state.userId ? 'table-primary' : ''}">
                     <td>${index + 1}</td>
                     <td>${player.name || 'Anonymous'}</td>
                     <td>${player.points || 0}</td>
                 </tr>
             `).join('');

             if (state.leaderboard.length === 0) {
                domElements.leaderboard.innerHTML = '<tr><td colspan="3" class="text-center fst-italic">Leaderboard is empty.</td></tr>';
             }
        }


         async function deleteProgress() {
             const confirmationMessage = 'Permanently delete ALL your progress? This includes points, challenges, streak, settings. Cannot be undone!';
             let confirmed = false;
            try {
                if (telegramApp && telegramApp.showConfirm) {
                     confirmed = await new Promise(resolve => telegramApp.showConfirm(confirmationMessage, ok => resolve(ok)));
                } else {
                     confirmed = confirm(confirmationMessage); // Browser fallback
                }
             } catch (e) { confirmed = confirm(confirmationMessage); } // Fallback on error too

             if (confirmed) {
                 console.log("User confirmed deletion.");
                 // Show makeshift loading overlay
                  document.body.insertAdjacentHTML('beforeend', '<div id="temp-loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10001; color: white; flex-direction:column;"><div class="spinner-border mb-3"></div>Deleting Progress...</div>');

                const userId = state.userId;
                const userName = state.userName;
                const userPhoto = state.userPhoto;

                // Reset state object almost completely
                 state = initializeState(); // Re-init with defaults
                 // Restore essential user info
                 state.userId = userId;
                 state.userName = userName;
                 state.userPhoto = userPhoto;
                state.isLoading = false; // Mark loading as complete after reset
                state.storageType = localStorage.getItem('tt_storage_pref') || (window.Telegram?.WebApp?.initData ? 'cloud' : 'local'); // Re-determine storage type just in case
                 ensureUserInLeaderboard(); // Add user back to the default leaderboard with 0 points


                 try {
                     // Clear cloud/local storage
                    if (state.storageType === 'cloud' && telegramApp && telegramApp.CloudStorage) {
                        // Attempt to remove all keys known to the app
                        await Promise.all(CLOUD_STORAGE_KEYS.map(key =>
                             telegramApp.CloudStorage.removeItem(key)
                                 .catch(err => console.warn(`Failed to remove ${key} from cloud:`, err))
                         ));
                         console.log("Cloud storage keys potentially cleared.");
                          // Explicitly save the fresh leaderboard (containing just user and bots with 0/default points)
                          await saveStateToCloud(['leaderboard', 'points', 'challenges', 'challengeHistory']); // Save critical reset states

                     } else {
                         // Clear local storage based on known keys
                        CLOUD_STORAGE_KEYS.forEach(key => localStorage.removeItem(key));
                         // Keep userId preference maybe?
                        localStorage.removeItem('tt_storage_pref'); // Clear preference too? Decide...
                        console.log("Local storage keys potentially cleared.");
                        saveStateToLocal(['leaderboard', 'points', 'challenges', 'challengeHistory']); // Save critical reset states
                     }

                     console.log("Progress data deletion attempted.");
                     showNotification('Your progress has been reset.', 'success');

                     // Reset UI and navigation
                    updateUI(); // Update displays to 0, Guest etc.
                    loadProfileHistory(); // Clear history table display
                    showInitialSection(); // Go back to start (horoscope or wellness)

                 } catch (error) {
                     console.error("Error during progress deletion final steps:", error);
                     showNotification('Error clearing data fully. Please reload.', 'error');
                 } finally {
                    // Remove loading indicator
                    const tempLoading = document.getElementById('temp-loading');
                    if (tempLoading) tempLoading.remove();
                 }
             } else {
                 console.log("User cancelled deletion.");
             }
         }

        // --- Task Management ---
        function updateTaskButtons() {
             const taskIds = ['twitter', 'telegram', 'instagram', 'youtube'];
            taskIds.forEach(id => {
                const button = domElements[`${id}TaskBtn`]; // Assuming consistent IDs like 'twitterTaskBtn'
                if (!button) return;

                 const isCompleted = state.completedTasks?.includes(id);
                button.disabled = isCompleted;
                 button.textContent = isCompleted ? 'Done' : 'Verify';
                button.classList.toggle('btn-success', isCompleted);
                 button.classList.toggle('btn-custom', !isCompleted);
            });
        }

        async function completeTask(taskKey) {
             if (state.completedTasks.includes(taskKey)) {
                 showNotification('Task already completed.', 'info'); return;
             }

            const button = domElements[`${taskKey}TaskBtn`];
            if (button) {
                 button.disabled = true;
                 button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Verifying...';
            }

            // Simulate check & award points
            await new Promise(resolve => setTimeout(resolve, 1000)); // Shorter delay

             state.completedTasks = [...state.completedTasks, taskKey]; // Add task safely
            await saveData(['completedTasks']); // Save update
            await awardPoints(10); // Award points (also saves points/leaderboard)

             showNotification(`Task '${taskKey}' verified! +10 $twote`, 'success');
             updateTaskButtons(); // Update button UI
        }


         function copyReferralLink() {
             const linkInput = domElements.referralLink;
             if (!linkInput || !linkInput.value || linkInput.value === 'Link available after login') {
                 showNotification('Referral link not ready.', 'warning'); return;
             }

             navigator.clipboard.writeText(linkInput.value).then(() => {
                 showNotification('Referral link copied!', 'success');
             }).catch(err => {
                 console.error('Clipboard copy failed:', err);
                 showNotification('Could not copy link.', 'error');
                 // Simple fallback: select the text
                  try { linkInput.select(); } catch (e) { /* Ignore selection error */ }
             });
         }


         // --- Event Listeners Setup ---
         function setupEventListeners() {
             console.log("Setting up event listeners...");

             // Use event delegation where possible for dynamically added elements
              if (domElements.challengeOptions) {
                domElements.challengeOptions.addEventListener('click', (event) => {
                    if (event.target.classList.contains('start-challenge-btn')) {
                        const days = parseInt(event.target.getAttribute('data-days'));
                        if (days) {
                            state.currentChallengeDuration = days;
                            showSection('dailyChallenges');
                        }
                    } else if (event.target.classList.contains('enroll-btn')) {
                         const days = parseInt(event.target.getAttribute('data-days'));
                         if(days) showEnrollModal(days);
                    } else if (event.target.classList.contains('attended-btn')) {
                        const days = parseInt(event.target.getAttribute('data-days'));
                         if(days) showCodeModal(days);
                    }
                 });
             }

            if(domElements.dailyChallengeList) {
                domElements.dailyChallengeList.addEventListener('click', (event) => {
                    if (event.target.classList.contains('start-day-btn')) {
                         const day = parseInt(event.target.getAttribute('data-day'));
                         if(day) startChallenge(day);
                    }
                });
            }


             // Direct listeners for non-dynamic elements
             domElements.profileLink?.addEventListener('click', () => showSection('playerProfile'));
             domElements.saveHoroscopeBtn?.addEventListener('click', saveHoroscope);

             // Footer Navigation
            document.querySelector('.footer-nav')?.addEventListener('click', (e) => {
                if (e.target.tagName === 'A' || e.target.closest('a')) {
                     e.preventDefault();
                     const link = e.target.closest('a');
                     if (!link) return;

                    // Remove active class from all links, add to clicked
                     document.querySelectorAll('.footer-nav a').forEach(l => l.classList.remove('active'));
                     link.classList.add('active');

                    const targetId = link.id;
                     if (targetId === 'navHome') showSection('wellnessManager');
                     else if (targetId === 'navTasks') showSection('tasksSection');
                     else if (targetId === 'navGame') showSection('gamePage');
                     else if (targetId === 'navProfile') showSection('playerProfile');
                 }
            });


             // Game Page Buttons
             domElements.dailyCheckInBtn?.addEventListener('click', dailyCheckIn);
             domElements.playHoroscopeWheel?.addEventListener('click', () => showSection('horoscopeWheelPage'));
             domElements.playNumerologyPath?.addEventListener('click', () => showSection('numerologyPathPage'));

             // Game Interaction Buttons
             domElements.spinWheel?.addEventListener('click', spinWheel);
            // Numerology handled via onclick assignment in initNumerologyPath

             // Profile Page Buttons
             domElements.deleteProgressBtn?.addEventListener('click', deleteProgress);
             domElements.connectWalletBtn?.addEventListener('click', () => showNotification('Wallet connection coming soon!', 'info'));
             domElements.airdropWithdrawBtn?.addEventListener('click', () => showNotification('Withdrawals available later.', 'info'));

            // Modal related listeners
            domElements.energySlider?.addEventListener('input', () => {
                domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`;
            });

             domElements.submitEnergyLog?.addEventListener('click', handleEnergyLogSubmit);

             // File input listeners for enabling submit button in modal
             [domElements.task1Proof, domElements.task2Proof].forEach(input => {
                 input?.addEventListener('change', () => {
                     if (domElements.submitEnergyLog?.getAttribute('data-stage') === 'after') {
                         const task1File = domElements.task1Proof?.files[0];
                         const task2File = domElements.task2Proof?.files[0];
                         domElements.submitEnergyLog.disabled = !(task1File && task2File);
                         domElements.proofWarning.style.display = (task1File && task2File) ? 'none' : 'block';
                     }
                 });
             });

              // Workshop code handled by onclick assignments in showCodeModal/showEnrollModal


              console.log("Event listeners setup complete.");

         } // End setupEventListeners


    </script>
</body>
</html>
