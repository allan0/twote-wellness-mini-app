<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Third Eye - Game</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #4E342E;
            --text-color: #FFF8E1;
            --button-color: #FFD700;
            --button-text-color: #3E2723;
            --wellness-manager-color: #3E2723;
            --warning-color: #8B0000;
            --challenge-description-color: #3E2723;
            --level-color: #00bcd4;
            --achievement-color: #ff9800;
            --wheel-border-color: #FFD700;
            --wheel-pointer-color: #E65100; /* Deep orange pointer */
        }
        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            padding-bottom: 70px;
        }
        #backgroundVideo {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: -1;
        }
        .container { width: 100%; max-width: 800px; margin: 0 auto; padding: 0 15px; }
        .section {
            background: rgba(255, 248, 220, 0.1); backdrop-filter: blur(10px);
            padding: 25px; border-radius: 20px; margin-bottom: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .challenge-div {
            background: #fff; border-radius: 15px; padding: 15px; margin-bottom: 15px;
            text-align: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: var(--challenge-description-color);
        }
        .challenge-div h3 { color: var(--challenge-description-color); margin-bottom: 10px; }
        .challenge-div p { color: var(--challenge-description-color); }
        .challenge-div .warning-text { color: var(--warning-color); }
        .challenge-icon { font-size: 2.5em; margin-bottom: 10px; color: var(--text-color); }
        .challenge-div .challenge-icon { color: var(--challenge-description-color); }

        .modal-content {
            background: var(--bg-color); color: var(--text-color); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        #wheelModal .modal-content { /* Specific styling for wheel modal */
             background: rgba(40, 20, 10, 0.85); /* Darker, more focused background */
        }
        #wheelCanvas {
             display: block;
             margin: 15px auto;
             max-width: 100%;
             height: auto;
             border-radius: 50%; /* Makes the container round */
        }
        #wheelResult {
            margin-top: 15px;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 30px;
        }
        .wheel-pointer {
            position: absolute;
            top: -5px; /* Adjust as needed based on pointer size */
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 25px solid var(--wheel-pointer-color); /* Pointer color */
            z-index: 10; /* Ensure it's above the canvas */
        }
         #wheelContainer { /* Relative positioning for the pointer */
            position: relative;
            width: 300px; /* Match canvas width */
            height: 300px; /* Match canvas height */
            margin: 0 auto; /* Center container */
         }


        .btn-custom {
            background-color: var(--button-color); color: var(--button-text-color); border: none;
            padding: 10px 20px; border-radius: 10px;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-custom:hover, .btn-custom:active, .btn-custom:focus {
            transform: scale(1.05);
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -4px -4px 8px rgba(255, 255, 255, 0.3);
            color: var(--button-text-color); background-color: var(--button-color);
        }
        .btn-danger { background-color: var(--warning-color); color: #fff; border: none; box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2), -2px -2px 4px rgba(255, 255, 255, 0.2); }
        .btn-danger:hover, .btn-danger:active, .btn-danger:focus { transform: scale(1.05); box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3), -4px -4px 8px rgba(255, 255, 255, 0.3); color: #fff; }
        .locked { opacity: 0.6; }

        header img[src="logo.webp"] { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; }
        #profilePhoto { width: 40px; height: 40px; object-fit: cover; border-radius: 50%; cursor: pointer; }
        h1, h2, h4, body > .container > p { color: var(--text-color); }
        /* Section Specific H2 Styles */
        #wellnessManager h2, #dailyChallenges h2, #tasksSection h2, #gamePage h2, #playerProfile h2 {
             color: var(--text-color); text-align: center; margin-bottom: 20px;
         }
        h3 { color: var(--text-color); }
        .warning-text { color: var(--warning-color); font-weight: bold; }

        .footer-nav {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: rgba(78, 52, 46, 0.8); padding: 10px 0; z-index: 1000;
            display: flex; justify-content: space-around; box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
        }
        .footer-nav a { color: var(--text-color); text-decoration: none; font-size: 14px; text-align: center; transition: transform 0.2s; flex: 1; padding: 5px 0; }
        .footer-nav a:hover { transform: scale(1.1); background-color: rgba(255, 255, 255, 0.1); border-radius: 5px; }
        .footer-nav a i { display: block; font-size: 20px; margin-bottom: 3px; }

        .task-icon { font-size: 1.75em; margin-right: 10px; color: var(--text-color); }
        #socialMediaTasks ul { list-style-type: none; padding: 0; }
        #socialMediaTasks li { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; flex-wrap: wrap; }
        #socialMediaTasks li > div { display: flex; align-items: center; margin-right: 10px; margin-bottom: 5px; }
        #socialMediaTasks a { color: var(--text-color); text-decoration: underline; margin-left: 5px; }
        #socialMediaTasks a:hover { text-decoration: none; }
        #socialMediaTasks button { padding: 5px 10px; font-size: 0.9em; }

        #referralTask { margin-top: 20px; }
        #referralTask p { margin-bottom: 10px; }
        #referralTask input[type="text"] { width: calc(100% - 110px); margin-right: 10px; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: var(--text-color); padding: 8px; border-radius: 5px; }
        #referralTask button { width: 100px; }

        /* Game Page specific styles */
        .wheel-button-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .wheel-button { padding: 12px 5px; font-size: 0.9em; text-align: center; }
        .wheel-button i { display: block; font-size: 1.5em; margin-bottom: 5px; }
        .mystery-box-section { text-align: center; margin-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 20px; }
        .mystery-box-section .fa-box-open { font-size: 3em; color: var(--button-color); margin-bottom: 10px; }
        #mysteryBoxCount { font-weight: bold; color: var(--button-color); }

         /* Progression & Achievements */
        #levelDisplay { font-size: 1.2em; font-weight: bold; color: var(--level-color); margin-bottom: 15px; text-align: center; }
        #achievementsList { list-style: none; padding: 0; text-align: center; }
        #achievementsList li { display: inline-block; background: rgba(0,0,0, 0.3); color: var(--achievement-color); padding: 5px 10px; border-radius: 15px; margin: 5px; font-size: 0.9em; border: 1px solid var(--achievement-color); }
        #achievementsList li i { margin-right: 5px; }
        .subscription-info { margin-top: 25px; padding-top: 15px; border-top: 1px dashed rgba(255, 255, 255, 0.3); text-align: center; font-size: 0.9em; opacity: 0.8; }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 0 10px; }
            .section { padding: 20px; margin-bottom: 15px;}
            .challenge-div { padding: 12px; }
            .challenge-icon { font-size: 2em; }
            .btn-custom { margin-bottom: 10px; padding: 10px 15px; }
            h1 { font-size: 1.6rem; } h2 { font-size: 1.4rem; } h3 { font-size: 1.2rem; }
            .challenge-div h3 { font-size: 1.2rem; }
            p { font-size: 0.95rem; } .warning-text { font-size: 0.9rem; }
            #socialMediaTasks button { width: auto; margin-left: auto; }
            #referralTask input[type="text"] { width: calc(100% - 100px); }
            #referralTask button { width: 90px; }
            .wheel-button-grid { grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 10px;}
            .wheel-button { font-size: 0.85em;}
            #wheelContainer, #wheelCanvas { width: 250px; height: 250px; } /* Smaller wheel on smaller screens */
            .wheel-pointer { border-left-width: 12px; border-right-width: 12px; border-top-width: 20px;}
        }
        @media (max-width: 576px) {
            .footer-nav a { font-size: 12px; } .footer-nav a i { font-size: 18px; }
            h1 { font-size: 1.4rem; } h2 { font-size: 1.2rem; } h3 { font-size: 1.1rem; }
            .challenge-div h3 { font-size: 1.1rem; }
            p { font-size: 0.875rem; }
            .challenge-icon { font-size: 1.75em; }
            #socialMediaTasks li { flex-direction: column; align-items: flex-start;}
            #socialMediaTasks li > div { margin-bottom: 8px; }
            #socialMediaTasks button { width: 100%; margin-top: 5px; }
            #referralTask { display: flex; flex-direction: column; }
            #referralTask input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px;}
            #referralTask button { width: 100%; }
            header { flex-direction: column; text-align: center;}
            header > div:last-child { margin-top: 10px; }
            .wheel-button-grid { grid-template-columns: repeat(2, 1fr); }
            .wheel-button { font-size: 0.8em;}
            #wheelContainer, #wheelCanvas { width: 220px; height: 220px; } /* Even smaller wheel */
            .wheel-pointer { border-left-width: 10px; border-right-width: 10px; border-top-width: 18px;}
        }

        /* Table styling */
        .table { color: var(--text-color); background-color: rgba(0, 0, 0, 0.2); border-radius: 10px; overflow: hidden; margin-top: 15px; border-collapse: separate; border-spacing: 0; }
        .table th, .table td { border-top: 1px solid rgba(255, 255, 255, 0.2); padding: 0.6rem 0.5rem; vertical-align: middle; }
        .table thead th { color: var(--button-color); background-color: rgba(0, 0, 0, 0.4); border-top: none; border-bottom: 2px solid var(--button-color); font-weight: bold; }
        .table tbody tr:first-child td { border-top: none; }
        .table tbody tr:hover { background-color: rgba(255, 255, 255, 0.1); }
        .table img { max-width: 40px; height: auto; border-radius: 4px; }
        .table-primary td, .table tr.table-primary td { background-color: rgba(var(--bs-primary-rgb, 13, 110, 253), 0.2) !important; }
        .table .table-primary { font-weight: bold; }
        .table-responsive { border-radius: 10px; }
        .table-sm th, .table-sm td { padding: 0.4rem 0.4rem; }

        /* Modal Styling Enhancements */
        .modal-header, .modal-footer { border: none; }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%); }
        .form-range::-webkit-slider-thumb { background-color: var(--button-color); }
        .form-range::-moz-range-thumb { background-color: var(--button-color); }

    </style>
</head>
<body>
    <video id="backgroundVideo" autoplay muted loop playsinline>
        <source src="cosmic.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

    <div class="container">
        <header class="d-flex justify-content-between align-items-center py-3">
            <div class="d-flex align-items-center">
                <img src="logo.webp" alt="Logo">
                <h1 style="margin: 0; font-size: 1.8rem;">Third Eye</h1>
            </div>
            <div class="d-flex align-items-center flex-column text-center" id="profileLink">
                <img id="profilePhoto" src="https://via.placeholder.com/40" alt="Profile">
                <span id="profileNameDisplay" style="margin-top: 5px; font-size: 0.9rem; line-height: 1.1;">Guest</span>
                <span id="profileLevelDisplay" style="font-size: 0.8rem; color: var(--level-color);">Level: Novice</span>
                <span id="pointsDisplay" style="font-size: 0.9rem; color: var(--button-color); font-weight: bold;">0 $twote</span>
            </div>
        </header>

        <!-- Sections -->
        <div id="horoscopeForm" class="section" style="display: none;">
            <h2>Enter Your Birthdate</h2>
            <p>To personalize your journey.</p>
            <input type="date" id="birthdate" class="form-control mb-2">
            <button class="btn btn-custom w-100" id="saveHoroscopeBtn">Save & Continue</button>
        </div>

        <div id="wellnessManager" class="section" style="display: none;">
            <h2>Mindfulness Journey</h2>
            <p style="text-align: center;">Select a challenge duration to begin.</p>
            <div id="challengeOptions" class="mt-3"></div>
        </div>

        <div id="dailyChallenges" class="section" style="display: none;">
            <h2 id="challengeTitle">Challenge</h2>
            <div id="dailyChallengeList"></div>
        </div>

        <div id="tasksSection" class="section" style="display: none;">
            <h2>Earn More $twote & Spins</h2>
             <div id="socialMediaTasks">
                 <h3 style="color: var(--text-color); border-bottom: 1px solid var(--button-color); padding-bottom: 5px; margin-bottom: 15px;">Social Tasks (+10 $twote each)</h3>
                 <ul>
                     <li>
                         <div><i class="fab fa-telegram-plane task-icon"></i>Join <a href="https://t.me/ThirdEyeXai" target="_blank">Telegram</a></div>
                         <button class="btn btn-custom" id="telegramTaskBtn" onclick="completeTask('telegram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-twitter task-icon"></i>Follow <a href="https://twitter.com/ThirdEyeXai" target="_blank">Twitter</a></div>
                         <button class="btn btn-custom" id="twitterTaskBtn" onclick="completeTask('twitter')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-instagram task-icon"></i>Follow <a href="https://instagram.com/ThirdEyeXai" target="_blank">Instagram</a></div>
                         <button class="btn btn-custom" id="instagramTaskBtn" onclick="completeTask('instagram')">Verify</button>
                     </li>
                     <li>
                         <div><i class="fab fa-youtube task-icon"></i>Subscribe <a href="https://youtube.com/@ThirdEyeXai" target="_blank">YouTube</a></div>
                         <button class="btn btn-custom" id="youtubeTaskBtn" onclick="completeTask('youtube')">Verify</button>
                     </li>
                 </ul>
             </div>
             <div id="referralTask" class="mt-4">
                 <h3 style="color: var(--text-color); border-bottom: 1px solid var(--button-color); padding-bottom: 5px; margin-bottom: 15px;">Referral Task (+Bonus Spins!)</h3>
                 <p>Share your link! Both you and your friend earn $twote. You also get bonus spins!</p>
                 <div class="d-flex">
                     <input type="text" id="referralLink" class="form-control" readonly style="flex-grow: 1; margin-right: 10px;">
                     <button class="btn btn-custom" onclick="copyReferralLink()">Copy</button>
                 </div>
                 <button class="btn btn-secondary mt-3 w-100" id="claimReferralRewardBtn" onclick="simulateReferralCompletion()">Simulate Friend Joined (Dev)</button>
             </div>
        </div>

        <div id="gamePage" class="section" style="display: none;">
            <h2>Engage & Earn</h2>
            <div class="text-center mb-3">
                <button class="btn btn-custom" id="dailyCheckInBtn">Daily Check-In</button>
                <p id="countdownDisplay" style="color: var(--button-color); margin-top: 10px; font-size: 0.9em;"></p>
            </div>

            <h3 style="text-align:center; margin-bottom: 15px;">Daily Bonus Wheels (1 Free Spin Each)</h3>
            <p id="spinInfo" class="text-center" style="font-size: 0.9em; margin-bottom: 15px;">Complete Daily Check-In to enable spins.</p>
            <div class="wheel-button-grid">
                 <!-- Buttons now trigger modal via data-wheel attribute -->
                <button class="btn btn-custom wheel-button" data-wheel="energy"><i class="fas fa-bolt"></i>Energy (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="sigil"><i class="fas fa-magic"></i>Sigil (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="happiness"><i class="fas fa-smile-beam"></i>Happiness (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="wellness"><i class="fas fa-heartbeat"></i>Wellness (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="prosperity"><i class="fas fa-coins"></i>Prosperity (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="manifestation"><i class="fas fa-star"></i>Manifest (1)</button>
                <button class="btn btn-custom wheel-button" data-wheel="healing"><i class="fas fa-hand-holding-heart"></i>Healing (1)</button>
                <button class="btn btn-info wheel-button" data-wheel="referral"><i class="fas fa-gift"></i>Ref Spins (<span id="referralSpinsCount">0</span>)</button>
            </div>

            <div class="mystery-box-section">
                <i class="fas fa-box-open"></i>
                <h4>Mystery Boxes</h4>
                <p>Earn boxes from streaks & events!</p>
                <p>You have <span id="mysteryBoxCount">0</span> boxes.</p>
                <button class="btn btn-custom" id="openMysteryBoxBtn" disabled>Open a Box</button>
            </div>

             <div class="subscription-info">
                 <p>✨ Premium Tiers Coming Soon! Unlock better rewards, exclusive badges, and more spins!</p>
             </div>
             <div class="section" style="margin-top: 20px; background: rgba(0,0,0,0.1);">
                 <h4 style="text-align: center;">Limited-Time Events</h4>
                 <p style="text-align: center;">Check back soon for seasonal challenges and special events!</p>
             </div>
        </div>

        <div id="playerProfile" class="section" style="display: none;">
            <h2>Player Profile</h2>
            <div class="text-center mb-3">
                <p>Welcome, <strong id="profileNameDisplayInner" style="color: var(--button-color);">Guest</strong>!</p>
                 <div id="levelDisplay">Level: <span id="levelName" style="color: var(--level-color); font-weight:bold;">Novice</span></div>
                <div id="pointsProfileDisplay">Points: <span id="pointsValue" style="color: var(--button-color); font-weight:bold;">0</span> $twote</div>
                <div id="energyLevel">Energy Level: <span id="energyValue" style="color: var(--button-color); font-weight:bold;">0</span>%</div>
                <div id="consecutiveDaysDisplay">Daily Streak: <span id="consecutiveDaysValue" style="color: var(--button-color); font-weight:bold;">0</span> days</div>
                <div id="weeklyStreakDisplay">Weekly Streak: <span id="weeklyStreakValue" style="color: var(--button-color); font-weight:bold;">0</span> weeks</div>
            </div>
             <div class="d-grid gap-2 mb-4">
                 <button class="btn btn-custom" id="connectWalletBtn">Connect Wallet (Soon)</button>
                 <button class="btn btn-custom" id="airdropWithdrawBtn">Withdraw $twote (Soon)</button>
             </div>

             <h3 class="mt-4 text-center" style="color: var(--text-color);">Achievements</h3>
             <ul id="achievementsList" class="mb-4">
                 <li><i class="fas fa-hourglass-start"></i> No achievements yet</li>
             </ul>

            <h3 class="mt-4" style="color: var(--text-color);">Challenge History</h3>
            <div class="table-responsive">
                <table class="table table-sm">
                    <thead><tr><th>Day</th><th>Goal</th><th>NRG In</th><th>NRG Out</th><th>T1 Proof</th><th>T2 Proof</th></tr></thead>
                    <tbody id="profileHistory"></tbody>
                </table>
            </div>

            <h3 class="mt-4" style="color: var(--text-color);">Leaderboard (Top 100)</h3>
             <div class="table-responsive">
                 <table class="table table-sm">
                     <thead><tr><th>Rank</th><th>Name</th><th>Points ($twote)</th></tr></thead>
                     <tbody id="leaderboard"></tbody>
                 </table>
             </div>
             <div class="text-center mt-4">
                 <button class="btn btn-danger mt-3" id="deleteProgressBtn">Delete Progress</button>
             </div>
        </div>
    </div>

    <nav class="footer-nav">
        <a href="#" id="navHome"><i class="fas fa-home"></i>Journey</a>
        <a href="#" id="navTasks"><i class="fas fa-tasks"></i>Tasks</a>
        <a href="#" id="navGame"><i class="fas fa-dice"></i>Engage</a>
        <a href="#" id="navProfile"><i class="fas fa-user-astronaut"></i>Profile</a>
    </nav>

    <!-- Modals -->
    <div class="modal fade" id="energyLogModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="energyLogModalTitle">Energy Log</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p id="energyLogPrompt">How positive is your mind frame?</p>
                    <div class="d-flex align-items-center my-3">
                         <input type="range" min="0" max="100" value="50" class="form-range flex-grow-1 me-3" id="energySlider">
                         <span id="energySliderValue" style="color: var(--button-color); font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                    </div>
                    <div id="challengeTasks" style="display: none; margin-top: 20px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px;">
                        <p class="mb-2"><strong>Meditation:</strong> <span id="meditationTask" style="font-style: italic;"></span></p>
                        <p class="mb-1"><strong>Task 1:</strong> <span id="task1Text"></span></p>
                        <input type="file" id="task1Proof" class="form-control form-control-sm mb-2" accept="image/*">
                        <p class="mb-1"><strong>Task 2:</strong> <span id="task2Text"></span></p>
                        <input type="file" id="task2Proof" class="form-control form-control-sm" accept="image/*">
                        <p class="mt-3 text-center warning-text" id="proofWarning" style="display: none; font-size: 0.9em;">Please upload proof for both tasks.</p>
                    </div>
                </div>
                <div class="modal-footer justify-content-center">
                    <button class="btn btn-custom w-50" id="submitEnergyLog" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="enrollModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Enroll in Workshop</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                     <p><strong>Name:</strong> <span id="enrollName"></span></p>
                     <p><strong>Energy Level:</strong> <span id="enrollEnergy" style="color: var(--button-color); font-weight: bold;"></span>%</p>
                     <p id="enrollRequirement" class="warning-text" style="font-size: 0.9em; display: none;">Requires 70% Energy</p>
                     <button class="btn btn-custom mt-3 w-50" id="submitEnrollment" disabled>Submit Enrollment</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="codeModal" tabindex="-1" aria-hidden="true">
         <div class="modal-dialog modal-dialog-centered">
             <div class="modal-content">
                 <div class="modal-header">
                     <h5 class="modal-title">Enter Workshop Code</h5>
                     <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                 </div>
                 <div class="modal-body">
                     <input type="text" id="workshopCode" class="form-control mb-3" placeholder="Enter code">
                      <div class="text-center">
                          <button class="btn btn-custom w-50" id="submitCode">Submit</button>
                      </div>
                 </div>
             </div>
         </div>
     </div>

    <!-- Wheel Modal -->
    <div class="modal fade" id="wheelModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="wheelModalTitle">Spin the Wheel!</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <div id="wheelContainer">
                         <div class="wheel-pointer"></div>
                         <canvas id="wheelCanvas" width="300" height="300"></canvas>
                    </div>
                    <p id="wheelResult">Ready to spin?</p>
                </div>
                <div class="modal-footer justify-content-center">
                    <button class="btn btn-custom" id="spinTheWheelBtn">Spin!</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Toast Container -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
    <script>
        // Constants
        const dailyGoals = [
            { goal: "Wealth", meditation: "Visualize wealth.", task1: "Write 3 financial goals.", task2: "Plan a budget.", points: 5 },
            { goal: "Peace", meditation: "Reflect on peace.", task1: "5-min gratitude.", task2: "5-min breathing.", points: 5 },
            { goal: "Focus", meditation: "Focus your mind.", task1: "List 3 priorities.", task2: "Organize workspace.", points: 5 },
            { goal: "Creativity", meditation: "Boost creativity.", task1: "Brainstorm 5 ideas.", task2: "Draw something.", points: 5 },
            { goal: "Confidence", meditation: "Build confidence.", task1: "Write 3 positives.", task2: "Power pose 2 min.", points: 5 },
            { goal: "Energy", meditation: "Energize yourself.", task1: "Visualize energy.", task2: "5-min stretch.", points: 5 },
            { goal: "Gratitude", meditation: "Cultivate gratitude.", task1: "Write 3 thanks.", task2: "Send a thank-you.", points: 5 }
        ];
        const sections = ['horoscopeForm', 'wellnessManager', 'dailyChallenges', 'tasksSection', 'gamePage', 'playerProfile'];
        const wheelTypes = ['energy', 'sigil', 'happiness', 'wellness', 'prosperity', 'manifestation', 'healing', 'referral'];
        const levels = [
            { name: "Novice", points: 0 }, { name: "Beginner", points: 100 },
            { name: "Adept", points: 500 }, { name: "Guardian", points: 1500 },
            { name: "Healer", points: 4000 }, { name: "Master", points: 10000 }
        ];
        const achievementsConfig = {
            'FIRST_CHECKIN': { name: "First Steps", icon: "fa-shoe-prints", description: "Completed your first daily check-in." },
            '7_DAY_STREAK': { name: "Consistent Soul", icon: "fa-calendar-check", description: "Achieved a 7-day streak." },
            'FIRST_REFERRAL': { name: "Community Builder", icon: "fa-users", description: "Successfully referred a friend." },
            'LEVEL_ADEPT': { name: "Adept Achiever", icon: "fa-star", description: "Reached the Adept level." },
            'CHALLENGE_7_COMPLETE': { name: "Foundation Complete", icon: "fa-sun", description: "Completed the 7-Day Foundation Challenge."},
            'OPEN_MYSTERY_BOX': { name: "Curious Explorer", icon: "fa-box", description: "Opened your first Mystery Box." },
        };
        // Wheel Reward Definitions
        const wheelRewardConfigs = {
            energy: [
                { label: "1 $twote", type: "points", value: 1, color: "#AED581" }, { label: "+1% NRG", type: "energy", value: 1, color: "#FFF176" },
                { label: "2 $twote", type: "points", value: 2, color: "#AED581" }, { label: "+2% NRG", type: "energy", value: 2, color: "#FFF176" },
                { label: "3 $twote", type: "points", value: 3, color: "#AED581" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "1 $twote", type: "points", value: 1, color: "#AED581" }, { label: "+1% NRG", type: "energy", value: 1, color: "#FFF176" },
            ],
            sigil: [
                { label: "2 $twote", type: "points", value: 2, color: "#81D4FA" }, { label: "3 $twote", type: "points", value: 3, color: "#4FC3F7" },
                { label: "4 $twote", type: "points", value: 4, color: "#81D4FA" }, { label: "Small Luck", type: "message", value: "Feeling lucky!", color: "#CE93D8" },
                { label: "5 $twote", type: "points", value: 5, color: "#4FC3F7" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "2 $twote", type: "points", value: 2, color: "#81D4FA" }, { label: "1 $twote", type: "points", value: 1, color: "#4FC3F7" },
            ],
            happiness: [
                { label: "+2% NRG", type: "energy", value: 2, color: "#FFD54F" }, { label: "3 $twote", type: "points", value: 3, color: "#FFB74D" },
                { label: "+3% NRG", type: "energy", value: 3, color: "#FFD54F" }, { label: "5 $twote", type: "points", value: 5, color: "#FFB74D" },
                { label: "+5% NRG", type: "energy", value: 5, color: "#FFD54F" }, { label: "Joyful!", type: "message", value: "Radiate joy!", color: "#FFF176" },
                { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" }, { label: "2 $twote", type: "points", value: 2, color: "#FFB74D" },
            ],
            wellness: [
                { label: "2 $twote", type: "points", value: 2, color: "#A5D6A7" }, { label: "+2% NRG", type: "energy", value: 2, color: "#C5E1A5" },
                { label: "4 $twote", type: "points", value: 4, color: "#A5D6A7" }, { label: "+3% NRG", type: "energy", value: 3, color: "#C5E1A5" },
                { label: "5 $twote", type: "points", value: 5, color: "#A5D6A7" }, { label: "Healthy Glow", type: "message", value: "Feeling vibrant!", color: "#E6EE9C" },
                { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" }, { label: "+1% NRG", type: "energy", value: 1, color: "#C5E1A5" },
            ],
            prosperity: [
                { label: "5 $twote", type: "points", value: 5, color: "#FFCC80" }, { label: "7 $twote", type: "points", value: 7, color: "#FFB74D" },
                { label: "10 $twote", type: "points", value: 10, color: "#FFA726" }, { label: "Mystery Box", type: "mystery_box", value: 1, color: "#ba68c8" },
                { label: "15 $twote", type: "points", value: 15, color: "#FF9800" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "5 $twote", type: "points", value: 5, color: "#FFCC80" }, { label: "Jackpot! 25", type: "points", value: 25, color: "#FB8C00" },
            ],
            manifestation: [
                { label: "3 $twote", type: "points", value: 3, color: "#90CAF9" }, { label: "+2% NRG", type: "energy", value: 2, color: "#A1887F" },
                { label: "5 $twote", type: "points", value: 5, color: "#64B5F6" }, { label: "Mystery Box", type: "mystery_box", value: 1, color: "#ba68c8" },
                { label: "7 $twote", type: "points", value: 7, color: "#42A5F5" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "+5% NRG", type: "energy", value: 5, color: "#A1887F" }, { label: "Vision Clear", type: "message", value: "Focus your intent!", color: "#BDBDBD" },
            ],
            healing: [
                { label: "+3% NRG", type: "energy", value: 3, color: "#B39DDB" }, { label: "2 $twote", type: "points", value: 2, color: "#9575CD" },
                { label: "+5% NRG", type: "energy", value: 5, color: "#B39DDB" }, { label: "4 $twote", type: "points", value: 4, color: "#7E57C2" },
                { label: "+7% NRG", type: "energy", value: 7, color: "#B39DDB" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "Restored", type: "message", value: "Feel refreshed!", color: "#FFF176" }, { label: "1 $twote", type: "points", value: 1, color: "#9575CD" },
            ],
            referral: [
                { label: "10 $twote", type: "points", value: 10, color: "#F06292" }, { label: "Mystery Box", type: "mystery_box", value: 1, color: "#ba68c8" },
                { label: "20 $twote", type: "points", value: 20, color: "#EC407A" }, { label: "2 Mystery Box", type: "mystery_box", value: 2, color: "#ba68c8" },
                { label: "30 $twote", type: "points", value: 30, color: "#E91E63" }, { label: "Spin Again", type: "spin_again", value: null, color: "#FFB74D" },
                { label: "Rare NFT (Soon)", type: "message", value: "NFT coming!", color: "#00BCD4" }, { label: "50 $twote", type: "points", value: 50, color: "#D81B60" },
            ]
        };

        // Global State & Utils
        let state = {};
        let sectionStack = ['wellnessManager'];
        let domElements = {};
        let energyLogModalInstance = null;
        let enrollModalInstance = null;
        let codeModalInstance = null;
        let wheelModalInstance = null;
        let currentWheelType = null;
        let wheelSpinning = false;
        let currentRotation = 0; // Keep track of wheel rotation

        // --- Utility Functions ---
        function getDomElements() {
            const ids = [
                'profilePhoto', 'profileNameDisplay', 'profileNameDisplayInner', 'pointsDisplay', 'profileLevelDisplay',
                'pointsValue', 'consecutiveDaysValue', 'weeklyStreakValue', 'energyValue', 'challengeOptions',
                'dailyChallengeList', 'challengeTitle', 'energyLogPrompt', 'energySlider',
                'energySliderValue', 'challengeTasks', 'meditationTask', 'task1Text',
                'task2Text', 'task1Proof', 'task2Proof', 'submitEnergyLog', 'profileHistory',
                'referralLink', 'dailyCheckInBtn', 'countdownDisplay', 'leaderboard', 'enrollName',
                'enrollHoroscope', 'enrollEnergy', 'submitEnrollment', 'workshopCode',
                'submitCode', 'proofWarning', 'enrollRequirement', 'energyLogModal',
                'enrollModal', 'codeModal', 'wheelModal', 'wheelModalTitle', 'wheelCanvas', 'wheelResult',
                'spinTheWheelBtn', 'spinInfo', 'levelDisplay', 'levelName', 'achievementsList',
                'mysteryBoxCount', 'openMysteryBoxBtn', 'referralSpinsCount', 'claimReferralRewardBtn'
            ];
            // Note: Wheel buttons are handled by class/data-attribute, not specific IDs here
            const elements = {};
            ids.forEach(id => elements[id] = document.getElementById(id));
            return elements;
        }

        function capitalizeFirstLetter(string) {
          if (!string) return '';
          return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            domElements = getDomElements();
            energyLogModalInstance = new bootstrap.Modal(domElements.energyLogModal);
            enrollModalInstance = new bootstrap.Modal(domElements.enrollModal);
            codeModalInstance = new bootstrap.Modal(domElements.codeModal);
            wheelModalInstance = new bootstrap.Modal(domElements.wheelModal);

            initializeApp(); // Initialize state and UI
            setupEventListeners(); // Setup button clicks etc.
        });

        function initializeState() {
            const defaultLeaderboard = [
                 { userId: 'bot1', name: 'Cosmic Guide', points: 150 },
                 { userId: 'bot2', name: 'Zen Master', points: 120 },
                 { userId: 'bot3', name: 'Astro Explorer', points: 110 },
            ];
            const initialSpins = {};
            wheelTypes.forEach(type => initialSpins[type] = 0); // Start with 0 spins

            return {
                userId: null, userName: "Guest", userPhoto: "https://via.placeholder.com/40",
                energyLevel: 0, points: 0, level: "Novice",
                challenges: [], challengeHistory: [], birthdate: null,
                consecutiveDays: 0, weeklyStreak: 0, lastPlayedDate: null, lastCheckInTime: null,
                completedTasks: [], workshopAccess: false, currentChallengeDuration: null,
                currentChallengeDay: null, energyBefore: null, leaderboard: defaultLeaderboard,
                achievements: [], mysteryBoxes: 0, wheelSpins: initialSpins,
                lastDailySpinReset: null, challengeCompletedToday: {}, // Track completion per day { 'YYYY-MM-DD': true/false }
            };
        }

        function initializeApp() {
             console.log("Initializing App (Local Storage)...");
             state = initializeState(); // Reset state first

             // Try getting Telegram data
             if (window.Telegram?.WebApp) {
                 Telegram.WebApp.ready();
                 Telegram.WebApp.expand();
                 const user = Telegram.WebApp.initDataUnsafe?.user;
                 if (user) {
                     console.log("Telegram User Data:", user);
                     state.userId = user.id.toString();
                     state.userName = user.first_name || "User";
                     state.userPhoto = user.photo_url || domElements.profilePhoto.src;
                 } else {
                     console.warn("Telegram user data not found.");
                     state.userId = localStorage.getItem('userId') || `local_${Date.now()}`;
                 }
             } else {
                 console.warn("Telegram WebApp not available. Using local storage.");
                 state.userId = localStorage.getItem('userId') || `local_${Date.now()}`;
             }
             localStorage.setItem('userId', state.userId); // Ensure ID is saved for local persistence

             initLocalStorage(); // Load saved data
        }

        function initLocalStorage() {
             console.log("Loading state from Local Storage for user:", state.userId);
             try {
                state.energyLevel = parseInt(localStorage.getItem('energyLevel') || '0');
                state.points = parseInt(localStorage.getItem('points') || '0');
                state.level = localStorage.getItem('level') || "Novice";
                state.challenges = JSON.parse(localStorage.getItem('challenges') || 'null') || initializeChallenges();
                state.challengeHistory = JSON.parse(localStorage.getItem('challengeHistory') || '[]');
                state.birthdate = localStorage.getItem('birthdate') || null;
                state.consecutiveDays = parseInt(localStorage.getItem('consecutiveDays') || '0');
                state.weeklyStreak = parseInt(localStorage.getItem('weeklyStreak') || '0');
                state.lastPlayedDate = localStorage.getItem('lastPlayedDate') || null;
                state.lastCheckInTime = localStorage.getItem('lastCheckInTime') ? parseInt(localStorage.getItem('lastCheckInTime')) : null;
                state.completedTasks = JSON.parse(localStorage.getItem('completedTasks') || '[]');
                state.workshopAccess = localStorage.getItem('workshopAccess') === 'true';
                state.achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
                state.mysteryBoxes = parseInt(localStorage.getItem('mysteryBoxes') || '0');
                // Load spins, ensuring default structure if missing
                const savedSpins = JSON.parse(localStorage.getItem('wheelSpins') || '{}');
                wheelTypes.forEach(type => {
                    state.wheelSpins[type] = savedSpins[type] || 0;
                });
                state.lastDailySpinReset = localStorage.getItem('lastDailySpinReset') || null;
                state.challengeCompletedToday = JSON.parse(localStorage.getItem('challengeCompletedToday') || '{}');

                const savedLeaderboard = JSON.parse(localStorage.getItem('leaderboard') || 'null') || [];
                state.leaderboard = mergeLeaderboards(state.leaderboard, savedLeaderboard);
                ensureUserInLeaderboard();

                // Save initial state if missing
                if (!localStorage.getItem('challenges')) saveData(['challenges']);
                if (!localStorage.getItem('leaderboard')) saveData(['leaderboard']);
                if (!localStorage.getItem('wheelSpins')) saveData(['wheelSpins']);
                if (!localStorage.getItem('challengeCompletedToday')) saveData(['challengeCompletedToday']);

                console.log("State loaded:", JSON.parse(JSON.stringify(state)));

                checkDailyReset();
                updateUserLevel();
                updateUI();
                startCountdown();
                showInitialSection();

             } catch (error) {
                 console.error('Initialization error with LocalStorage:', error);
                 showNotification('Failed to load local data. Using defaults.', 'error');
                 // Fallback to defaults if load fails badly
                 state = initializeState(); // Reset to defaults again
                 state.challenges = initializeChallenges();
                 ensureUserInLeaderboard();
                 updateUI();
                 showInitialSection();
             }
        }

        // --- State Saving & Management ---
        function saveData(keys) {
            // console.log(`Saving keys to LocalStorage: ${keys.join(', ')}`); // Less verbose
            keys.forEach(key => {
                 try {
                    let valueToSave;
                     switch (key) {
                        case 'challenges': case 'challengeHistory': case 'completedTasks':
                        case 'leaderboard': case 'achievements': case 'wheelSpins':
                        case 'challengeCompletedToday': // Save this object
                             valueToSave = JSON.stringify(state[key]);
                             break;
                         case 'workshopAccess':
                            valueToSave = state[key] ? 'true' : 'false';
                            break;
                        default: // numbers, strings, nulls
                             valueToSave = state[key];
                            break;
                     }
                    if (valueToSave !== null && valueToSave !== undefined) {
                         localStorage.setItem(key, valueToSave);
                    } else {
                         localStorage.removeItem(key);
                    }
                 } catch (error) {
                     console.error(`Error saving '${key}' to LocalStorage:`, error);
                     showNotification(`Error saving ${key}`, 'error');
                 }
             });
             // console.log(`Save operation completed.`); // Less verbose
        }

        function mergeLeaderboards(defaultBoard, savedBoard) { /* ... (no changes needed) ... */
            const merged = [...defaultBoard];
            const defaultUserIds = new Set(defaultBoard.map(u => u.userId));
            savedBoard.forEach(savedUser => {
                if (!defaultUserIds.has(savedUser.userId)) {
                    merged.push(savedUser);
                } else {
                    const defaultUser = merged.find(u => u.userId === savedUser.userId);
                    if (defaultUser && savedUser.points > defaultUser.points) {
                        defaultUser.points = savedUser.points;
                    }
                }
            });
            return merged;
        }
        function ensureUserInLeaderboard() { /* ... (no changes needed) ... */
             const userEntry = state.leaderboard.find(p => p.userId === state.userId);
             if (!userEntry) {
                 console.log(`User ${state.userId} not found in leaderboard, adding.`);
                 state.leaderboard.push({ userId: state.userId, name: state.userName, points: state.points });
             } else {
                if (userEntry.points !== state.points || userEntry.name !== state.userName) {
                    console.log(`Updating leaderboard entry for user ${state.userId}`);
                    userEntry.points = state.points;
                    userEntry.name = state.userName;
                }
             }
        }

        // --- UI Update Functions ---
        function showNotification(message, type = 'info') { /* ... (no changes needed) ... */
            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-bg-${type === 'error' ? 'danger' : (type === 'success' ? 'success' : 'primary')} border-0`;
            toast.setAttribute('role', 'alert'); toast.setAttribute('aria-live', 'assertive'); toast.setAttribute('aria-atomic', 'true');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>`;
            document.querySelector('.toast-container').appendChild(toast);
            const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
            bsToast.show();
            toast.addEventListener('hidden.bs.toast', () => { toast.remove(); });
        }

        function updateUI() {
            domElements.profilePhoto.src = state.userPhoto;
            domElements.profileNameDisplay.textContent = state.userName;
            domElements.profileNameDisplayInner.textContent = state.userName;
            domElements.pointsDisplay.textContent = `${state.points} $twote`;
            domElements.pointsValue.textContent = state.points;
            domElements.consecutiveDaysValue.textContent = state.consecutiveDays;
            domElements.weeklyStreakValue.textContent = state.weeklyStreak;
            domElements.energyValue.textContent = state.energyLevel;
            domElements.levelName.textContent = state.level;
            domElements.profileLevelDisplay.textContent = `Level: ${state.level}`;

            if (state.userId) {
                const botUsername = "ThirdEyeTestDevBot"; // Replace with your bot username
                domElements.referralLink.value = `https://t.me/${botUsername}?start=${state.userId}`;
            }
            updateDailyCheckInButtonState();
            updateLeaderboardUI();
            updateTaskButtons();
            updateWheelButtonLabels(); // Just update labels, enable/disable happens in check-in update
            updateAchievementsUI();
            updateMysteryBoxUI();
            updateReferralSpinsUI();
        }

        function updateReferralSpinsUI() {
            if (domElements.referralSpinsCount) {
               domElements.referralSpinsCount.textContent = state.wheelSpins.referral || 0;
            }
            // Enable/disable logic handled in updateDailyCheckInButtonState/updateWheelButtonsEnablement
        }

        function updateDailyCheckInButtonState() {
           const now = Date.now();
           const twentyFourHours = 24 * 60 * 60 * 1000;
           const canCheckIn = !state.lastCheckInTime || (now - state.lastCheckInTime >= twentyFourHours);

            if (canCheckIn) {
                domElements.dailyCheckInBtn.disabled = false;
                domElements.dailyCheckInBtn.textContent = "Daily Check-In";
                domElements.countdownDisplay.textContent = 'Check-in available!';
                domElements.spinInfo.textContent = 'Complete Daily Check-In to enable spins.';
            } else {
                domElements.dailyCheckInBtn.disabled = true;
                domElements.dailyCheckInBtn.textContent = "Checked In";
                domElements.spinInfo.textContent = 'Spins enabled for today!';
                startCountdown(); // Ensure countdown is running
            }
            updateWheelButtonsEnablement(); // Update wheel buttons based on check-in status
        }

        function updateWheelButtonLabels() {
            const buttons = document.querySelectorAll('.wheel-button');
            buttons.forEach(button => {
                const wheelType = button.dataset.wheel;
                if (!wheelType) return;

                const spinsLeft = state.wheelSpins[wheelType] || 0;
                const baseHtml = button.innerHTML.split('(')[0].trim(); // Get HTML before parenthesis

                if (wheelType === 'referral') {
                    // Special handling for referral button text structure
                    if (domElements.referralSpinsCount) domElements.referralSpinsCount.textContent = spinsLeft;
                } else {
                    button.innerHTML = `${baseHtml} (${spinsLeft})`;
                }
            });
        }

        function updateWheelButtonsEnablement() {
             const now = Date.now();
             const twentyFourHours = 24 * 60 * 60 * 1000;
             const checkedInToday = state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours);
             const buttons = document.querySelectorAll('.wheel-button');

             buttons.forEach(button => {
                 const wheelType = button.dataset.wheel;
                 if (!wheelType) return;

                 const spinsLeft = state.wheelSpins[wheelType] || 0;
                 const canSpin = checkedInToday && spinsLeft > 0;
                 button.disabled = !canSpin;

                 if (!checkedInToday) {
                    button.title = "Complete daily check-in first";
                 } else if (spinsLeft <= 0) {
                     button.title = `No ${capitalizeFirstLetter(wheelType)} spins left for today`;
                 } else {
                     button.title = `Click to spin (${spinsLeft} left)`;
                 }
             });
         }

        function updateLeaderboardUI() { /* ... (no changes needed) ... */
            state.leaderboard.sort((a, b) => b.points - a.points);
            domElements.leaderboard.innerHTML = state.leaderboard.slice(0, 100).map((player, index) => `
                <tr class="${player.userId === state.userId ? 'table-primary' : ''}">
                    <td>${index + 1}</td>
                    <td>${player.name || 'Anonymous'}</td>
                    <td>${player.points}</td>
                </tr>
            `).join('');
           if(state.leaderboard.length === 0) {
               domElements.leaderboard.innerHTML = '<tr><td colspan="3" class="text-center">Leaderboard is empty.</td></tr>';
           }
        }
        function updateTaskButtons() { /* ... (no changes needed) ... */
             const taskButtons = {
                 twitter: document.getElementById('twitterTaskBtn'), telegram: document.getElementById('telegramTaskBtn'),
                 instagram: document.getElementById('instagramTaskBtn'), youtube: document.getElementById('youtubeTaskBtn')
             };
             for (const taskKey in taskButtons) {
                 const button = taskButtons[taskKey];
                 if (button) {
                     if (state.completedTasks.includes(taskKey)) {
                         button.disabled = true; button.textContent = 'Done';
                         button.classList.remove('btn-custom'); button.classList.add('btn-success');
                     } else {
                         button.disabled = false; button.textContent = 'Verify';
                         button.classList.remove('btn-success'); button.classList.add('btn-custom');
                     }
                 }
             }
        }
        function updateAchievementsUI() { /* ... (no changes needed) ... */
             if (!domElements.achievementsList) return;
             if (state.achievements.length === 0) {
                 domElements.achievementsList.innerHTML = '<li><i class="fas fa-hourglass-start"></i> No achievements yet</li>';
                 return;
             }
             domElements.achievementsList.innerHTML = state.achievements.map(key => {
                 const achievement = achievementsConfig[key];
                 if (!achievement) return '';
                 return `<li title="${achievement.description}"><i class="fas ${achievement.icon}"></i> ${achievement.name}</li>`;
             }).join('');
        }
        function updateMysteryBoxUI() { /* ... (no changes needed) ... */
           if (!domElements.mysteryBoxCount || !domElements.openMysteryBoxBtn) return;
           domElements.mysteryBoxCount.textContent = state.mysteryBoxes;
           domElements.openMysteryBoxBtn.disabled = state.mysteryBoxes <= 0;
        }


        // --- Navigation ---
        function showInitialSection() {
             const firstSection = state.birthdate ? 'wellnessManager' : 'horoscopeForm';
             sectionStack = [firstSection];
             showSection(firstSection, true);
        }
        function showSection(sectionId, isInitial = false) { /* ... (no changes needed) ... */
            if (!isInitial && sectionId !== sectionStack[sectionStack.length - 1]) {
                sectionStack.push(sectionId);
            } else if (isInitial) {
               sectionStack = [sectionId];
            }
            console.log("Showing section:", sectionId, "Stack:", sectionStack);
            sections.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = id === sectionId ? 'block' : 'none';
            });
            if (window.Telegram?.WebApp) {
               if (sectionStack.length > 1) Telegram.WebApp.BackButton.show();
               else Telegram.WebApp.BackButton.hide();
            }
            // Section specific updates
            switch (sectionId) {
                case 'wellnessManager': loadChallenges(); break;
                case 'dailyChallenges': displayDailyChallenges(state.currentChallengeDuration); break;
                case 'playerProfile': loadProfileHistory(); updateLeaderboardUI(); updateAchievementsUI(); break;
                case 'gamePage': updateWheelButtonLabels(); updateWheelButtonsEnablement(); updateMysteryBoxUI(); updateReferralSpinsUI(); break;
            }
        }
        function setupBackButton() {
             if (window.Telegram?.WebApp) {
                 Telegram.WebApp.BackButton.onClick(() => {
                     console.log("Back button clicked. Stack before pop:", sectionStack);
                     if (sectionStack.length > 1) {
                         sectionStack.pop();
                         const previousSection = sectionStack[sectionStack.length - 1];
                         console.log("Navigating back to:", previousSection);
                         showSection(previousSection, true);
                     } else {
                         console.log("Back button clicked, but stack is too small.");
                         // Optional: Close app if back is pressed on the first screen
                         // Telegram.WebApp.close();
                     }
                 });
             }
        }


        // --- Core Game Logic ---
        function awardPoints(amount, reason = "") {
             const pointsToAward = parseInt(amount); // Ensure it's a number
             if (isNaN(pointsToAward) || pointsToAward <= 0) {
                 console.warn(`Invalid points amount received: ${amount}. Reason: ${reason}. Award cancelled.`);
                 return;
             }

             state.points += pointsToAward;
             console.log(`Awarded ${pointsToAward} points. Reason: ${reason}. New total: ${state.points}`);

             // Update leaderboard state
             const playerIndex = state.leaderboard.findIndex(p => p.userId === state.userId);
             if (playerIndex > -1) {
                 state.leaderboard[playerIndex].points = state.points;
             } else {
                 state.leaderboard.push({ userId: state.userId, name: state.userName, points: state.points });
             }

             updateUserLevel(); // Check for level up AFTER points are added
             // Save relevant data. Level is saved within updateUserLevel if changed.
             saveData(['points', 'leaderboard']);

             updateUI(); // Update points display everywhere
             showNotification(`+${pointsToAward} $twote earned! ✨`, 'success');
         }

        function updateUserLevel() { /* ... (no changes needed) ... */
           let currentLevel = state.level;
           let newLevel = levels[0].name;
           for (let i = levels.length - 1; i >= 0; i--) {
               if (state.points >= levels[i].points) { newLevel = levels[i].name; break; }
           }
           if (newLevel !== currentLevel) {
               state.level = newLevel;
               console.log(`Level up! Reached ${newLevel}`);
               showNotification(`Congratulations! You've reached Level: ${newLevel}! 🎉`, 'success');
               saveData(['level']);
               if (newLevel === "Adept") checkAndGrantAchievement('LEVEL_ADEPT');
               updateUI();
           }
        }

        function updateEnergyLevel(before = null, after = null) { /* ... (no changes needed) ... */
           if (before !== null && after !== null) {
               state.energyLevel = Math.min(Math.max(Math.round((before + after) / 2), 0), 100);
               domElements.energyValue.textContent = state.energyLevel;
               saveData(['energyLevel']);
            }
        }

        function checkDailyReset() {
            const today = new Date().toISOString().split('T')[0];
            console.log(`Checking daily reset: Today is ${today}, Last played was ${state.lastPlayedDate}`);

            if (state.lastPlayedDate === today) {
                console.log("Already played today, no change to streaks.");
                resetDailySpinsIfNeeded(today); // Still check spins reset
                clearChallengeCompletionFlagIfNeeded(today); // Clear yesterday's completion flag if needed
                return;
             }

             // Day has changed
             resetDailySpinsIfNeeded(today);
             clearChallengeCompletionFlagIfNeeded(today); // Clear flags for the *new* day

             if (!state.lastPlayedDate) {
                state.consecutiveDays = 0; state.weeklyStreak = 0;
                console.log("First play, streaks set to 0.");
                return;
             }

             const todayDate = new Date(today);
             const lastPlayedDateObj = new Date(state.lastPlayedDate);
             const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
             const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
             console.log(`Difference in days: ${diffDays}`);

             if (diffDays > 1) {
                state.consecutiveDays = 0; state.weeklyStreak = 0;
                console.log("Missed days, resetting streaks to 0.");
                saveData(['consecutiveDays', 'weeklyStreak']);
             }
             // If diffDays === 1, streak increment happens during check-in.

             updateDailyCheckInButtonState(); // Update button based on cooldown
        }

        function clearChallengeCompletionFlagIfNeeded(today) {
            // Clear the completion flag for the *current* day if it exists from a previous session on the same day
            if(state.challengeCompletedToday[today]) {
                delete state.challengeCompletedToday[today];
                console.log(`Cleared challenge completion flag for today (${today}).`);
                saveData(['challengeCompletedToday']);
            }
            // Optional: Clean up old flags older than yesterday?
             const yesterday = new Date();
             yesterday.setDate(yesterday.getDate() - 1);
             const yesterdayStr = yesterday.toISOString().split('T')[0];
             let changed = false;
             for (const dateKey in state.challengeCompletedToday) {
                 if (dateKey !== today && dateKey !== yesterdayStr) {
                     delete state.challengeCompletedToday[dateKey];
                     changed = true;
                 }
             }
             if(changed) saveData(['challengeCompletedToday']);

        }

        function resetDailySpinsIfNeeded(today) { /* ... (no changes needed) ... */
           if (state.lastDailySpinReset !== today) {
               console.log("New day detected, resetting daily wheel spins to 1.");
               wheelTypes.forEach(type => {
                   if (type !== 'referral') { state.wheelSpins[type] = 1; }
               });
               state.lastDailySpinReset = today;
               saveData(['wheelSpins', 'lastDailySpinReset']);
               updateWheelButtonLabels(); // Update UI for spins
           } else {
                // console.log("Daily spins already reset for today."); // Less verbose
           }
        }


        function dailyCheckIn() { /* ... (Mostly unchanged, added saveData for streaks) ... */
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            if (state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours)) {
                showNotification('You can check in again after the 24-hour cooldown.', 'warning'); return;
            }
            domElements.dailyCheckInBtn.disabled = true;
            domElements.dailyCheckInBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking In...';
            const today = new Date().toISOString().split('T')[0];
            let pointsAwarded = 5; let newWeeklyStreak = false;

            resetDailySpinsIfNeeded(today); // Grant daily spins

            // Handle Streaks
            if (state.lastPlayedDate) {
                const lastPlayedDateObj = new Date(state.lastPlayedDate);
                const todayDate = new Date(today);
                const diffTime = todayDate.getTime() - lastPlayedDateObj.getTime();
                const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                if (diffDays === 1) {
                    state.consecutiveDays++; pointsAwarded += Math.min(state.consecutiveDays, 5);
                    console.log(`Streak maintained! Day ${state.consecutiveDays}. Bonus: ${Math.min(state.consecutiveDays, 5)}`);
                    if (state.consecutiveDays > 0 && state.consecutiveDays % 7 === 0) {
                        state.weeklyStreak++; newWeeklyStreak = true;
                        console.log(`Weekly streak completed! Week ${state.weeklyStreak}.`);
                        awardMysteryBox(1, "Weekly Streak");
                    }
                    if (state.consecutiveDays >= 7) checkAndGrantAchievement('7_DAY_STREAK');
                } else if (diffDays > 1) {
                    state.consecutiveDays = 1; state.weeklyStreak = 0;
                    console.log("Streak broken, starting new streak at Day 1.");
                } else { if (state.lastPlayedDate !== today) state.consecutiveDays = 1; }
            } else { state.consecutiveDays = 1; state.weeklyStreak = 0; console.log("First check-in, starting streak at Day 1."); }
            checkAndGrantAchievement('FIRST_CHECKIN');

            state.lastPlayedDate = today; state.lastCheckInTime = now;
            // Save all relevant state changes together
            saveData(['lastPlayedDate', 'lastCheckInTime', 'consecutiveDays', 'weeklyStreak', 'achievements']); // Include achievements if potentially granted
            awardPoints(pointsAwarded, "Daily Check-in"); // This saves points/leaderboard/level

            updateUI();
            let notificationMsg = `Checked in! Day ${state.consecutiveDays}.`;
            if(newWeeklyStreak) notificationMsg += ` Weekly Streak: ${state.weeklyStreak}!`;
            showNotification(notificationMsg, 'success');
        }

        function startCountdown() { /* ... (no changes needed) ... */
            if (window.checkinCountdownInterval) clearInterval(window.checkinCountdownInterval);
            if (!state.lastCheckInTime) { domElements.countdownDisplay.textContent = 'Check-in available!'; updateDailyCheckInButtonState(); return; }
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const endTime = state.lastCheckInTime + twentyFourHours;
            function updateCountdownDisplay() {
                const now = Date.now(); const timeLeft = endTime - now;
                if (timeLeft <= 0) {
                    domElements.countdownDisplay.textContent = 'Check-in available!';
                    updateDailyCheckInButtonState(); clearInterval(window.checkinCountdownInterval); return;
                }
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                domElements.countdownDisplay.textContent = `Next check-in: ${hours}h ${minutes}m ${seconds}s`;
                domElements.dailyCheckInBtn.disabled = true; domElements.dailyCheckInBtn.textContent = "Checked In";
            }
            updateCountdownDisplay();
            window.checkinCountdownInterval = setInterval(updateCountdownDisplay, 1000);
        }


        // --- Challenges Logic ---
        function initializeChallenges() { /* ... (no changes needed) ... */
             return Array.from({ length: 150 }, (_, i) => {
                 const goalIndex = i % dailyGoals.length;
                 return { day: i + 1, goal: dailyGoals[goalIndex].goal, meditation: dailyGoals[goalIndex].meditation, task1: dailyGoals[goalIndex].task1, task2: dailyGoals[goalIndex].task2, points: dailyGoals[goalIndex].points, completed: false, };
             });
        }
        function getCompletedDaysCount(maxDay) { /* ... (no changes needed) ... */
           return state.challenges.slice(0, maxDay).filter(ch => ch.completed).length;
        }
        function isChallengeUnlocked(days) { /* ... (no changes needed) ... */
             switch (days) {
                 case 7: return true; case 21: return getCompletedDaysCount(7) === 7;
                 case 41: return getCompletedDaysCount(21) === 21; case 66: return state.workshopAccess && getCompletedDaysCount(41) === 41;
                 case 150: return state.workshopAccess && getCompletedDaysCount(66) === 66; default: return false;
             }
        }
        function loadChallenges() { /* ... (no changes needed) ... */
           const challengeDurations = [7, 21, 41, 66, 150];
           const challengeIcons = { 7: 'fas fa-sun', 21: 'fas fa-seedling', 41: 'fas fa-star', 66: 'fas fa-moon', 150: 'fas fa-crown' };
           const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
           domElements.challengeOptions.innerHTML = '';
           challengeDurations.forEach(days => {
               const isUnlocked = isChallengeUnlocked(days); const iconClass = challengeIcons[days] || 'fas fa-question-circle';
               const title = challengeTitles[days] || `${days}-Day`; const requiresWorkshop = days > 41;
               const prevTierDays = days === 21 ? 7 : (days === 41 ? 21 : (days === 66 ? 41 : (days === 150 ? 66 : 0)));
               const prevTierTitle = challengeTitles[prevTierDays] || `${prevTierDays}-Day`;
               const div = document.createElement('div'); div.className = `challenge-div ${isUnlocked ? '' : 'locked'}`;
               let content = `<i class="${iconClass} challenge-icon"></i><h3>${days}-Day: ${title}</h3>`;
               if (isUnlocked) { content += `<button class="btn btn-custom start-challenge-btn mt-2" data-days="${days}">Begin ${title}</button>`; }
               else {
                   if (requiresWorkshop && !state.workshopAccess) {
                       if (getCompletedDaysCount(prevTierDays) !== prevTierDays) { content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`; }
                       else { content += `<p class="warning-text">Requires Workshop Access</p><button class="btn btn-custom enroll-btn mt-2" data-days="${days}" style="font-size: 0.9em;">Enroll Info</button><button class="btn btn-secondary attended-btn mt-2 ms-1" data-days="${days}" style="font-size: 0.9em;">Enter Code</button>`; }
                   } else if (requiresWorkshop && state.workshopAccess) { content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`; }
                   else { content += `<p class="warning-text">Complete the ${prevTierTitle} challenge first.</p>`; }
               }
               div.innerHTML = content; domElements.challengeOptions.appendChild(div);
           });
           // Event listener is added in setupEventListeners
        }

        // DUBAI TIME CHECK HELPER
        function isPastMidnightDubai() {
            const now = new Date();
            // Create a date object representing the current time in Dubai (UTC+4)
            const dubaiTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Dubai"}));
            // console.log("Current Dubai Time:", dubaiTime.getHours(), ":", dubaiTime.getMinutes()); // For debugging
            // Check if it's past midnight (hour 0)
            return true; // For simplicity during testing - ALWAYS allow unlock after completion.
            // return dubaiTime.getHours() >= 0; // Real check: has the day started in Dubai?
            // OR, more accurately, check if the *date* in Dubai is later than the last completion date.
            // For this implementation, just checking the time is simpler. Let's assume unlocking *at* midnight is fine.
        }

        function displayDailyChallenges(days) {
            if (!days) { showSection('wellnessManager'); return; }
            const challengeTitles = { 7: 'Foundation', 21: 'Habit Building', 41: 'Deepening', 66: 'Integration', 150: 'Mastery' };
            domElements.challengeTitle.textContent = `${days}-Day Challenge: ${challengeTitles[days] || ''}`;
            domElements.dailyChallengeList.innerHTML = '';

            let firstUncompletedIndex = state.challenges.slice(0, days).findIndex(ch => !ch.completed);
            if (firstUncompletedIndex === -1) firstUncompletedIndex = days; // All completed

            const todayStr = new Date().toISOString().split('T')[0];
            const pastMidnightDubai = isPastMidnightDubai(); // Check if it's past midnight in Dubai

            state.challenges.slice(0, days).forEach((challenge, index) => {
                const card = document.createElement('div');
                card.className = 'challenge-div mb-2';

                const isPreviousCompleted = index === 0 || state.challenges[index - 1].completed;
                const isTodayFirstUncompleted = index === firstUncompletedIndex;
                const wasPreviousCompletedToday = index > 0 && state.challengeCompletedToday[todayStr]; // Check if the *previous* challenge was the one completed today

                let canStart = false;
                let lockReason = "";

                if (challenge.completed) {
                    // Already completed, nothing to do.
                } else if (isTodayFirstUncompleted) {
                    // This is the next challenge to be done.
                    if (isPreviousCompleted) {
                        // Previous is done. Now check the time lock *if* the previous was done *today*.
                        if (wasPreviousCompletedToday && !pastMidnightDubai) {
                             canStart = false;
                             lockReason = `<i class="fas fa-clock"></i> Available after midnight (Dubai Time)`;
                        } else {
                             // Either previous was completed on a prior day, OR it's past midnight Dubai.
                             canStart = true;
                        }
                    } else {
                        // Should not happen if firstUncompletedIndex logic is correct, but as fallback:
                        canStart = false;
                        lockReason = `<i class="fas fa-lock"></i> Complete Day ${challenge.day - 1} first`;
                    }
                } else {
                     // This is not the first uncompleted day (either already completed or further in future)
                     canStart = false;
                     if (index < firstUncompletedIndex) {
                         // Should be completed, error state?
                         lockReason = `Error: Should be completed`;
                     } else {
                         // Future challenge
                         lockReason = `<i class="fas fa-lock"></i> Complete Day ${firstUncompletedIndex + 1} first`;
                     }
                }


                 let content = `<h4 style="color: var(--challenge-description-color); font-size: 1.1rem;">Day ${challenge.day}: ${challenge.goal}</h4>`;

                 if (challenge.completed) {
                     content += `<p style="color: green; font-weight: bold;"><i class="fas fa-check-circle"></i> Completed (+${challenge.points || 0} $twote)</p>`;
                 } else if (canStart) {
                     content += `<button class="btn btn-custom btn-sm mt-1" data-day="${challenge.day}">Start Day ${challenge.day}</button>`;
                 } else {
                     content += `<p class="warning-text" style="font-size: 0.9em;">${lockReason || 'Locked'}</p>`;
                     card.classList.add('locked');
                 }
                 card.innerHTML = content;
                 domElements.dailyChallengeList.appendChild(card);
            });

            domElements.dailyChallengeList.querySelectorAll('button.btn-custom').forEach(btn => {
                btn.addEventListener('click', () => startChallenge(parseInt(btn.getAttribute('data-day'))));
            });
        }

        function startChallenge(day) { /* ... (no changes needed) ... */
           const challenge = state.challenges.find(c => c.day === day);
           if (!challenge) return;
            state.currentChallengeDay = day; state.energyBefore = null;
            document.getElementById('energyLogModalTitle').textContent = `Day ${day}: ${challenge.goal} - Before`;
            domElements.energyLogPrompt.textContent = "Log your current energy level (0-100%).";
            domElements.energySlider.value = 50; domElements.energySliderValue.textContent = '50%';
            domElements.challengeTasks.style.display = 'none'; domElements.proofWarning.style.display = 'none';
            domElements.submitEnergyLog.textContent = 'Confirm Energy & View Tasks';
            domElements.submitEnergyLog.setAttribute('data-stage', 'before'); domElements.submitEnergyLog.disabled = false;
            domElements.task1Proof.value = ''; domElements.task2Proof.value = '';
            energyLogModalInstance.show();
        }

        domElements.energySlider.addEventListener('input', () => { domElements.energySliderValue.textContent = `${domElements.energySlider.value}%`; });
        [domElements.task1Proof, domElements.task2Proof].forEach(input => {
            input.addEventListener('change', () => {
                if (domElements.submitEnergyLog.getAttribute('data-stage') === 'after') {
                    const task1File = domElements.task1Proof.files[0]; const task2File = domElements.task2Proof.files[0];
                    domElements.submitEnergyLog.disabled = !(task1File && task2File);
                    domElements.proofWarning.style.display = (task1File && task2File) ? 'none' : 'block';
                }
            });
        });

        domElements.submitEnergyLog.addEventListener('click', () => { // Removed async
            const sliderValue = parseInt(domElements.energySlider.value);
            const stage = domElements.submitEnergyLog.getAttribute('data-stage');
            const challenge = state.challenges.find(c => c.day === state.currentChallengeDay);
            if (!challenge) { energyLogModalInstance.hide(); return; }

            domElements.submitEnergyLog.disabled = true;

            if (stage === 'before') {
                state.energyBefore = sliderValue; console.log(`Energy Before (Day ${state.currentChallengeDay}): ${state.energyBefore}%`);
                document.getElementById('energyLogModalTitle').textContent = `Day ${state.currentChallengeDay}: ${challenge.goal} - After`;
                domElements.energyLogPrompt.textContent = "Complete tasks & log your energy post-challenge.";
                domElements.challengeTasks.style.display = 'block'; domElements.meditationTask.textContent = challenge.meditation;
                domElements.task1Text.textContent = challenge.task1; domElements.task2Text.textContent = challenge.task2;
                domElements.energySlider.value = 50; domElements.energySliderValue.textContent = '50%';
                domElements.task1Proof.value = ''; domElements.task2Proof.value = '';
                domElements.submitEnergyLog.textContent = 'Submit Completion'; domElements.submitEnergyLog.setAttribute('data-stage', 'after');
                domElements.submitEnergyLog.disabled = true; domElements.proofWarning.style.display = 'block';
            } else if (stage === 'after') {
                const energyAfter = sliderValue; const task1File = domElements.task1Proof.files[0]; const task2File = domElements.task2Proof.files[0];
                if (!task1File || !task2File) {
                    showNotification('Please upload proof for both tasks.', 'error');
                    domElements.submitEnergyLog.disabled = false; domElements.proofWarning.style.display = 'block'; return;
                }
                console.log(`Energy After (Day ${state.currentChallengeDay}): ${energyAfter}%`);
                domElements.submitEnergyLog.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Processing...';

                // Use setTimeout to simulate async operation and allow UI to update
                setTimeout(() => {
                    try {
                        challenge.completed = true;
                        // Flag that *this specific challenge day* was completed today
                        const todayStr = new Date().toISOString().split('T')[0];
                        state.challengeCompletedToday[todayStr] = true; // Mark completion for today

                        state.challengeHistory.push({
                            day: state.currentChallengeDay, goal: challenge.goal, energyBefore: state.energyBefore,
                            energyAfter, task1ProofProvided: true, task2ProofProvided: true
                        });
                        updateEnergyLevel(state.energyBefore, energyAfter);

                        // --- NaN FIX ---
                        const pointsToAward = parseInt(challenge.points) || 0; // Ensure points is a number, default 0
                        awardPoints(pointsToAward, `Challenge Day ${state.currentChallengeDay}`);
                        // --- End NaN FIX ---


                        if(state.currentChallengeDuration === 7 && getCompletedDaysCount(7) === 7) { checkAndGrantAchievement('CHALLENGE_7_COMPLETE'); }
                        // Save all relevant data together
                        saveData(['challenges', 'challengeHistory', 'energyLevel', 'points', 'leaderboard', 'level', 'achievements', 'challengeCompletedToday']);

                        energyLogModalInstance.hide();
                        showNotification(`Day ${state.currentChallengeDay} completed! 🎉`, 'success');
                        displayDailyChallenges(state.currentChallengeDuration); // Refresh challenge list

                    } catch (error) {
                        console.error("Error processing challenge completion:", error);
                        showNotification('Error submitting completion. Please try again.', 'error');
                        domElements.submitEnergyLog.textContent = 'Submit Completion'; domElements.submitEnergyLog.disabled = false;
                    }
                }, 100); // Short delay
            }
        });


        // --- Workshop Access ---
        function showEnrollModal(days) { /* ... (no changes needed) ... */
            domElements.enrollName.textContent = state.userName; domElements.enrollEnergy.textContent = state.energyLevel;
            const canEnroll = state.energyLevel >= 70; domElements.submitEnrollment.disabled = !canEnroll;
            domElements.enrollRequirement.style.display = canEnroll ? 'none' : 'block';
            domElements.submitEnrollment.onclick = () => enroll(days); enrollModalInstance.show();
        }
        function enroll(days) { /* ... (no changes needed) ... */
            if (state.energyLevel < 70) { showNotification('Energy level must be 70% or higher!', 'error'); return; }
            state.workshopAccess = true; saveData(['workshopAccess']); enrollModalInstance.hide();
            loadChallenges(); showNotification(`Enrollment successful! Advanced challenges unlocked.`, 'success');
        }
        function showCodeModal(days) { /* ... (no changes needed) ... */
            domElements.workshopCode.value = ''; domElements.submitCode.onclick = () => submitCode(days);
            codeModalInstance.show();
        }
        function submitCode(days) { /* ... (no changes needed) ... */
            const code = domElements.workshopCode.value.trim();
            if (code.toLowerCase() === "wellness") {
                state.workshopAccess = true; saveData(['workshopAccess']); codeModalInstance.hide();
                loadChallenges(); showNotification(`Workshop code accepted! Access granted.`, 'success');
            } else { showNotification('Invalid workshop code.', 'error'); domElements.workshopCode.focus(); }
        }


        // --- Wheel Logic ---
        function drawWheelSegment(ctx, centerX, centerY, radius, startAngle, endAngle, color, text, textRadiusFactor = 0.6) {
            // Draw segment arc
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.closePath();
            ctx.fill();
            // Add subtle border
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw text, rotated
            ctx.save();
            ctx.translate(centerX, centerY);
            const textAngle = startAngle + (endAngle - startAngle) / 2;
            ctx.rotate(textAngle);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000'; // Black text for contrast on light segments
            // Adjust font size based on radius
             const fontSize = Math.max(Math.min(radius / 10, 14), 8); // Clamp font size
             ctx.font = `bold ${fontSize}px Nunito`;

            // Limit text length
            const maxTextWidth = radius * 0.5; // Max width based on radius
            let label = text;
            // Basic truncation if needed (better methods exist)
            // if (ctx.measureText(label).width > maxTextWidth && label.length > 10) {
            //     label = label.substring(0, 8) + '..';
            // }

            ctx.fillText(label, radius * textRadiusFactor, 0);
            ctx.restore();
        }

        function drawWheel(wheelType, rotationAngle = 0) {
            const canvas = domElements.wheelCanvas;
            const ctx = canvas.getContext('2d');
            const rewards = wheelRewardConfigs[wheelType];
            if (!rewards) return;

            const numSegments = rewards.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 5; // Small padding

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotationAngle); // Apply rotation
            ctx.translate(-centerX, -centerY);

            // Draw segments
            rewards.forEach((segment, index) => {
                const startAngle = index * anglePerSegment - Math.PI / 2 - anglePerSegment / 2; // Align first segment top-ish
                const endAngle = startAngle + anglePerSegment;
                drawWheelSegment(ctx, centerX, centerY, radius, startAngle, endAngle, segment.color || '#eee', segment.label);
            });

            // Optional: Add inner/outer decoration
            ctx.strokeStyle = var(--wheel-border-color);
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.stroke();
            ctx.fillStyle = var(--wheel-border-color);
            ctx.beginPath(); ctx.arc(centerX, centerY, radius * 0.1, 0, 2 * Math.PI); ctx.fill();

            ctx.restore(); // Restore context before pointer (pointer isn't rotated)
        }

        function showWheelModal(wheelType) {
            currentWheelType = wheelType;
            if (!wheelRewardConfigs[currentWheelType]) {
                showNotification("Invalid wheel type.", "error");
                return;
            }

            // Check spins and check-in status
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const checkedInToday = state.lastCheckInTime && (now - state.lastCheckInTime < twentyFourHours);
            const spinsLeft = state.wheelSpins[currentWheelType] || 0;

            if (!checkedInToday) {
                 showNotification('Please perform your Daily Check-In first!', 'warning');
                 return;
            }
             if (spinsLeft <= 0) {
                  showNotification(`No spins left for the ${capitalizeFirstLetter(currentWheelType)} wheel today.`, 'warning');
                  return;
             }


            domElements.wheelModalTitle.textContent = `${capitalizeFirstLetter(currentWheelType)} Wheel`;
            domElements.wheelResult.textContent = `Ready? ${spinsLeft} spin(s) left.`;
            domElements.spinTheWheelBtn.disabled = false;
            wheelSpinning = false;
            drawWheel(currentWheelType, currentRotation); // Draw initial state
            wheelModalInstance.show();
        }

        function triggerSpin() {
            if (wheelSpinning || !currentWheelType) return;

             // Double check spins (in case state changed while modal open)
             const spinsLeft = state.wheelSpins[currentWheelType] || 0;
             if (spinsLeft <= 0) {
                 showNotification(`No spins left for the ${capitalizeFirstLetter(currentWheelType)} wheel.`, 'error');
                 domElements.spinTheWheelBtn.disabled = true;
                 return;
             }

            wheelSpinning = true;
            domElements.spinTheWheelBtn.disabled = true;
            domElements.wheelResult.textContent = 'Spinning...';

            // Consume the spin
            state.wheelSpins[currentWheelType]--;
            saveData(['wheelSpins']); // Save immediately
            updateWheelButtonLabels(); // Update button in background
            updateReferralSpinsUI();

            const rewards = wheelRewardConfigs[currentWheelType];
            const numSegments = rewards.length;
            const anglePerSegment = (2 * Math.PI) / numSegments;

            // Spin parameters
            const minRotations = 5;
            const maxExtraRotations = 8;
            const spinDuration = Math.random() * 2000 + 3000; // 3-5 seconds

            const totalRotations = minRotations + Math.random() * maxExtraRotations;
            const randomStopAngle = Math.random() * 2 * Math.PI; // Random final angle
            const targetRotation = totalRotations * 2 * Math.PI + randomStopAngle;

            const startTime = performance.now();

            function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            function animateSpin(currentTime) {
                const elapsedTime = currentTime - startTime;
                let progress = Math.min(elapsedTime / spinDuration, 1);
                progress = easeOutCubic(progress); // Apply easing

                const rotation = currentRotation + progress * (targetRotation - currentRotation);
                drawWheel(currentWheelType, rotation);

                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    // Spin finished
                    currentRotation = rotation % (2 * Math.PI); // Keep track of final position for next draw
                    const winningAngle = (currentRotation + Math.PI / 2 + anglePerSegment / 2) % (2 * Math.PI); // Angle relative to top pointer
                    const winningIndex = Math.floor(winningAngle / anglePerSegment);
                    const winner = rewards[winningIndex % numSegments]; // Use modulo for safety

                    console.log(`Wheel stopped. Index: ${winningIndex}, Reward:`, winner);
                    applyReward(winner);

                    // Re-enable button after a short delay
                    setTimeout(() => {
                         wheelSpinning = false;
                         // Check if MORE spins are available before re-enabling
                          const remainingSpins = state.wheelSpins[currentWheelType] || 0;
                          domElements.spinTheWheelBtn.disabled = remainingSpins <= 0;
                          if (remainingSpins <= 0) {
                              domElements.wheelResult.innerHTML += ` <br/>No more spins left.`;
                          } else {
                               domElements.wheelResult.innerHTML += ` <br/>${remainingSpins} spin(s) left.`;
                          }
                    }, 1000); // Delay before re-enabling spin button
                }
            }
            requestAnimationFrame(animateSpin);
        }

        function applyReward(reward) {
            if (!reward) { domElements.wheelResult.textContent = 'Oops! Spin Error.'; return; }

            let resultMessage = `You won: ${reward.label}!`;

            switch (reward.type) {
                case 'points':
                    awardPoints(reward.value, `${capitalizeFirstLetter(currentWheelType)} Wheel`);
                    break;
                case 'energy':
                    state.energyLevel = Math.min(100, state.energyLevel + reward.value);
                    saveData(['energyLevel']);
                    resultMessage += ` (+${reward.value}% Energy)`;
                    updateUI(); // Update energy display
                    break;
                case 'mystery_box':
                    awardMysteryBox(reward.value, `${capitalizeFirstLetter(currentWheelType)} Wheel`);
                    break;
                case 'message':
                    // Just display the message from the label
                    break;
                case 'spin_again':
                     resultMessage += ` Spinning again!`;
                     // Give back the spin consumed
                     state.wheelSpins[currentWheelType]++;
                     saveData(['wheelSpins']);
                     updateWheelButtonLabels();
                     updateReferralSpinsUI();
                     // Trigger another spin automatically after a delay
                     setTimeout(triggerSpin, 1500);
                     break;
                default:
                    console.warn("Unknown reward type:", reward.type);
            }

            domElements.wheelResult.textContent = resultMessage;
        }


        // --- Mystery Box & Achievements ---
        function awardMysteryBox(count = 1, reason = "") { /* ... (no changes needed) ... */
            state.mysteryBoxes += count; console.log(`Awarded ${count} Mystery Box(es). Reason: ${reason}. Total: ${state.mysteryBoxes}`);
            saveData(['mysteryBoxes']); showNotification(`You received ${count} Mystery Box! 🎁`, 'success'); updateMysteryBoxUI();
        }
        function openMysteryBox() { /* ... (Mostly unchanged, added achievement check) ... */
            if (state.mysteryBoxes <= 0) { showNotification("No Mystery Boxes to open.", 'warning'); return; }
            domElements.openMysteryBoxBtn.disabled = true; state.mysteryBoxes--;

            const possibleRewards = [
                { type: 'points', value: 15 }, { type: 'points', value: 25 }, { type: 'points', value: 50 },
                { type: 'spin', wheel: 'referral', value: 1 }, { type: 'energy', value: 5 }
            ];
            const reward = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
            let message = "You opened a Mystery Box and found ";
            if (reward.type === 'points') { message += `${reward.value} $twote!`; awardPoints(reward.value, "Mystery Box"); }
            else if (reward.type === 'spin') {
                message += `${reward.value} bonus spin for the ${capitalizeFirstLetter(reward.wheel)} wheel!`;
                state.wheelSpins[reward.wheel] = (state.wheelSpins[reward.wheel] || 0) + reward.value;
                saveData(['wheelSpins']); updateReferralSpinsUI();
            } else if (reward.type === 'energy') {
                message += `a +${reward.value}% Energy boost!`; state.energyLevel = Math.min(100, state.energyLevel + reward.value);
                saveData(['energyLevel']);
            }

            checkAndGrantAchievement('OPEN_MYSTERY_BOX'); // Check achievement
            // Save relevant data together
            saveData(['mysteryBoxes', 'achievements', 'energyLevel', 'points', 'leaderboard', 'level']);
            showNotification(message, 'success'); updateMysteryBoxUI(); updateUI();
        }
        function checkAndGrantAchievement(achievementKey) { /* ... (no changes needed) ... */
            if (!achievementsConfig[achievementKey]) return;
            if (!state.achievements.includes(achievementKey)) {
                state.achievements.push(achievementKey); const achievement = achievementsConfig[achievementKey];
                console.log(`Achievement Unlocked: ${achievement.name}`);
                showNotification(`Achievement Unlocked: ${achievement.name}! 🏅`, 'success');
                saveData(['achievements']); updateAchievementsUI();
            }
        }


        // --- Profile & History ---
        function loadProfileHistory() { /* ... (no changes needed) ... */
            const recentHistory = state.challengeHistory.slice(-15).reverse();
            if (recentHistory.length === 0) { domElements.profileHistory.innerHTML = '<tr><td colspan="6" class="text-center">No challenge history yet.</td></tr>'; return; }
            domElements.profileHistory.innerHTML = recentHistory.map(entry => `
                <tr><td>${entry.day}</td><td>${entry.goal}</td><td>${entry.energyBefore}%</td><td>${entry.energyAfter}%</td>
                <td class="text-center">${entry.task1ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td>
                <td class="text-center">${entry.task2ProofProvided ? '<i class="fas fa-check text-success"></i>' : '<i class="fas fa-times text-danger"></i>'}</td></tr>`).join('');
        }
        function deleteProgress() { /* ... (no changes needed, uses localStorage) ... */
            const confirmed = confirm('Are you sure you want to delete ALL progress? This cannot be undone.');
            if (confirmed) {
                console.log("User confirmed deletion.");
                document.body.insertAdjacentHTML('beforeend', '<div id="temp-loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 1.2em;">Deleting...</div>');
                const userId = state.userId; const userName = state.userName; const userPhoto = state.userPhoto;
                state = initializeState(); state.userId = userId; state.userName = userName; state.userPhoto = userPhoto;
                ensureUserInLeaderboard();
                const keysToRemove = [
                    'energyLevel', 'points', 'level', 'challenges', 'challengeHistory', 'birthdate',
                    'consecutiveDays', 'weeklyStreak', 'lastPlayedDate', 'lastCheckInTime', 'completedTasks',
                    'workshopAccess', 'leaderboard', 'achievements', 'mysteryBoxes', 'wheelSpins', 'lastDailySpinReset', 'challengeCompletedToday'
                ];
                try {
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    saveData(['leaderboard', 'level', 'challenges', 'wheelSpins', 'challengeCompletedToday']); // Save essential defaults
                    console.log("Progress deleted."); showNotification('Your progress has been reset.', 'success');
                    updateUI(); loadProfileHistory(); showInitialSection();
                } catch (error) { console.error("Error deleting progress:", error); showNotification('Failed to clear data.', 'error'); }
                finally { const tempLoading = document.getElementById('temp-loading'); if (tempLoading) tempLoading.remove(); }
            } else { console.log("User cancelled deletion."); }
        }


        // --- Tasks & Referrals ---
        function completeTask(taskKey) { /* ... (no changes needed) ... */
            if (state.completedTasks.includes(taskKey)) { showNotification('Task already completed.', 'info'); return; }
            const button = document.getElementById(`${taskKey}TaskBtn`);
            if (button) { button.disabled = true; button.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Verifying...'; }
            setTimeout(() => {
                state.completedTasks.push(taskKey); saveData(['completedTasks']);
                awardPoints(10, `Task ${taskKey}`); showNotification(`Task '${taskKey}' completed! +10 $twote`, 'success');
                updateTaskButtons();
            }, 1500);
        }
        function simulateReferralCompletion() { /* ... (no changes needed) ... */
            console.log("Simulating referral completion..."); awardPoints(20, "Referral Bonus (Simulated)");
            const referralSpinsAwarded = 3; state.wheelSpins.referral = (state.wheelSpins.referral || 0) + referralSpinsAwarded;
            checkAndGrantAchievement('FIRST_REFERRAL');
            saveData(['wheelSpins', 'achievements']); // Save spins and achievements
            showNotification(`Referral sim complete! +20 $twote & +${referralSpinsAwarded} Spins!`, 'success');
            updateUI();
        }
        function copyReferralLink() { /* ... (no changes needed) ... */
            const input = domElements.referralLink; if (!input || !input.value) { showNotification('Referral link not available.', 'error'); return; }
            navigator.clipboard.writeText(input.value).then(() => { showNotification('Referral link copied!', 'success'); }).catch(err => { console.error('Copy failed: ', err); showNotification('Could not copy link.', 'error'); });
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            document.getElementById('profileLink').addEventListener('click', () => showSection('playerProfile'));
            document.getElementById('saveHoroscopeBtn').addEventListener('click', saveHoroscope);
            // Footer Navigation
            document.getElementById('navHome').addEventListener('click', (e) => { e.preventDefault(); showSection('wellnessManager'); });
            document.getElementById('navTasks').addEventListener('click', (e) => { e.preventDefault(); showSection('tasksSection'); });
            document.getElementById('navGame').addEventListener('click', (e) => { e.preventDefault(); showSection('gamePage'); });
            document.getElementById('navProfile').addEventListener('click', (e) => { e.preventDefault(); showSection('playerProfile'); });
            // Game Page Buttons
            document.getElementById('dailyCheckInBtn').addEventListener('click', dailyCheckIn);
            domElements.openMysteryBoxBtn.addEventListener('click', openMysteryBox);
            domElements.claimReferralRewardBtn.addEventListener('click', simulateReferralCompletion);
            // Wheel Buttons (Event Delegation)
            document.querySelector('.wheel-button-grid').addEventListener('click', (event) => {
                const button = event.target.closest('button.wheel-button');
                if (button && button.dataset.wheel) {
                    showWheelModal(button.dataset.wheel);
                }
            });
            // Wheel Modal Spin Button
            domElements.spinTheWheelBtn.addEventListener('click', triggerSpin);
            // Profile Page Buttons
            document.getElementById('deleteProgressBtn').addEventListener('click', deleteProgress);
            document.getElementById('connectWalletBtn').addEventListener('click', () => showNotification('Wallet connection coming soon!', 'info'));
            document.getElementById('airdropWithdrawBtn').addEventListener('click', () => showNotification('Withdrawal feature coming soon!', 'info'));
            // Challenge Options (Delegation)
             domElements.challengeOptions.addEventListener('click', (event) => {
                 const target = event.target;
                 if (target.classList.contains('start-challenge-btn')) {
                     const days = parseInt(target.getAttribute('data-days')); state.currentChallengeDuration = days; showSection('dailyChallenges');
                 } else if (target.classList.contains('enroll-btn')) { showEnrollModal(parseInt(target.getAttribute('data-days'))); }
                 else if (target.classList.contains('attended-btn')) { showCodeModal(parseInt(target.getAttribute('data-days'))); }
             });

             setupBackButton(); // Setup Telegram back button listener
        }

    </script>
</body>
</html>
